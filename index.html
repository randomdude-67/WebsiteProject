<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindustry Clone</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        /* Top Resource Bar */
        #resource-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(180deg, rgba(22, 33, 62, 0.95) 0%, rgba(22, 33, 62, 0.8) 100%);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            z-index: 100;
            border-bottom: 2px solid #333;
        }

        .resource-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .resource-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .resource-count {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            min-width: 40px;
        }

        #wave-display {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #wave-display span {
            color: #ff6b6b;
            font-size: 14px;
        }

        #player-health-bar {
            width: 150px;
            height: 20px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #player-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.2s;
        }

        #player-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 11px;
            text-shadow: 1px 1px 2px black;
        }

        /* Bottom Build Bar */
        #build-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, rgba(22, 33, 62, 0.95) 0%, rgba(22, 33, 62, 0.8) 100%);
            z-index: 100;
            border-top: 2px solid #333;
        }

        #category-tabs {
            display: flex;
            gap: 5px;
            padding: 8px 15px;
            border-bottom: 1px solid #444;
        }

        .category-tab {
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 5px 5px 0 0;
            color: #aaa;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.2s;
        }

        .category-tab:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .category-tab.active {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }

        #building-grid {
            display: flex;
            gap: 8px;
            padding: 12px 15px;
            flex-wrap: wrap;
        }

        .build-btn {
            width: 60px;
            height: 60px;
            border: 2px solid #444;
            border-radius: 8px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .build-btn:hover {
            transform: scale(1.05);
            border-color: #666;
        }

        .build-btn.selected {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .build-btn:disabled,
        .build-btn.unaffordable {
            opacity: 0.5;
        }

        .build-btn:disabled {
            cursor: not-allowed;
        }

        .build-btn .icon {
            font-size: 24px;
        }

        .build-btn .name {
            font-size: 8px;
            color: #fff;
            margin-top: 2px;
        }

        .build-btn .hotkey {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 9px;
            color: #888;
        }

        .build-btn .cost {
            position: absolute;
            bottom: 2px;
            font-size: 8px;
            color: #aaa;
        }

        /* Minimap */
        #minimap {
            position: fixed;
            bottom: 130px;
            right: 10px;
            width: 150px;
            height: 112px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #444;
            border-radius: 5px;
            z-index: 90;
        }

        /* Tooltip - fixed in bottom right */
        .tooltip {
            position: fixed;
            bottom: 130px;
            right: 170px;
            background: linear-gradient(135deg, rgba(22, 33, 62, 0.98), rgba(30, 45, 75, 0.98));
            color: white;
            padding: 14px 18px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            min-width: 240px;
            max-width: 320px;
            border: 2px solid #4CAF50;
            box-shadow: 0 6px 16px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.1);
            display: none;
        }

        .tooltip-title {
            font-weight: bold;
            font-size: 15px;
            color: #4CAF50;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(76, 175, 80, 0.3);
            padding-bottom: 6px;
            text-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

        .tooltip-stat {
            margin: 6px 0;
            color: #ddd;
            line-height: 1.5;
        }

        .tooltip-stat-label {
            color: #4CAF50;
            font-weight: 600;
            margin-right: 6px;
        }

        /* Info panel */
        #info-panel {
            position: fixed;
            top: 60px;
            left: 10px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px;
            border-radius: 5px;
            color: #aaa;
            font-size: 10px;
            z-index: 90;
            max-width: 180px;
            transition: all 0.3s ease;
        }

        #info-panel.collapsed {
            width: 80px;
            height: 30px;
            overflow: hidden;
            padding: 5px 10px;
        }

        #info-panel.collapsed .panel-content {
            display: none;
        }

        #panel-toggle {
            cursor: pointer;
            color: #4CAF50;
            font-weight: bold;
            user-select: none;
            display: inline-block;
            margin-bottom: 5px;
        }

        #panel-toggle:hover {
            color: #66dd66;
        }

        #info-panel b {
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <!-- Top Resource Bar -->
    <div id="resource-bar">
        <div class="resource-item">
            <div class="resource-icon" style="background: #d4a574;"></div>
            <span class="resource-count" id="copper-count">20</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #7799aa;"></div>
            <span class="resource-count" id="lead-count">20</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #444;"></div>
            <span class="resource-count" id="coal-count">0</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #4a7c9b;"></div>
            <span class="resource-count" id="titanium-count">0</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #2a2a2a;"></div>
            <span class="resource-count" id="graphite-count">0</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: linear-gradient(135deg, #d4a574, #7799aa);"></div>
            <span class="resource-count" id="alloy-count">0</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #c9b592;"></div>
            <span class="resource-count" id="sand-count">0</span>
        </div>

        <div id="wave-display">
            <span>Wave: <b id="wave-num">0</b></span>
            <span>Enemies: <b id="enemy-count">0</b></span>
            <span>Next: <b id="next-wave">60s</b></span>
            <div id="player-health-bar">
                <div id="player-health-fill" style="width: 100%"></div>
                <span id="player-health-text">Ship: 100%</span>
            </div>
            <button id="debug-btn" style="margin-left: 10px; padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">âˆž Resources</button>
        </div>
    </div>

    <!-- Bottom Build Bar -->
    <div id="build-bar">
        <div id="category-tabs">
            <button class="category-tab active" data-category="production">Production</button>
            <button class="category-tab" data-category="transport">Transport</button>
            <button class="category-tab" data-category="units">Units</button>
            <button class="category-tab" data-category="power">Power</button>
            <button class="category-tab" data-category="defense">Defense</button>
            <button class="category-tab" data-category="tools">Tools</button>
        </div>
        <div id="building-grid"></div>
    </div>

    <!-- Minimap -->
    <canvas id="minimap"></canvas>

    <!-- Info Panel -->
    <div id="info-panel">
        <div id="panel-toggle" onclick="document.getElementById('info-panel').classList.toggle('collapsed')">
            ðŸ“– Tutorial
        </div>
        <div class="panel-content">
            <b>Controls:</b><br>
            WASD - Move ship<br>
            Click - Place/Mine<br>
            Middle-click - Pick building<br>
            Drag - Place multiple<br>
            Right-click - Delete<br>
            R/Scroll - Rotate<br>
            Space - Start wave<br>
            <br>
            <b>Tips:</b><br>
            Click with no building selected to mine copper/lead<br>
            Drills mine ore deposits<br>
            Conveyors transport to core<br>
            Duo uses copper, Scatter uses lead<br>
            Feed ammo via conveyors!<br>
            Arc turrets need power
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <div id="game"></div>

    <script>
        // Game Constants
        const TILE_SIZE = 32;
        const MAP_WIDTH = 100;
        const MAP_HEIGHT = 75;

        // Player ship
        let player = {
            x: MAP_WIDTH * TILE_SIZE / 2,
            y: MAP_HEIGHT * TILE_SIZE / 2,
            health: 100,
            maxHealth: 100,
            speed: 5,
            angle: 0,
            respawnTimer: 0,
            invulnerable: 0,
            deaths: 0
        };

        // Camera
        let camera = { x: 0, y: 0 };

        // Resources
        let resources = {
            copper: 20,
            lead: 20,
            coal: 0,
            titanium: 0,
            graphite: 0,
            alloy: 0,
            sand: 0
        };

        // Terrain types
        const TERRAIN = {
            GRASS: 0,
            SAND: 1,
            WATER: 2,
            STONE: 3,
            DARK_STONE: 4
        };

        // Building definitions with categories
        const BUILDINGS = {
            drill: {
                category: 'production', cost: { copper: 12 }, health: 40,
                icon: 'â›', name: 'Drill', hotkey: '1',
                desc: 'Mines ore deposits', mineSpeed: 1,
                width: 2, height: 2, buildTime: 500
            },
            'pneumatic-drill': {
                category: 'production', cost: { copper: 45, graphite: 15 }, health: 50,
                icon: 'âš™', name: 'P-Drill', hotkey: '2',
                desc: 'Fast mining 2x speed', mineSpeed: 2,
                width: 2, height: 2, buildTime: 500
            },
            'alloy-drill': {
                category: 'production', cost: { alloy: 45, titanium: 30 }, health: 80,
                icon: 'ðŸ”©', name: 'A-Drill', hotkey: null,
                desc: 'Alloy drill 4x speed', mineSpeed: 4,
                width: 2, height: 2, buildTime: 1000
            },
            'graphite-press': {
                category: 'production', cost: { copper: 60, lead: 40 }, health: 60,
                icon: 'â¬›', name: 'Graphite Press', hotkey: null,
                desc: 'Compresses 2 coal into 1 graphite', craftTime: 2000,
                width: 2, height: 2, buildTime: 1500
            },
            'alloy-factory': {
                category: 'production', cost: { copper: 90, lead: 90 }, health: 60,
                icon: 'ðŸ­', name: 'Alloy Factory', hotkey: null,
                desc: 'Combines lead+titanium into alloy (needs power)', craftTime: 3000, powerUse: 5,
                width: 2, height: 2, buildTime: 2000
            },
            'miner-constructor': {
                category: 'units', cost: { lead: 120, titanium: 120 }, health: 100,
                icon: 'ðŸ—ï¸', name: 'Miner Constructor', hotkey: null,
                desc: 'Builds mining drones (50 lead+titanium, 30s)', craftTime: 30000,
                width: 2, height: 2, buildTime: 3000
            },
            conveyor: {
                category: 'transport', cost: { copper: 1 }, health: 20,
                icon: 'âž¡', name: 'Conveyor', hotkey: '3',
                desc: 'Moves items in one direction', buildTime: 200
            },
            'alloy-conveyor': {
                category: 'transport', cost: { alloy: 3 }, health: 40,
                icon: 'â‡’', name: 'A-Conveyor', hotkey: null,
                desc: 'Fast alloy conveyor 2x speed', speedMult: 2, buildTime: 300
            },
            router: {
                category: 'transport', cost: { copper: 15 }, health: 30,
                icon: 'âœš', name: 'Router', hotkey: '4',
                desc: 'Splits items 3 ways', buildTime: 300
            },
            junction: {
                category: 'transport', cost: { copper: 9, lead: 9 }, health: 25,
                icon: 'â•‹', name: 'Junction', hotkey: '5',
                desc: 'Items pass through', buildTime: 300
            },
            'payload-conveyor': {
                category: 'units', cost: { titanium: 15, alloy: 10 }, health: 35,
                icon: 'âŠž', name: 'Payload Conv', hotkey: null,
                desc: 'Transports miner drones', buildTime: 500,
                width: 2, height: 2
            },
            generator: {
                category: 'power', cost: { copper: 60, lead: 30 }, health: 60,
                icon: 'ðŸ”¥', name: 'Generator', hotkey: '6',
                desc: 'Burns coal for power', powerOutput: 10, coalConsume: 0.1, buildTime: 1000
            },
            'thermal-generator': {
                category: 'power', cost: { graphite: 80, lead: 120, titanium: 50 }, health: 100,
                icon: 'âš¡', name: 'Thermal Gen', hotkey: null,
                desc: 'Burns coal+lead for 30 power', powerOutput: 30, coalConsume: 0.15, leadConsume: 0.1,
                width: 2, height: 2, buildTime: 2000
            },
            'power-node': {
                category: 'power', cost: { copper: 15, lead: 15 }, health: 30,
                icon: 'âš¡', name: 'P-Node', hotkey: '7',
                desc: 'Distributes power', powerRange: 6, buildTime: 500
            },
            turret: {
                category: 'defense', cost: { copper: 60 }, health: 50,
                icon: 'ðŸ”«', name: 'Duo', hotkey: '8',
                desc: 'Rapid fire turret (uses copper)', damage: 8, range: 6, cooldown: 400, ammoType: 'copper', ammoUse: 1, buildTime: 3000
            },
            scatter: {
                category: 'defense', cost: { copper: 90, lead: 60 }, health: 60,
                icon: 'ðŸ’¥', name: 'Scatter', hotkey: '9',
                desc: 'Fires 3 shot spread (uses lead)', damage: 4, range: 10, cooldown: 150, shots: 3, ammoType: 'lead', ammoUse: 2, buildTime: 4000
            },
            laser: {
                category: 'defense', cost: { copper: 120, lead: 90 }, health: 45,
                icon: 'âš¡', name: 'Arc', hotkey: '0',
                desc: 'Electric arc (needs power)', damage: 15, range: 8, cooldown: 800, powerUse: 2, buildTime: 3000
            },
            stormer: {
                category: 'defense', cost: { titanium: 70, copper: 50, lead: 40 }, health: 70,
                icon: 'ðŸŒª', name: 'Stormer', hotkey: null,
                desc: 'Blasts sand like flamethrower, slows enemies', damage: 2, range: 5, cooldown: 100, ammoType: 'sand', ammoUse: 1, slowEffect: 0.5, buildTime: 4000
            },
            wall: {
                category: 'defense', cost: { copper: 6 }, health: 80,
                icon: 'â–ª', name: 'Wall', hotkey: 'Q',
                desc: 'Basic defense', buildTime: 300
            },
            'titanium-wall': {
                category: 'defense', cost: { titanium: 15 }, health: 200,
                icon: 'â–£', name: 'Ti-Wall', hotkey: 'E',
                desc: 'Strong titanium wall', buildTime: 500
            },
            'alloy-wall': {
                category: 'defense', cost: { alloy: 24 }, health: 650,
                icon: 'â–¦', name: 'A-Wall', hotkey: null,
                desc: 'Reinforced alloy wall', buildTime: 1000
            },
            'alloy-turret': {
                category: 'defense', cost: { alloy: 75, titanium: 45 }, health: 100,
                icon: 'ðŸŽ¯', name: 'Salvo', hotkey: null,
                desc: 'Rapid alloy turret (uses alloy)', damage: 12, range: 8, cooldown: 250, ammoType: 'alloy', ammoUse: 1, buildTime: 5000
            },
            explosive: {
                category: 'defense', cost: { copper: 45, coal: 30 }, health: 30,
                icon: 'ðŸ’£', name: 'Bomb', hotkey: 'B',
                desc: 'Explodes when destroyed!', explosionDamage: 80, explosionRange: 3, buildTime: 1000
            },
            repair: {
                category: 'defense', cost: { copper: 75, lead: 45 }, health: 40,
                icon: 'ðŸ”§', name: 'Repair', hotkey: 'F',
                desc: 'Repairs nearby buildings (needs power)', repairRange: 5, powerUse: 1, buildTime: 2000
            },
            delete: {
                category: 'tools', cost: {}, health: 0,
                icon: 'ðŸ—‘', name: 'Delete', hotkey: 'X',
                desc: 'Remove buildings'
            }
        };

        // Game state
        let selectedBuilding = null;
        let miningMode = false;
        let currentCategory = 'production';
        let rotation = 0;
        let miningCooldown = 0;
        let miningTarget = null; // Store current mining target for laser rendering
        let tooltipCollapsed = false; // Track tooltip collapse state
        let buildings = [];
        let constructionQueue = []; // Buildings currently being built
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let items = [];
        let particles = [];
        let miners = []; // Mining drones
        let wave = 0;
        let waveTimer = 240; // Start with 240 seconds (4 minutes - first wave)
        let coreHealth = 500;
        let maxCoreHealth = 500;
        let gameOver = false;
        let isDragging = false;
        let lastDragTile = null;

        // Map data
        let map = [];
        let oreMap = [];
        let terrainMap = [];

        // Spawn point
        let spawnPoint = { x: 5, y: 5 };

        // Power system
        let powerGrid = { production: 0, consumption: 0 };

        // Phaser Config
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            parent: 'game',
            backgroundColor: '#1a1a2e',
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);
        let graphics, scene;
        let keys = {};

        function preload() {}

        function create() {
            scene = this;
            graphics = this.add.graphics();

            // Generate terrain and map
            generateTerrain();
            generateMap();

            // Place core in center
            const coreX = Math.floor(MAP_WIDTH / 2);
            const coreY = Math.floor(MAP_HEIGHT / 2);
            placeCore(coreX, coreY);

            // Set spawn point in corner
            spawnPoint = { x: 3, y: 3 };

            // Center camera on player initially
            player.x = (coreX + 1) * TILE_SIZE;
            player.y = (coreY + 1) * TILE_SIZE;

            // Input handling
            this.input.on('pointerdown', handlePointerDown);
            this.input.on('pointermove', handlePointerMove);
            this.input.on('pointerup', handlePointerUp);

            // Disable context menu
            this.game.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            // Add mouse wheel rotation
            this.game.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    rotation = (rotation + 1) % 4; // Scroll up = rotate clockwise
                } else if (e.deltaY > 0) {
                    rotation = (rotation + 3) % 4; // Scroll down = rotate counter-clockwise
                }
            });

            // Keyboard
            keys = {
                W: this.input.keyboard.addKey('W'),
                A: this.input.keyboard.addKey('A'),
                S: this.input.keyboard.addKey('S'),
                D: this.input.keyboard.addKey('D'),
                R: this.input.keyboard.addKey('R'),
                SPACE: this.input.keyboard.addKey('SPACE')
            };

            this.input.keyboard.on('keydown-R', () => { rotation = (rotation + 1) % 4; });
            this.input.keyboard.on('keydown-SPACE', startWaveEarly);

            // Building hotkeys
            Object.entries(BUILDINGS).forEach(([type, data]) => {
                if (data.hotkey) {
                    const keyCode = data.hotkey === '0' ? 'ZERO' :
                                   data.hotkey === '1' ? 'ONE' :
                                   data.hotkey === '2' ? 'TWO' :
                                   data.hotkey === '3' ? 'THREE' :
                                   data.hotkey === '4' ? 'FOUR' :
                                   data.hotkey === '5' ? 'FIVE' :
                                   data.hotkey === '6' ? 'SIX' :
                                   data.hotkey === '7' ? 'SEVEN' :
                                   data.hotkey === '8' ? 'EIGHT' :
                                   data.hotkey === '9' ? 'NINE' : data.hotkey;
                    this.input.keyboard.on('keydown-' + keyCode, () => selectBuilding(type));
                }
            });

            // Setup UI
            setupBuildUI();
            setupCategoryTabs();

            // Timers
            this.time.addEvent({ delay: 1000, callback: updateWaveTimer, loop: true });
            this.time.addEvent({ delay: 1500, callback: produceTick, loop: true });
            // Items now updated smoothly in main update loop
            this.time.addEvent({ delay: 1000, callback: repairTick, loop: true });
            this.time.addEvent({ delay: 500, callback: powerTick, loop: true });
            
            // Debug button handler
            document.getElementById('debug-btn').addEventListener('click', () => {
                // Give infinite resources (large amount)
                resources.copper = 999999;
                resources.lead = 999999;
                resources.coal = 999999;
                resources.titanium = 999999;
                resources.graphite = 999999;
                resources.alloy = 999999;
                resources.sand = 999999;
                updateResourceUI();
            });
        }

        function generateTerrain() {
            // Add randomness seed for variation
            const seed = Math.random() * 1000;
            
            for (let y = 0; y < MAP_HEIGHT; y++) {
                terrainMap[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    // Multiple noise layers for more organic terrain
                    const noise1 = Math.sin(x * 0.15 + seed) * Math.cos(y * 0.15 + seed);
                    const noise2 = Math.sin(x * 0.08 + seed * 2) * Math.cos(y * 0.12 + seed * 2) * 0.5;
                    const noise3 = Math.sin(x * 0.25 + seed * 3) * Math.cos(y * 0.2 + seed * 3) * 0.3;
                    const noise4 = Math.sin(x * 0.4 + seed * 4) * Math.cos(y * 0.35 + seed * 4) * 0.2;
                    
                    const noise = noise1 + noise2 + noise3 + noise4;
                    
                    // Add random variation
                    const randomFactor = (Math.random() - 0.5) * 0.3;
                    const finalNoise = noise + randomFactor;

                    // Water near edges
                    const edgeDist = Math.min(x, y, MAP_WIDTH - x - 1, MAP_HEIGHT - y - 1);

                    if (edgeDist < 3 && Math.random() < 0.4) {
                        terrainMap[y][x] = TERRAIN.WATER;
                    } else if (finalNoise > 0.7) {
                        terrainMap[y][x] = TERRAIN.STONE;
                    } else if (finalNoise > 0.45) {
                        terrainMap[y][x] = TERRAIN.DARK_STONE;
                    } else if (finalNoise < -0.4) {
                        terrainMap[y][x] = TERRAIN.SAND;
                    } else if (finalNoise < -0.2 && Math.random() < 0.3) {
                        terrainMap[y][x] = TERRAIN.SAND;
                    } else {
                        terrainMap[y][x] = TERRAIN.GRASS;
                    }
                }
            }

            // Clear center area for core
            const cx = Math.floor(MAP_WIDTH / 2);
            const cy = Math.floor(MAP_HEIGHT / 2);
            for (let dy = -3; dy <= 4; dy++) {
                for (let dx = -3; dx <= 4; dx++) {
                    if (cy + dy >= 0 && cy + dy < MAP_HEIGHT && cx + dx >= 0 && cx + dx < MAP_WIDTH) {
                        terrainMap[cy + dy][cx + dx] = TERRAIN.DARK_STONE;
                    }
                }
            }
        }

        function generateMap() {
            for (let y = 0; y < MAP_HEIGHT; y++) {
                map[y] = [];
                oreMap[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    map[y][x] = 0;
                    oreMap[y][x] = null;
                }
            }

            // Generate ore clusters
            const oreTypes = [
                { type: 'copper', count: 12, size: 8 },
                { type: 'lead', count: 8, size: 6 },
                { type: 'coal', count: 6, size: 5 },
                { type: 'titanium', count: 3, size: 4 }
            ];

            oreTypes.forEach(ore => {
                for (let i = 0; i < ore.count; i++) {
                    const cx = Math.floor(Math.random() * (MAP_WIDTH - 6)) + 3;
                    const cy = Math.floor(Math.random() * (MAP_HEIGHT - 6)) + 3;

                    for (let j = 0; j < ore.size; j++) {
                        const ox = cx + Math.floor(Math.random() * 4) - 2;
                        const oy = cy + Math.floor(Math.random() * 4) - 2;
                        if (ox >= 0 && ox < MAP_WIDTH && oy >= 0 && oy < MAP_HEIGHT) {
                            if (terrainMap[oy][ox] !== TERRAIN.WATER) {
                                oreMap[oy][ox] = ore.type;
                            }
                        }
                    }
                }
            });
        }

        function placeCore(x, y) {
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    map[y + dy][x + dx] = 'core';
                    oreMap[y + dy][x + dx] = null;
                }
            }
            buildings.push({
                type: 'core',
                x: x, y: y,
                width: 2, height: 2,
                health: maxCoreHealth,
                maxHealth: maxCoreHealth
            });
        }

        function setupCategoryTabs() {
            document.querySelectorAll('.category-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    currentCategory = tab.dataset.category;
                    renderBuildingGrid();
                });
            });
        }

        function setupBuildUI() {
            renderBuildingGrid();
        }

        function renderBuildingGrid() {
            const grid = document.getElementById('building-grid');
            grid.innerHTML = '';

            Object.entries(BUILDINGS).forEach(([type, data]) => {
                if (data.category !== currentCategory) return;

                const btn = document.createElement('button');
                btn.className = 'build-btn';
                btn.dataset.type = type;
                btn.style.background = getBuildingColor(type);

                btn.innerHTML = `
                    <span class="hotkey">${data.hotkey}</span>
                    <span class="icon">${data.icon}</span>
                    <span class="name">${data.name}</span>
                    <span class="cost">${getCostString(data.cost)}</span>
                `;

                btn.onclick = () => selectBuilding(type);

                if (selectedBuilding === type) {
                    btn.classList.add('selected');
                }

                if (!canAfford(type)) {
                    btn.classList.add('unaffordable');
                    // Don't use disabled attribute - just style it differently
                }

                // Add tooltip on hover
                btn.addEventListener('mouseenter', (e) => {
                    showBuildButtonTooltip(type, data);
                });

                btn.addEventListener('mouseleave', () => {
                    hideBuildButtonTooltip();
                });

                grid.appendChild(btn);
            });
        }

        function showBuildButtonTooltip(type, data) {
            const tooltip = document.querySelector('.tooltip');
            let html = `<div class="tooltip-title">${data.name}</div>`;
            html += `<div class="tooltip-stat">${data.desc}</div>`;
            
            // Show cost with color coding
            if (data.cost && Object.keys(data.cost).length > 0) {
                let costHtml = '<div class="tooltip-stat"><span class="tooltip-stat-label">Cost:</span> ';
                costHtml += Object.entries(data.cost).map(([res, amt]) => {
                    const hasEnough = (resources[res] || 0) >= amt;
                    const current = resources[res] || 0;
                    return `<span style="color:${hasEnough ? getOreColorCSS(res) : '#ff4444'}">${amt} ${res} (${current})</span>`;
                }).join(', ');
                html += costHtml + '</div>';
            }
            
            html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Health:</span> ${data.health}</div>`;
            if (data.damage) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Damage:</span> ${data.damage}</div>`;
            if (data.range) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Range:</span> ${data.range} tiles</div>`;
            if (data.cooldown) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Fire rate:</span> ${(1000/data.cooldown).toFixed(1)}/s</div>`;
            if (data.ammoType) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo type:</span> <span style="color:${getOreColorCSS(data.ammoType)}">${data.ammoType}</span></div>`;
            if (data.ammoUse) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo/shot:</span> ${data.ammoUse}</div>`;
            if (data.powerUse) {
                html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power use:</span> ${data.powerUse}</div>`;
                const surplus = powerGrid.production - powerGrid.consumption;
                const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
            }
            if (data.powerOutput) {
                html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power output:</span> ${data.powerOutput}</div>`;
                const surplus = powerGrid.production - powerGrid.consumption;
                const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
            }
            if (data.powerRange) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power range:</span> ${data.powerRange} tiles</div>`;
            if (data.mineSpeed) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Mine speed:</span> ${data.mineSpeed}x</div>`;
            if (data.repairRange) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Repair range:</span> ${data.repairRange} tiles</div>`;
            if (data.craftTime) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Craft time:</span> ${(data.craftTime/1000).toFixed(1)}s</div>`;
            if (data.slowEffect) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Slow effect:</span> ${(data.slowEffect * 100).toFixed(0)}%</div>`;
            
            tooltip.innerHTML = html;
            tooltip.style.display = 'block';
        }

        function hideBuildButtonTooltip() {
            const tooltip = document.querySelector('.tooltip');
            tooltip.style.display = 'none';
        }

        function getBuildingColor(type) {
            const colors = {
                drill: 'linear-gradient(135deg, #8B4513, #654321)',
                'pneumatic-drill': 'linear-gradient(135deg, #B87333, #8B5A2B)',
                'alloy-drill': 'linear-gradient(135deg, #b8967a, #8a6a5a)',
                'graphite-press': 'linear-gradient(135deg, #333333, #1a1a1a)',
                'alloy-factory': 'linear-gradient(135deg, #887766, #665544)',
                'miner-constructor': 'linear-gradient(135deg, #44aa44, #227722)',
                conveyor: 'linear-gradient(135deg, #555, #333)',
                'alloy-conveyor': 'linear-gradient(135deg, #b8967a, #8a6a5a)',
                'payload-conveyor': 'linear-gradient(135deg, #4a7c9b, #2a5c7b)',
                router: 'linear-gradient(135deg, #666699, #444477)',
                junction: 'linear-gradient(135deg, #996666, #774444)',
                generator: 'linear-gradient(135deg, #ff8800, #cc5500)',
                'thermal-generator': 'linear-gradient(135deg, #ff4400, #aa2200)',
                'power-node': 'linear-gradient(135deg, #ffcc00, #cc9900)',
                turret: 'linear-gradient(135deg, #cc3333, #991111)',
                scatter: 'linear-gradient(135deg, #cc6633, #994411)',
                'alloy-turret': 'linear-gradient(135deg, #b8967a, #cc5555)',
                laser: 'linear-gradient(135deg, #3366cc, #224499)',
                stormer: 'linear-gradient(135deg, #c9b592, #a89572)',
                wall: 'linear-gradient(135deg, #555, #333)',
                'titanium-wall': 'linear-gradient(135deg, #4a7c9b, #2a5c7b)',
                'alloy-wall': 'linear-gradient(135deg, #b8967a, #8a6a5a)',
                explosive: 'linear-gradient(135deg, #ff6600, #cc3300)',
                repair: 'linear-gradient(135deg, #339933, #227722)',
                delete: 'linear-gradient(135deg, #ff4444, #cc2222)'
            };
            return colors[type] || '#444';
        }

        function getCostString(cost) {
            if (!cost || Object.keys(cost).length === 0) return '';
            return Object.entries(cost).map(([res, amt]) => {
                const abbrev = { copper: 'Cu', lead: 'Pb', coal: 'C', titanium: 'Ti', graphite: 'Gr', alloy: 'Al', sand: 'Sd' };
                return amt + abbrev[res];
            }).join(' ');
        }

        function selectBuilding(type) {
            selectedBuilding = type;
            miningMode = false; // Turn off mining mode when selecting a building
            renderBuildingGrid();

            // Switch to correct category
            if (type && BUILDINGS[type]) {
                const cat = BUILDINGS[type].category;
                if (cat !== currentCategory) {
                    currentCategory = cat;
                    document.querySelectorAll('.category-tab').forEach(t => {
                        t.classList.toggle('active', t.dataset.category === cat);
                    });
                    renderBuildingGrid();
                }
            }
        }

        function canAfford(type) {
            const data = BUILDINGS[type];
            if (!data || !data.cost) return true;
            for (let res in data.cost) {
                if ((resources[res] || 0) < data.cost[res]) return false;
            }
            return true;
        }

        function spend(type) {
            const data = BUILDINGS[type];
            if (!data || !data.cost) return;
            for (let res in data.cost) {
                resources[res] -= data.cost[res];
            }
            updateResourceUI();
        }

        function screenToWorld(screenX, screenY) {
            return {
                x: screenX + camera.x,
                y: screenY + camera.y
            };
        }

        function worldToTile(worldX, worldY) {
            return {
                x: Math.floor(worldX / TILE_SIZE),
                y: Math.floor(worldY / TILE_SIZE)
            };
        }

        function handlePointerDown(pointer) {
            if (gameOver) return;

            const world = screenToWorld(pointer.x, pointer.y);
            const tile = worldToTile(world.x, world.y);

            // Middle click - pick building type
            if (pointer.middleButtonDown()) {
                const building = buildings.find(b => {
                    if (b.type === 'core') return false; // Can't pick core
                    const w = b.width || 1;
                    const h = b.height || 1;
                    return tile.x >= b.x && tile.x < b.x + w && tile.y >= b.y && tile.y < b.y + h;
                });
                
                if (building) {
                    selectBuilding(building.type);
                }
                return;
            }

            if (pointer.rightButtonDown()) {
                // Right click - deselect or delete
                if (selectedBuilding) {
                    selectBuilding(null);
                } else {
                    deleteBuilding(tile.x, tile.y);
                }
                return;
            }

            // Left click when no building selected - toggle mining mode or mine
            if (!selectedBuilding) {
                miningMode = !miningMode;
                if (miningMode) {
                    manualMine();
                }
                return;
            }

            // Start drag placement if building is selected
            isDragging = true;
            lastDragTile = tile;
            tryPlaceBuilding(tile.x, tile.y);
        }

        function handlePointerMove(pointer) {
            if (!isDragging || !selectedBuilding) return;

            const world = screenToWorld(pointer.x, pointer.y);
            const tile = worldToTile(world.x, world.y);

            if (lastDragTile && (tile.x !== lastDragTile.x || tile.y !== lastDragTile.y)) {
                if (selectedBuilding === 'delete') {
                    // Drag deleting
                    tryDeleteBuilding(tile.x, tile.y);
                } else {
                    // Drag placing
                    tryPlaceBuilding(tile.x, tile.y);
                }
                lastDragTile = tile;
            }

            // Update tooltip
            updateTooltip(pointer, tile);
        }

        function handlePointerUp() {
            isDragging = false;
            lastDragTile = null;
        }

        function updateTooltip(pointer, tile) {
            const tooltip = document.getElementById('tooltip');

            if (tile.x >= 0 && tile.x < MAP_WIDTH && tile.y >= 0 && tile.y < MAP_HEIGHT) {
                const building = buildings.find(b =>
                    (b.x === tile.x && b.y === tile.y) ||
                    (b.type === 'core' && tile.x >= b.x && tile.x < b.x + 2 && tile.y >= b.y && tile.y < b.y + 2)
                );

                if (building) {
                    const data = BUILDINGS[building.type] || { desc: 'Your main base - protect it!', health: 500 };
                    const healthPct = Math.ceil((building.health / building.maxHealth) * 100);
                    const healthColor = healthPct > 50 ? '#4CAF50' : (healthPct > 25 ? '#ffaa00' : '#ff4444');

                    let html = `<div class="tooltip-title" style="cursor:pointer;user-select:none;" onclick="tooltipCollapsed = !tooltipCollapsed">${building.type === 'core' ? 'Core' : data.name} <span style="font-size:12px">${tooltipCollapsed ? 'â–¶' : 'â–¼'}</span></div>`;

                    if (!tooltipCollapsed) {
                        html += `<div class="tooltip-stat">${data.desc}</div>`;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Health:</span> <span style="color:${healthColor}">${Math.ceil(building.health)}/${building.maxHealth}</span></div>`;

                        // Show stored items
                        let hasStorage = false;
                        let storageHtml = '';
                        if (building.coalStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Coal:</span> <span style="color:${getOreColorCSS('coal')}">${Math.floor(building.coalStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (building.leadStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Lead:</span> <span style="color:${getOreColorCSS('lead')}">${Math.floor(building.leadStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (building.titaniumStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Titanium:</span> <span style="color:${getOreColorCSS('titanium')}">${Math.floor(building.titaniumStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (building.graphiteStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Graphite:</span> <span style="color:${getOreColorCSS('graphite')}">${Math.floor(building.graphiteStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (building.alloyStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Alloy:</span> <span style="color:${getOreColorCSS('alloy')}">${Math.floor(building.alloyStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (hasStorage) {
                            html += `<div style="margin-top:6px;border-top:1px solid #444;padding-top:6px">${storageHtml}</div>`;
                        }
                    } else {
                        html += `<div class="tooltip-stat" style="color:#888;font-size:11px">Click to expand...</div>`;
                    }

                    if (!tooltipCollapsed) {

                    if (data.damage) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Damage:</span> ${data.damage}</div>`;
                    if (data.range) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Range:</span> ${data.range} tiles</div>`;
                    if (data.cooldown) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Fire rate:</span> ${(1000/data.cooldown).toFixed(1)}/s</div>`;
                    if (data.ammoType) {
                        const ammoColor = getOreColorCSS(data.ammoType);
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo type:</span> <span style="color:${ammoColor}">${data.ammoType}</span></div>`;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo/shot:</span> ${data.ammoUse}</div>`;
                    }
                    if (building.ammo !== undefined) {
                        const hasAmmo = building.ammo > 0;
                        const ammoPct = (building.ammo / (building.maxAmmo || 20)) * 100;
                        const ammoBarColor = ammoPct > 30 ? '#4CAF50' : '#ff4444';
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo:</span> <span style="color:${ammoBarColor}">${building.ammo}/${building.maxAmmo || 20}</span></div>`;
                        if (!hasAmmo) html += `<div class="tooltip-stat" style="color:#ff8844">âš  Feed ${BUILDINGS[building.type]?.ammoType || 'ammo'} via conveyor!</div>`;
                    }
                    if (data.powerUse) {
                        const powered = building.powered;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power:</span> <span style="color:${powered ? '#4CAF50' : '#ff4444'}">${powered ? 'âœ“ Connected' : 'âœ— NONE'}</span></div>`;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power use:</span> ${data.powerUse}</div>`;
                        
                        // Show grid surplus/deficit
                        const surplus = powerGrid.production - powerGrid.consumption;
                        const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                        const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
                    }
                    if (data.powerOutput) {
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power output:</span> ${data.powerOutput}</div>`;
                        
                        // Show grid surplus/deficit for generators too
                        const surplus = powerGrid.production - powerGrid.consumption;
                        const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                        const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
                    }
                    if (building.ore) {
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Mining:</span> <span style="color:${getOreColorCSS(building.ore)}">${building.ore}</span></div>`;
                        // Show ore count and speed bonus for drills
                        if (building.oreCount !== undefined && building.type && (building.type === 'drill' || building.type === 'pneumatic-drill' || building.type === 'alloy-drill')) {
                            const speedMultiplier = 1 + (building.oreCount - 1) * 0.25;
                            const effectiveSpeed = data.mineSpeed * speedMultiplier;
                            html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ore tiles:</span> ${building.oreCount}/4</div>`;
                            html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Effective speed:</span> ${effectiveSpeed.toFixed(2)}x <span style="color:#4CAF50">(+${((speedMultiplier - 1) * 100).toFixed(0)}%)</span></div>`;
                        }
                    }
                    if (data.mineSpeed) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Base speed:</span> ${data.mineSpeed}x</div>`;
                    if (data.repairRange) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Repair range:</span> ${data.repairRange} tiles</div>`;

                    // Position info
                    html += `<div class="tooltip-stat" style="margin-top:8px;color:#666;font-size:10px">Position: (${building.x}, ${building.y})</div>`;
                    } // Close tooltipCollapsed check

                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';
                } else if (oreMap[tile.y] && oreMap[tile.y][tile.x]) {
                    const ore = oreMap[tile.y][tile.x];
                    const oreColor = getOreColorCSS(ore);
                    let html = `<div class="tooltip-title" style="color:${oreColor}">${ore.charAt(0).toUpperCase() + ore.slice(1)} Ore</div>`;
                    html += `<div class="tooltip-stat">Place a drill here to mine</div>`;
                    html += `<div class="tooltip-stat" style="margin-top:8px;color:#666;font-size:10px">Position: (${tile.x}, ${tile.y})</div>`;
                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';
                } else if (selectedBuilding && BUILDINGS[selectedBuilding]) {
                    // Show selected building info when hovering empty tile
                    const data = BUILDINGS[selectedBuilding];
                    let html = `<div class="tooltip-title">${data.name}</div>`;
                    html += `<div class="tooltip-stat">${data.desc}</div>`;
                    // Show cost
                    if (data.cost && Object.keys(data.cost).length > 0) {
                        let costHtml = '<div class="tooltip-stat"><span class="tooltip-stat-label">Cost:</span> ';
                        costHtml += Object.entries(data.cost).map(([res, amt]) => {
                            const hasEnough = (resources[res] || 0) >= amt;
                            return `<span style="color:${hasEnough ? getOreColorCSS(res) : '#ff4444'}">${amt} ${res}</span>`;
                        }).join(', ');
                        html += costHtml + '</div>';
                    }
                    html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Health:</span> ${data.health}</div>`;
                    if (data.damage) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Damage:</span> ${data.damage}</div>`;
                    if (data.range) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Range:</span> ${data.range} tiles</div>`;
                    if (data.ammoType) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo type:</span> <span style="color:${getOreColorCSS(data.ammoType)}">${data.ammoType}</span></div>`;
                    if (data.powerUse) {
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power use:</span> ${data.powerUse}</div>`;
                        const surplus = powerGrid.production - powerGrid.consumption;
                        const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                        const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
                    }
                    if (data.powerOutput) {
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power output:</span> ${data.powerOutput}</div>`;
                        const surplus = powerGrid.production - powerGrid.consumption;
                        const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                        const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
                    }
                    if (data.mineSpeed) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Mine speed:</span> ${data.mineSpeed}x</div>`;
                    if (data.explosionDamage) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Explosion:</span> ${data.explosionDamage} dmg, ${data.explosionRange} range</div>`;
                    html += `<div class="tooltip-stat" style="margin-top:8px;color:#666;font-size:10px">Position: (${tile.x}, ${tile.y})</div>`;
                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';
                } else {
                    // Show terrain info
                    const terrain = terrainMap[tile.y][tile.x];
                    const terrainNames = { 0: 'Grass', 1: 'Sand', 2: 'Water', 3: 'Stone', 4: 'Dark Stone' };
                    let html = `<div class="tooltip-title" style="color:#888">${terrainNames[terrain] || 'Unknown'}</div>`;
                    if (terrain === 2) {
                        html += `<div class="tooltip-stat" style="color:#ff6666">Cannot build here</div>`;
                    } else {
                        html += `<div class="tooltip-stat">Empty tile</div>`;
                    }
                    html += `<div class="tooltip-stat" style="margin-top:8px;color:#666;font-size:10px">Position: (${tile.x}, ${tile.y})</div>`;
                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';
                }
            } else {
                tooltip.style.display = 'none';
            }
        }

        function getOreColorCSS(type) {
            const colors = { copper: '#d4a574', lead: '#888899', coal: '#666666', titanium: '#4a7c9b', graphite: '#2a2a2a', alloy: '#b8967a', sand: '#c9b592' };
            return colors[type] || '#ffffff';
        }

        function getOreColor(type) {
            const colors = { copper: 0xd4a574, lead: 0x888899, coal: 0x444444, titanium: 0x4a7c9b, graphite: 0x2a2a2a, alloy: 0xb8967a, sand: 0xc9b592 };
            return colors[type] || 0xffffff;
        }

        function tryDeleteBuilding(x, y) {
            if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return;
            deleteBuilding(x, y);
        }

        function tryPlaceBuilding(x, y) {
            if (!selectedBuilding) return;
            if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return;

            if (selectedBuilding === 'delete') {
                deleteBuilding(x, y);
                return;
            }

            const data = BUILDINGS[selectedBuilding];
            const width = data.width || 1;
            const height = data.height || 1;

            // Check if all tiles are available for 2x2 buildings
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    if (checkX >= MAP_WIDTH || checkY >= MAP_HEIGHT) return;
                    if (map[checkY][checkX] !== 0) return;
                    if (terrainMap[checkY][checkX] === TERRAIN.WATER) return;
                }
            }

            if (!canAfford(selectedBuilding)) return;

            const isDrill = selectedBuilding === 'drill' || selectedBuilding === 'pneumatic-drill' || selectedBuilding === 'alloy-drill';
            if (isDrill) {
                // For 2x2 drills, check if ANY of the 4 tiles has ore OR is sand
                let hasOreOrSand = false;
                for (let dy = 0; dy < height; dy++) {
                    for (let dx = 0; dx < width; dx++) {
                        if ((oreMap[y + dy] && oreMap[y + dy][x + dx]) || 
                            (terrainMap[y + dy] && terrainMap[y + dy][x + dx] === TERRAIN.SAND)) {
                            hasOreOrSand = true;
                            break;
                        }
                    }
                    if (hasOreOrSand) break;
                }
                if (!hasOreOrSand) return;
            }

            spend(selectedBuilding);

            const building = {
                type: selectedBuilding,
                x: x, y: y,
                rotation: rotation,
                health: data.health,
                maxHealth: data.health,
                cooldown: 0,
                stored: 0,
                powered: false,
                ammo: 0,
                width: width,
                height: height,
                buildProgress: 0,
                isConstructing: true
            };

            if (isDrill) {
                // For 2x2 drills, count all ore tiles and pick highest priority
                // Priority: Sand < Coal < Copper < Lead < Titanium
                // Note: Titanium can only be mined by pneumatic-drill and alloy-drill
                const orePriority = { sand: 1, coal: 2, copper: 3, lead: 4, titanium: 5 };
                let highestPriorityOre = null;
                let highestPriority = 0;
                let oreCount = 0;
                const canMineTitanium = selectedBuilding === 'pneumatic-drill' || selectedBuilding === 'alloy-drill';
                
                for (let dy = 0; dy < height; dy++) {
                    for (let dx = 0; dx < width; dx++) {
                        let foundOre = null;
                        if (oreMap[y + dy] && oreMap[y + dy][x + dx]) {
                            foundOre = oreMap[y + dy][x + dx];
                            // Skip titanium if drill can't mine it
                            if (foundOre === 'titanium' && !canMineTitanium) {
                                continue;
                            }
                        } else if (terrainMap[y + dy] && terrainMap[y + dy][x + dx] === TERRAIN.SAND) {
                            foundOre = 'sand';
                        }
                        
                        if (foundOre) {
                            oreCount++;
                            const priority = orePriority[foundOre] || 0;
                            if (priority > highestPriority) {
                                highestPriority = priority;
                                highestPriorityOre = foundOre;
                            }
                        }
                    }
                }
                
                building.ore = highestPriorityOre;
                building.oreCount = oreCount; // Store count for speed bonus
            }

            if (selectedBuilding === 'generator') {
                building.coalStored = 0;
                building.active = false;
            }

            if (selectedBuilding === 'thermal-generator') {
                building.coalStored = 0;
                building.leadStored = 0;
                building.active = false;
            }

            // Alloy factory stores lead and titanium
            if (selectedBuilding === 'alloy-factory') {
                building.leadStored = 0;
                building.titaniumStored = 0;
                building.craftProgress = 0;
                building.powered = false;
            }

            // Miner constructor stores lead and titanium
            if (selectedBuilding === 'miner-constructor') {
                building.leadStored = 0;
                building.titaniumStored = 0;
                building.craftProgress = 0;
            }

            // Graphite press stores coal
            if (selectedBuilding === 'graphite-press') {
                building.coalStored = 0;
                building.craftProgress = 0;
            }

            // Turrets start with NO ammo - must be fed via conveyors
            if (selectedBuilding === 'turret' || selectedBuilding === 'scatter' || selectedBuilding === 'alloy-turret' || selectedBuilding === 'stormer') {
                building.ammo = 0;
                building.maxAmmo = 20;
            }

            // Add to construction queue instead of directly to buildings
            constructionQueue.push(building);

            // Mark tiles as occupied immediately to prevent overlapping placements
            if (width > 1 || height > 1) {
                for (let dy = 0; dy < height; dy++) {
                    for (let dx = 0; dx < width; dx++) {
                        map[y + dy][x + dx] = 'constructing';
                    }
                }
            } else {
                map[y][x] = 'constructing';
            }

            spawnParticles(x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2, 0xffaa00, 5);
        }

        function deleteBuilding(x, y) {
            // First check construction queue
            let constructionIdx = constructionQueue.findIndex(b => {
                const w = b.width || 1;
                const h = b.height || 1;
                return x >= b.x && x < b.x + w && y >= b.y && y < b.y + h;
            });

            if (constructionIdx !== -1) {
                const b = constructionQueue[constructionIdx];
                const data = BUILDINGS[b.type];
                const w = b.width || 1;
                const h = b.height || 1;

                // Refund full cost for buildings under construction
                if (data && data.cost) {
                    for (let res in data.cost) {
                        resources[res] += data.cost[res];
                    }
                    updateResourceUI();
                }

                // Remove from construction queue
                constructionQueue.splice(constructionIdx, 1);

                // Clear tiles
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        map[b.y + dy][b.x + dx] = 0;
                    }
                }

                spawnParticles(b.x * TILE_SIZE + TILE_SIZE/2, b.y * TILE_SIZE + TILE_SIZE/2, 0xff4444, 5);
                return;
            }

            // Then check completed buildings
            let idx = buildings.findIndex(b => {
                if (b.type === 'core') return false;
                const w = b.width || 1;
                const h = b.height || 1;
                return x >= b.x && x < b.x + w && y >= b.y && y < b.y + h;
            });
            if (idx !== -1) {
                let b = buildings[idx];

                // Resolve to master if it's a tile reference
                if (b.isTileRef) {
                    b = b.master;
                    idx = buildings.indexOf(b);
                }

                const data = BUILDINGS[b.type];
                const w = b.width || 1;
                const h = b.height || 1;

                if (data && data.cost) {
                    for (let res in data.cost) {
                        resources[res] += Math.floor(data.cost[res] * 0.5);
                    }
                    updateResourceUI();
                }

                // Remove master and all tile references
                if (b.isMaster) {
                    buildings = buildings.filter(building => {
                        if (building === b) return false;
                        if (building.isTileRef && building.master === b) return false;
                        return true;
                    });
                } else {
                    buildings.splice(idx, 1);
                }

                // Clear all tiles
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        map[b.y + dy][b.x + dx] = 0;
                    }
                }

                spawnParticles(b.x * TILE_SIZE + TILE_SIZE/2, b.y * TILE_SIZE + TILE_SIZE/2, 0xff4444, 5);
            }
        }

        function destroyBuilding(building) {
            const idx = buildings.indexOf(building);
            if (idx !== -1 && building.type !== 'core') {
                // Check if explosive - trigger explosion
                if (building.type === 'explosive') {
                    const expData = BUILDINGS.explosive;
                    const expRange = expData.explosionRange * TILE_SIZE;
                    const expDamage = expData.explosionDamage;
                    const targetX = building.x * TILE_SIZE + TILE_SIZE / 2;
                    const targetY = building.y * TILE_SIZE + TILE_SIZE / 2;

                    // Damage enemies in range
                    enemies.forEach(e => {
                        const dx = e.x - targetX;
                        const dy = e.y - targetY;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < expRange) {
                            const falloff = 1 - (dist / expRange);
                            e.health -= expDamage * falloff;
                            spawnParticles(e.x, e.y, 0xff6600, 5);
                        }
                    });

                    // Explosion particles (reduced for performance)
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 5 + 2;
                        particles.push({
                            x: targetX,
                            y: targetY,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            color: Math.random() > 0.5 ? 0xff6600 : 0xffcc00,
                            life: Math.random() * 30 + 20
                        });
                    }
                }

                // Remove from map - handle multi-tile buildings
                const w = building.width || 1;
                const h = building.height || 1;
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        map[building.y + dy][building.x + dx] = 0;
                    }
                }
                
                buildings.splice(idx, 1);
                spawnParticles(building.x * TILE_SIZE + TILE_SIZE/2, building.y * TILE_SIZE + TILE_SIZE/2, 0x666666, 10);
            }
        }

        function produceTick() {
            buildings.forEach(b => {
                if ((b.type === 'drill' || b.type === 'pneumatic-drill' || b.type === 'alloy-drill') && b.ore) {
                    const data = BUILDINGS[b.type];
                    // Speed bonus: each ore tile adds 25% speed (1 tile = 1x, 2 tiles = 1.25x, 3 tiles = 1.5x, 4 tiles = 1.75x)
                    const oreCount = b.oreCount || 1;
                    const speedMultiplier = 1 + (oreCount - 1) * 0.25;
                    b.stored = (b.stored || 0) + data.mineSpeed * speedMultiplier;
                    if (b.stored >= 2) {
                        outputItem(b, b.ore);
                        b.stored = 0;
                    }
                }
            });
        }

        // Ammo tick removed - turrets now get ammo from conveyor items only

        function powerTick() {
            let totalProduction = 0;
            let totalConsumption = 0;

            buildings.forEach(b => {
                if (b.type === 'generator') {
                    const data = BUILDINGS.generator;
                    if (b.coalStored > data.coalConsume) {
                        b.coalStored -= data.coalConsume;
                        b.active = true;
                        totalProduction += data.powerOutput;
                    } else {
                        b.active = false;
                    }
                }
                if (b.type === 'thermal-generator') {
                    const data = BUILDINGS['thermal-generator'];
                    if (b.coalStored > data.coalConsume && b.leadStored > data.leadConsume) {
                        b.coalStored -= data.coalConsume;
                        b.leadStored -= data.leadConsume;
                        b.active = true;
                        totalProduction += data.powerOutput;
                    } else {
                        b.active = false;
                    }
                }
            });

            // Count power consumers
            buildings.forEach(b => {
                if (b.type === 'laser') {
                    totalConsumption += BUILDINGS.laser.powerUse;
                }
                if (b.type === 'alloy-factory') {
                    totalConsumption += BUILDINGS['alloy-factory'].powerUse;
                }
                if (b.type === 'repair') {
                    totalConsumption += BUILDINGS.repair.powerUse;
                }
                if (b.type === 'miner-constructor' && b.craftProgress > 0) {
                    totalConsumption += 20; // 20 power when crafting
                }
            });

            // Calculate power efficiency (everything runs slower when low on power)
            const powerEfficiency = totalConsumption > 0 ? 
                Math.min(1.0, totalProduction / totalConsumption) : 1.0;

            // Power all connected consumers (they all run but slower if not enough power)
            buildings.filter(b => b.type === 'laser' || b.type === 'alloy-factory' || b.type === 'repair').forEach(consumer => {
                const cx = consumer.x * TILE_SIZE + TILE_SIZE/2;
                const cy = consumer.y * TILE_SIZE + TILE_SIZE/2;

                const connected = buildings.some(node => {
                    // Power nodes can connect to generators, other power nodes, and any building that produces power
                    if (node.type !== 'power-node' && node.type !== 'generator' && node.type !== 'thermal-generator') return false;
                    const nx = node.x * TILE_SIZE + TILE_SIZE/2;
                    const ny = node.y * TILE_SIZE + TILE_SIZE/2;
                    const dist = Math.sqrt((cx - nx)**2 + (cy - ny)**2);
                    return dist <= BUILDINGS['power-node'].powerRange * TILE_SIZE;
                });

                consumer.powered = connected;
                consumer.powerEfficiency = connected ? powerEfficiency : 0;
            });

            // Construction queue - progress buildings under construction (iterate backwards to safely remove)
            for (let i = constructionQueue.length - 1; i >= 0; i--) {
                const building = constructionQueue[i];
                const buildTime = BUILDINGS[building.type].buildTime || 0;

                if (buildTime === 0) {
                    // Instant build (like core or buildings without buildTime)
                    building.isConstructing = false;
                    building.buildProgress = buildTime;
                } else {
                    // Progress construction by 500ms per tick
                    building.buildProgress += 500;
                }

                // Check if construction is complete
                if (building.buildProgress >= buildTime) {
                    // Remove from construction queue
                    constructionQueue.splice(i, 1);
                    building.isConstructing = false;

                    // Add to buildings array
                    const width = building.width || 1;
                    const height = building.height || 1;

                    buildings.push(building);

                    // For 2x2 buildings, create tile references
                    if (width > 1 || height > 1) {
                        building.isMaster = true;
                        building.tileX = building.x;
                        building.tileY = building.y;

                        for (let dy = 0; dy < height; dy++) {
                            for (let dx = 0; dx < width; dx++) {
                                if (dx === 0 && dy === 0) continue; // Skip top-left (master)

                                const tileRef = new Proxy({
                                    _isTileRef: true,
                                    _master: building,
                                    _x: building.x + dx,
                                    _y: building.y + dy
                                }, {
                                    get(target, prop) {
                                        if (prop === 'isTileRef') return true;
                                        if (prop === 'master') return target._master;
                                        if (prop === 'x') return target._x;
                                        if (prop === 'y') return target._y;
                                        if (prop === 'width') return 1;
                                        if (prop === 'height') return 1;
                                        return target._master[prop];
                                    },
                                    set(target, prop, value) {
                                        if (prop === 'x' || prop === 'y') {
                                            target['_' + prop] = value;
                                            return true;
                                        }
                                        target._master[prop] = value;
                                        return true;
                                    }
                                });

                                buildings.push(tileRef);
                                map[building.y + dy][building.x + dx] = building.type;
                            }
                        }
                        map[building.y][building.x] = building.type;
                    } else {
                        map[building.y][building.x] = building.type;
                    }

                    spawnParticles(building.x * TILE_SIZE + TILE_SIZE/2, building.y * TILE_SIZE + TILE_SIZE/2, 0x44ff44, 8);
                }
            }

            // Graphite press crafting (no power required)
            buildings.filter(b => b.type === 'graphite-press').forEach(press => {
                if ((press.coalStored || 0) >= 2) {
                    press.craftProgress = (press.craftProgress || 0) + 500; // Progress per tick (500ms)
                    if (press.craftProgress >= BUILDINGS['graphite-press'].craftTime) {
                        press.craftProgress = 0;
                        press.coalStored -= 2;
                        // Output graphite
                        outputItem(press, 'graphite');
                    }
                }
            });

            // Alloy factory crafting (slower when low power)
            buildings.filter(b => b.type === 'alloy-factory').forEach(factory => {
                if (factory.powered && (factory.leadStored || 0) >= 1 && (factory.titaniumStored || 0) >= 1) {
                    const progressRate = 500 * (factory.powerEfficiency || 0); // Slowed by power efficiency
                    factory.craftProgress = (factory.craftProgress || 0) + progressRate;
                    if (factory.craftProgress >= BUILDINGS['alloy-factory'].craftTime) {
                        factory.craftProgress = 0;
                        factory.leadStored = (factory.leadStored || 0) - 1;
                        factory.titaniumStored = (factory.titaniumStored || 0) - 1;
                        // Output alloy
                        outputItem(factory, 'alloy');
                    }
                }
            });

            // Miner constructor crafting (uses 20 power when active)
            buildings.filter(b => b.type === 'miner-constructor').forEach(constructor => {
                if (constructor.leadStored >= 50 && constructor.titaniumStored >= 50) {
                    // Craft speed affected by powerEfficiency, but always makes some progress (min 20%)
                    const effectivePower = Math.max(0.2, powerEfficiency); // Minimum 20% speed even with no power
                    constructor.craftProgress = (constructor.craftProgress || 0) + (500 * effectivePower); // Progress per tick (500ms)
                    if (constructor.craftProgress >= BUILDINGS['miner-constructor'].craftTime) {
                        constructor.craftProgress = 0;
                        constructor.leadStored -= 50;
                        constructor.titaniumStored -= 50;
                        // Spawn a miner unit
                        spawnMiner(constructor);
                    }
                }
            });

            powerGrid.production = totalProduction;
            powerGrid.consumption = totalConsumption;
        }

        function spawnMiner(constructor) {
            // Determine which ore to target based on current resources
            // Target lead if more copper, target copper if more lead
            const targetOreType = (resources.copper || 0) > (resources.lead || 0) ? 'lead' : 'copper';
            
            // Find nearest ore of target type
            let nearestOre = null;
            let nearestDist = Infinity;
            const constructorCenterX = constructor.x + 1;
            const constructorCenterY = constructor.y + 1;
            
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const ore = oreMap[y] && oreMap[y][x];
                    if (ore === targetOreType) {
                        const dist = Math.sqrt((x - constructorCenterX) ** 2 + (y - constructorCenterY) ** 2);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestOre = { x, y, type: ore };
                        }
                    }
                }
            }
            
            // If no ore of target type found, try the other type
            if (!nearestOre) {
                const fallbackType = targetOreType === 'copper' ? 'lead' : 'copper';
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        const ore = oreMap[y] && oreMap[y][x];
                        if (ore === fallbackType) {
                            const dist = Math.sqrt((x - constructorCenterX) ** 2 + (y - constructorCenterY) ** 2);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestOre = { x, y, type: ore };
                            }
                        }
                    }
                }
            }
            
            if (nearestOre) {
                miners.push({
                    x: (constructor.x + 1) * TILE_SIZE,
                    y: (constructor.y + 1) * TILE_SIZE,
                    targetX: nearestOre.x,
                    targetY: nearestOre.y,
                    oreType: nearestOre.type,
                    miningCooldown: 0,
                    health: 50,
                    maxHealth: 50
                });
                spawnParticles((constructor.x + 1) * TILE_SIZE, (constructor.y + 1) * TILE_SIZE, 0x44ff44, 8);
            }
        }

        function outputItem(building, itemType) {
            // For drills, check all edges of the 2x2 drill
            const isDrill = building.type === 'drill' || building.type === 'pneumatic-drill' || building.type === 'alloy-drill';
            
            if (isDrill) {
                // For 2x2 drills, check all tiles on all 4 edges
                const width = building.width || 1;
                const height = building.height || 1;
                const edges = [];
                
                // Right edge
                for (let dy = 0; dy < height; dy++) {
                    edges.push({ x: building.x + width, y: building.y + dy });
                }
                // Left edge
                for (let dy = 0; dy < height; dy++) {
                    edges.push({ x: building.x - 1, y: building.y + dy });
                }
                // Bottom edge
                for (let dx = 0; dx < width; dx++) {
                    edges.push({ x: building.x + dx, y: building.y + height });
                }
                // Top edge
                for (let dx = 0; dx < width; dx++) {
                    edges.push({ x: building.x + dx, y: building.y - 1 });
                }
                
                for (const pos of edges) {
                    if (pos.x < 0 || pos.x >= MAP_WIDTH || pos.y < 0 || pos.y >= MAP_HEIGHT) continue;
                    
                    const target = buildings.find(t =>
                        t.x === pos.x && t.y === pos.y ||
                        (t.type === 'core' && pos.x >= t.x && pos.x < t.x + 2 && pos.y >= t.y && pos.y < t.y + 2)
                    );
                    
                    if (target && tryOutputToTarget(building, target, pos.x, pos.y, itemType)) {
                        return; // Successfully output, stop checking
                    }
                }
            } else {
                // For 2x2 buildings, check all edges for valid conveyors (not just rotation direction)
                const width = building.width || 1;
                const height = building.height || 1;

                // Generate all possible output positions on all edges
                const outputPositions = [];
                if (width === 2 && height === 2) {
                    // Right edge
                    outputPositions.push({ x: building.x + 2, y: building.y });
                    outputPositions.push({ x: building.x + 2, y: building.y + 1 });
                    // Left edge
                    outputPositions.push({ x: building.x - 1, y: building.y });
                    outputPositions.push({ x: building.x - 1, y: building.y + 1 });
                    // Bottom edge
                    outputPositions.push({ x: building.x, y: building.y + 2 });
                    outputPositions.push({ x: building.x + 1, y: building.y + 2 });
                    // Top edge
                    outputPositions.push({ x: building.x, y: building.y - 1 });
                    outputPositions.push({ x: building.x + 1, y: building.y - 1 });
                } else {
                    // For 1x1, use rotation direction
                    const dir = getDirection(building.rotation);
                    outputPositions.push({ x: building.x + dir.x, y: building.y + dir.y });
                }

                // Try each output position
                for (const pos of outputPositions) {
                    if (pos.x < 0 || pos.x >= MAP_WIDTH || pos.y < 0 || pos.y >= MAP_HEIGHT) continue;

                    const target = buildings.find(t => {
                        // Check exact tile match
                        if (t.x === pos.x && t.y === pos.y) return true;
                        // Check 2x2 buildings
                        const w = t.width || 1;
                        const h = t.height || 1;
                        if (w > 1 || h > 1) {
                            return pos.x >= t.x && pos.x < t.x + w && pos.y >= t.y && pos.y < t.y + h;
                        }
                        return false;
                    });

                    if (target && tryOutputToTarget(building, target, pos.x, pos.y, itemType)) {
                        return; // Successfully output
                    }
                }
            }
        }

        function tryOutputToTarget(building, target, outX, outY, itemType) {
            if (target.type === 'core') {
                resources[itemType] = (resources[itemType] || 0) + 1;
                updateResourceUI();
                spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                return true;
            } else if (target.type === 'generator' && itemType === 'coal') {
                target.coalStored = (target.coalStored || 0) + 1;
                return true;
            } else if (target.type === 'thermal-generator') {
                if (itemType === 'coal' && target.coalStored < 10) {
                    target.coalStored++;
                    return true;
                } else if (itemType === 'lead' && target.leadStored < 10) {
                    target.leadStored++;
                    return true;
                }
            } else if (target.type === 'graphite-press' && itemType === 'coal') {
                if ((target.coalStored || 0) < 10) { // Allow storing more coal
                    target.coalStored = (target.coalStored || 0) + 1;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                }
            } else if (target.type === 'alloy-factory') {
                // Alloy factory accepts lead and titanium
                if (itemType === 'lead' && (target.leadStored || 0) < 10) {
                    target.leadStored = (target.leadStored || 0) + 1;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                } else if (itemType === 'titanium' && (target.titaniumStored || 0) < 10) {
                    target.titaniumStored = (target.titaniumStored || 0) + 1;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                }
            } else if (target.type === 'miner-constructor') {
                // Miner constructor accepts lead and titanium
                if (itemType === 'lead' && target.leadStored < 100) {
                    target.leadStored++;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                } else if (itemType === 'titanium' && target.titaniumStored < 100) {
                    target.titaniumStored++;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                }
            } else if (target.type === 'conveyor' || target.type === 'alloy-conveyor' || target.type === 'router' || target.type === 'junction') {
                // Don't output to a conveyor that's facing towards us (it wants to output TO us, not receive FROM us)
                if (target.type === 'conveyor' || target.type === 'alloy-conveyor') {
                    const conveyorOutputDir = getDirection(target.rotation);
                    const conveyorOutputX = target.x + conveyorOutputDir.x;
                    const conveyorOutputY = target.y + conveyorOutputDir.y;

                    // Check if the conveyor is outputting towards the source building
                    const bw = building.width || 1;
                    const bh = building.height || 1;
                    const conveyorPointsToSource = conveyorOutputX >= building.x && conveyorOutputX < building.x + bw &&
                                                     conveyorOutputY >= building.y && conveyorOutputY < building.y + bh;
                    if (conveyorPointsToSource) {
                        return false; // Can't output to a conveyor facing us
                    }
                }

                // Items now use world coordinates for smooth movement
                // For 2x2 buildings, use the center of the entire building, not just top-left
                const bw = building.width || 1;
                const bh = building.height || 1;
                const startWorldX = (building.x + bw / 2) * TILE_SIZE;
                const startWorldY = (building.y + bh / 2) * TILE_SIZE;

                // Calculate fromDir based on where the item exits the building
                let fromDir = -1;
                if (outX < building.x) fromDir = 2; // Exiting left, came from right
                else if (outX >= building.x + bw) fromDir = 0; // Exiting right, came from left
                else if (outY < building.y) fromDir = 3; // Exiting up, came from down
                else if (outY >= building.y + bh) fromDir = 1; // Exiting down, came from up

                items.push({
                    type: itemType,
                    worldX: startWorldX,
                    worldY: startWorldY,
                    targetTileX: outX,
                    targetTileY: outY,
                    fromDir: fromDir
                });
                return true;
            } else if ((target.type === 'turret' || target.type === 'scatter') &&
                       BUILDINGS[target.type].ammoType === itemType &&
                       target.ammo < (target.maxAmmo || 20)) {
                // Feed ammo to turret
                target.ammo++;
                spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                return true;
            }
            return false;
        }

        // Smooth item movement speed (pixels per frame)
        const ITEM_SPEED = 1.5;

        // Helper function to handle item reaching a target
        function handleItemTarget(item, target, nextX, nextY, dir, targetWorldX, targetWorldY, toRemove, idx) {
            if (target.type === 'core') {
                resources[item.type] = (resources[item.type] || 0) + 1;
                updateResourceUI();
                spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                toRemove.push(idx);
                return true;
            } else if (target.type === 'generator' && item.type === 'coal') {
                target.coalStored = (target.coalStored || 0) + 1;
                spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                toRemove.push(idx);
                return true;
            } else if (target.type === 'thermal-generator') {
                // Thermal generator accepts coal and lead
                if (item.type === 'coal' && target.coalStored < 10) {
                    target.coalStored = (target.coalStored || 0) + 1;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                } else if (item.type === 'lead' && target.leadStored < 10) {
                    target.leadStored = (target.leadStored || 0) + 1;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                }
            } else if (target.type === 'graphite-press' && item.type === 'coal') {
                if (target.coalStored < 2) {
                    target.coalStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                }
            } else if (target.type === 'alloy-factory') {
                // Alloy factory accepts lead and titanium
                if (item.type === 'lead' && target.leadStored < 10) {
                    target.leadStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                } else if (item.type === 'titanium' && target.titaniumStored < 10) {
                    target.titaniumStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                }
            } else if (target.type === 'miner-constructor') {
                // Miner constructor accepts lead and titanium
                if (item.type === 'lead' && target.leadStored < 100) {
                    target.leadStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                } else if (item.type === 'titanium' && target.titaniumStored < 100) {
                    target.titaniumStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                }
            } else if ((target.type === 'turret' || target.type === 'scatter' || target.type === 'alloy-turret' || target.type === 'stormer') &&
                       BUILDINGS[target.type].ammoType === item.type &&
                       target.ammo < (target.maxAmmo || 20)) {
                // Feed ammo to turret
                target.ammo++;
                spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                toRemove.push(idx);
                return true;
            } else if (target.type === 'conveyor' || target.type === 'alloy-conveyor' || target.type === 'router' || target.type === 'junction') {
                // Check if next tile is blocked
                const occupied = items.some(i => i !== item &&
                    i.targetTileX === nextX && i.targetTileY === nextY &&
                    Math.sqrt((i.worldX - targetWorldX)**2 + (i.worldY - targetWorldY)**2) < TILE_SIZE * 0.6
                );
                if (!occupied) {
                    item.targetTileX = nextX;
                    item.targetTileY = nextY;
                    item.fromDir = (dir + 2) % 4;
                    return true;
                }
            }
            return false;
        }

        function updateItems() {
            const toRemove = [];

            items.forEach((item, idx) => {
                // Calculate target world position (center of target tile)
                const targetWorldX = item.targetTileX * TILE_SIZE + TILE_SIZE / 2;
                const targetWorldY = item.targetTileY * TILE_SIZE + TILE_SIZE / 2;

                // Move towards target
                const dx = targetWorldX - item.worldX;
                const dy = targetWorldY - item.worldY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > ITEM_SPEED) {
                    // Still moving to target
                    item.worldX += (dx / dist) * ITEM_SPEED;
                    item.worldY += (dy / dist) * ITEM_SPEED;
                } else {
                    // Reached target tile center - find next destination
                    item.worldX = targetWorldX;
                    item.worldY = targetWorldY;

                    let building = buildings.find(b => {
                        // Check if target tile is within building bounds
                        const w = b.width || 1;
                        const h = b.height || 1;
                        return item.targetTileX >= b.x && item.targetTileX < b.x + w &&
                               item.targetTileY >= b.y && item.targetTileY < b.y + h;
                    });
                    
                    // Resolve tile reference to master
                    if (building && building.isTileRef) {
                        building = building.master;
                    }
                    
                    if (!building) {
                        toRemove.push(idx);
                        return;
                    }

                    // Determine output directions and find valid targets
                    let moved = false;

                    if (building.type === 'conveyor' || building.type === 'alloy-conveyor') {
                        // Conveyor: single output direction
                        const dir = building.rotation;
                        const d = getDirection(dir);
                        const nextX = item.targetTileX + d.x;
                        const nextY = item.targetTileY + d.y;

                        if (nextX >= 0 && nextX < MAP_WIDTH && nextY >= 0 && nextY < MAP_HEIGHT) {
                            let target = buildings.find(b => {
                                // Check exact tile match
                                if (b.x === nextX && b.y === nextY) return true;
                                // Check 2x2 buildings
                                const w = b.width || 1;
                                const h = b.height || 1;
                                if (w > 1 || h > 1) {
                                    return nextX >= b.x && nextX < b.x + w && nextY >= b.y && nextY < b.y + h;
                                }
                                return false;
                            });

                            // Resolve tile reference to master
                            if (target && target.isTileRef) {
                                target = target.master;
                            }

                            if (target) {
                                moved = handleItemTarget(item, target, nextX, nextY, dir, targetWorldX, targetWorldY, toRemove, idx);
                            }
                        }
                    } else if (building.type === 'router') {
                        // Router: distribute evenly to valid outputs only
                        // Only outputs to: conveyors facing away, cores, and buildings that need this resource
                        let validOutputs = [];

                        for (let dirIdx = 0; dirIdx < 4; dirIdx++) {
                            if (dirIdx === item.fromDir) continue; // Skip input direction

                            const d = getDirection(dirIdx);
                            const nextX = item.targetTileX + d.x;
                            const nextY = item.targetTileY + d.y;

                            if (nextX < 0 || nextX >= MAP_WIDTH || nextY < 0 || nextY >= MAP_HEIGHT) continue;

                            let target = buildings.find(b => {
                                // Check exact tile match
                                if (b.x === nextX && b.y === nextY) return true;
                                // Check 2x2 buildings (core, graphite-press, alloy-factory, thermal-generator, drills)
                                const w = b.width || 1;
                                const h = b.height || 1;
                                if (w > 1 || h > 1) {
                                    return nextX >= b.x && nextX < b.x + w && nextY >= b.y && nextY < b.y + h;
                                }
                                return false;
                            });
                            
                            // Resolve tile reference to master
                            if (target && target.isTileRef) {
                                target = target.master;
                            }

                            if (target) {
                                let isValidTarget = false;
                                
                                // Always output to core
                                if (target.type === 'core') {
                                    isValidTarget = true;
                                }
                                // Output to generator if it needs coal
                                else if (target.type === 'generator' && item.type === 'coal') {
                                    isValidTarget = true;
                                }
                                // Output to thermal generator if it needs coal or lead
                                else if (target.type === 'thermal-generator') {
                                    if ((item.type === 'coal' && target.coalStored < 10) ||
                                        (item.type === 'lead' && target.leadStored < 10)) {
                                        isValidTarget = true;
                                    }
                                }
                                // Output to graphite press if it needs coal
                                else if (target.type === 'graphite-press' && item.type === 'coal' && target.coalStored < 2) {
                                    isValidTarget = true;
                                }
                                // Output to alloy factory if it needs copper or lead
                                else if (target.type === 'alloy-factory') {
                                    if ((item.type === 'lead' && target.leadStored < 10) ||
                                        (item.type === 'titanium' && target.titaniumStored < 10)) {
                                        isValidTarget = true;
                                    }
                                }
                                // Output to miner constructor if it needs lead or titanium
                                else if (target.type === 'miner-constructor') {
                                    if ((item.type === 'lead' && target.leadStored < 100) ||
                                        (item.type === 'titanium' && target.titaniumStored < 100)) {
                                        isValidTarget = true;
                                    }
                                }
                                // Output to turret if it needs ammo
                                else if ((target.type === 'turret' || target.type === 'scatter' || target.type === 'alloy-turret' || target.type === 'stormer') &&
                                         BUILDINGS[target.type].ammoType === item.type &&
                                         target.ammo < (target.maxAmmo || 20)) {
                                    isValidTarget = true;
                                }
                                // Output to conveyor ONLY if it's facing away from the router
                                else if (target.type === 'conveyor' || target.type === 'alloy-conveyor') {
                                    // A conveyor accepts input from behind (opposite of its output direction)
                                    // Router outputs in dirIdx direction, conveyor at (nextX, nextY)
                                    // Check: is the router outputting from the direction that the conveyor accepts input from?
                                    const conveyorOutputDir = target.rotation;
                                    const routerToConveyor = dirIdx; // Direction from router to conveyor
                                    const conveyorToRouter = (routerToConveyor + 2) % 4; // Direction from conveyor back to router

                                    // Conveyor accepts input from behind, which is opposite its output direction
                                    const conveyorInputDir = (conveyorOutputDir + 2) % 4;

                                    // Check if conveyor's input direction matches where the router is
                                    if (conveyorToRouter === conveyorInputDir) {
                                        isValidTarget = true;
                                    }
                                }
                                // Output to other routers and junctions
                                else if (target.type === 'router' || target.type === 'junction') {
                                    isValidTarget = true;
                                }

                                if (isValidTarget) {
                                    // Check if not blocked
                                    const occupied = items.some(i => i !== item &&
                                        i.targetTileX === nextX && i.targetTileY === nextY &&
                                        Math.sqrt((i.worldX - targetWorldX)**2 + (i.worldY - targetWorldY)**2) < TILE_SIZE * 0.6
                                    );
                                    if (!occupied) {
                                        validOutputs.push({ dir: dirIdx, target, nextX, nextY });
                                    }
                                }
                            }
                        }

                        if (validOutputs.length > 0) {
                            // Use random distribution
                            const chosenIdx = Math.floor(Math.random() * validOutputs.length);
                            const chosen = validOutputs[chosenIdx];

                            moved = handleItemTarget(item, chosen.target, chosen.nextX, chosen.nextY, chosen.dir, targetWorldX, targetWorldY, toRemove, idx);
                        }
                    } else if (building.type === 'junction') {
                        // Junction: pass through in same direction
                        const dir = (item.fromDir + 2) % 4;
                        const d = getDirection(dir);
                        const nextX = item.targetTileX + d.x;
                        const nextY = item.targetTileY + d.y;

                        if (nextX >= 0 && nextX < MAP_WIDTH && nextY >= 0 && nextY < MAP_HEIGHT) {
                            let target = buildings.find(b => {
                                // Check exact tile match
                                if (b.x === nextX && b.y === nextY) return true;
                                // Check 2x2 buildings
                                const w = b.width || 1;
                                const h = b.height || 1;
                                if (w > 1 || h > 1) {
                                    return nextX >= b.x && nextX < b.x + w && nextY >= b.y && nextY < b.y + h;
                                }
                                return false;
                            });

                            // Resolve tile reference to master
                            if (target && target.isTileRef) {
                                target = target.master;
                            }

                            if (target) {
                                moved = handleItemTarget(item, target, nextX, nextY, dir, targetWorldX, targetWorldY, toRemove, idx);
                            }
                        }
                    }

                    // If stuck, stay in place (item will wait)
                }
            });

            // Remove consumed items
            for (let i = toRemove.length - 1; i >= 0; i--) {
                items.splice(toRemove[i], 1);
            }
            
            // Hard limit on items for performance - increased to prevent items disappearing
            if (items.length > 1000) {
                items.splice(0, items.length - 1000);
            }
        }

        function repairTick() {
            buildings.forEach(b => {
                if (b.type === 'repair' && b.powered) { // Only repair when powered
                    const range = BUILDINGS.repair.repairRange * TILE_SIZE;
                    const rx = b.x * TILE_SIZE + TILE_SIZE/2;
                    const ry = b.y * TILE_SIZE + TILE_SIZE/2;

                    buildings.forEach(target => {
                        if (target === b || target.type === 'core') return;
                        if (target.health >= target.maxHealth) return;

                        const tx = target.x * TILE_SIZE + TILE_SIZE/2;
                        const ty = target.y * TILE_SIZE + TILE_SIZE/2;
                        const dist = Math.sqrt((tx - rx)**2 + (ty - ry)**2);

                        if (dist <= range) {
                            target.health = Math.min(target.maxHealth, target.health + 2);
                        }
                    });
                }
            });
        }

        function getDirection(rot) {
            const dirs = [{ x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 0, y: -1 }];
            return dirs[rot % 4];
        }

        function updateWaveTimer() {
            if (gameOver) return;
            waveTimer--;
            document.getElementById('next-wave').textContent = waveTimer + 's';
            if (waveTimer <= 0) {
                spawnWave();
            }
        }

        function manualMine() {
            if (player.respawnTimer > 0) {
                miningTarget = null;
                return;
            }

            // Find nearest ore node within range
            const playerTileX = Math.floor(player.x / TILE_SIZE);
            const playerTileY = Math.floor(player.y / TILE_SIZE);
            const mineRange = 3; // Can mine ore within 3 tiles

            let nearestOre = null;
            let nearestDist = Infinity;

            for (let dy = -mineRange; dy <= mineRange; dy++) {
                for (let dx = -mineRange; dx <= mineRange; dx++) {
                    const checkX = playerTileX + dx;
                    const checkY = playerTileY + dy;

                    if (checkX >= 0 && checkX < MAP_WIDTH && checkY >= 0 && checkY < MAP_HEIGHT) {
                        const ore = oreMap[checkY][checkX];

                        // Can only manually mine copper and lead
                        if (ore === 'copper' || ore === 'lead') {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestOre = {
                                    x: checkX * TILE_SIZE + TILE_SIZE / 2,
                                    y: checkY * TILE_SIZE + TILE_SIZE / 2,
                                    type: ore
                                };
                            }
                        }
                    }
                }
            }

            if (nearestOre) {
                miningTarget = nearestOre;
                resources[nearestOre.type] = (resources[nearestOre.type] || 0) + 1; // Mine 1 ore per 200ms
                updateResourceUI();
                spawnParticles(nearestOre.x, nearestOre.y, getOreColor(nearestOre.type), 3);
            } else {
                miningTarget = null;
            }
        }

        function startWaveEarly() {
            if (waveTimer > 5) {
                resources.copper += Math.floor(waveTimer / 2);
                updateResourceUI();
                spawnWave();
            }
        }

        function spawnWave() {
            wave++;
            document.getElementById('wave-num').textContent = wave;
            waveTimer = 120; // 2 minutes between waves

            // Start with 1 enemy, add 1 per wave (much slower progression)
            const baseCount = wave;

            for (let i = 0; i < baseCount; i++) {
                // Spawn from designated spawn point
                const spawnX = spawnPoint.x * TILE_SIZE + (Math.random() - 0.5) * TILE_SIZE * 4;
                const spawnY = spawnPoint.y * TILE_SIZE + (Math.random() - 0.5) * TILE_SIZE * 4;

                let enemyType = 'basic';
                const roll = Math.random();
                if (wave >= 3 && roll < 0.2) enemyType = 'fast';
                if (wave >= 5 && roll < 0.15) enemyType = 'shooter';
                if (wave >= 7 && roll < 0.12) enemyType = 'sniper';
                if (wave >= 9 && roll < 0.1) enemyType = 'artillery';
                if (wave >= 9 && roll < 0.15) enemyType = 'tank';
                if (wave >= 11 && roll < 0.08) enemyType = 'swarm';
                if (wave >= 15 && roll < 0.05) enemyType = 'boss';

                const stats = {
                    basic: { health: 40 + wave * 5, speed: 0.9, size: 12, color: 0xff5555, damage: 2, canShoot: true, range: 5, fireCooldown: 500, bulletSpeed: 8, useLaser: false },
                    fast: { health: 20 + wave * 3, speed: 1.8, size: 10, color: 0xffaa00, damage: 30, canShoot: false, isKamikaze: true, explosionRange: 1.5, useLaser: false },
                    shooter: { health: 30 + wave * 4, speed: 0.7, size: 11, color: 0xff8844, damage: 3, canShoot: true, range: 6, fireCooldown: 500, bulletSpeed: 9, useLaser: false },
                    sniper: { health: 25 + wave * 3, speed: 0.5, size: 10, color: 0x8844ff, damage: 4, canShoot: true, range: 10, fireCooldown: 1500, bulletSpeed: 12, useLaser: true, laserColor: 0x8844ff },
                    artillery: { health: 60 + wave * 6, speed: 0.3, size: 16, color: 0x448844, damage: 5, canShoot: true, range: 12, fireCooldown: 500, bulletSpeed: 7, splash: true, useLaser: false },
                    tank: { health: 100 + wave * 12, speed: 0.35, size: 18, color: 0x884444, damage: 4, canShoot: true, range: 6, fireCooldown: 1000, bulletSpeed: 9, useLaser: true, laserColor: 0xff4444 },
                    swarm: { health: 15 + wave * 2, speed: 2.2, size: 8, color: 0xff88ff, damage: 20, canShoot: false, isKamikaze: true, explosionRange: 1, useLaser: false },
                    boss: { health: 300 + wave * 25, speed: 0.25, size: 26, color: 0xff0000, damage: 6, canShoot: true, range: 9, fireCooldown: 800, bulletSpeed: 10, useLaser: true, laserColor: 0xff0000 }
                }[enemyType];

                enemies.push({
                    x: spawnX,
                    y: spawnY,
                    ...stats,
                    maxHealth: stats.health,
                    type: enemyType,
                    delay: i * 300,
                    fireCooldownMax: stats.fireCooldown || 0,
                    lastFire: 0,
                    bulletSpeed: stats.bulletSpeed || 4,
                    splash: stats.splash || false,
                    useLaser: stats.useLaser || false,
                    laserColor: stats.laserColor || 0xff0000,
                    targetBuilding: null,
                    laserActive: false, // Track if laser is currently firing
                    laserTarget: null // Store laser target position
                });
            }
        }

        function updateResourceUI() {
            document.getElementById('copper-count').textContent = resources.copper || 0;
            document.getElementById('lead-count').textContent = resources.lead || 0;
            document.getElementById('coal-count').textContent = resources.coal || 0;
            document.getElementById('titanium-count').textContent = resources.titanium || 0;
            document.getElementById('graphite-count').textContent = resources.graphite || 0;
            document.getElementById('alloy-count').textContent = resources.alloy || 0;
            document.getElementById('sand-count').textContent = resources.sand || 0;
            renderBuildingGrid();
        }

        function updatePlayerHealthUI() {
            const pct = Math.max(0, (player.health / player.maxHealth) * 100);
            document.getElementById('player-health-fill').style.width = pct + '%';
            if (player.respawnTimer > 0) {
                document.getElementById('player-health-text').textContent = 'Respawn: ' + Math.ceil(player.respawnTimer / 1000) + 's';
            } else {
                document.getElementById('player-health-text').textContent = 'Ship: ' + Math.ceil(pct) + '%';
            }
        }

        function respawnPlayer() {
            player.deaths++;
            player.respawnTimer = 3000; // 3 second respawn
            player.health = 0;

            // Big explosion effect
            spawnParticles(player.x, player.y, 0xff4400, 20);
            spawnParticles(player.x, player.y, 0xffff00, 15);
            spawnParticles(player.x, player.y, 0xff0000, 10);

            updatePlayerHealthUI();
        }

        function completeRespawn() {
            // Respawn at core
            const core = buildings.find(b => b.type === 'core');
            if (core) {
                player.x = (core.x + 1) * TILE_SIZE;
                player.y = (core.y + 1) * TILE_SIZE;
            }

            player.health = player.maxHealth;
            player.respawnTimer = 0;
            player.invulnerable = 2000; // 2 seconds of invulnerability

            // Respawn particles
            spawnParticles(player.x, player.y, 0x44ff44, 15);
            spawnParticles(player.x, player.y, 0xffffff, 10);

            updatePlayerHealthUI();
        }

        function spawnParticles(x, y, color, count) {
            // Reduce particle count for performance (max 5 per spawn)
            count = Math.min(count, 5);
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 30,
                    color: color,
                    size: 2 + Math.random() * 2
                });
            }
        }

        function update(time, delta) {
            // Cache timestamp for performance
            const now = Date.now();
            
            if (gameOver) {
                graphics.clear();
                graphics.fillStyle(0xff0000, 0.5);
                graphics.fillRect(0, 0, window.innerWidth, window.innerHeight);
                return;
            }

            // Handle respawn timer
            if (player.respawnTimer > 0) {
                player.respawnTimer -= delta;
                if (player.respawnTimer <= 0) {
                    completeRespawn();
                }
                updatePlayerHealthUI();
            }

            // Handle invulnerability timer
            if (player.invulnerable > 0) {
                player.invulnerable -= delta;
            }

            // Handle mining cooldown and auto-mine when in mining mode
            if (miningCooldown > 0) {
                miningCooldown -= delta;
            }
            if (miningMode && miningCooldown <= 0 && player.respawnTimer <= 0) {
                manualMine();
                miningCooldown = 200; // Mine every 200ms (faster)
            }

            // Player movement (only if alive)
            if (player.respawnTimer <= 0) {
                let moveX = 0;
                let moveY = 0;

                if (keys.W.isDown) moveY -= player.speed;
                if (keys.S.isDown) moveY += player.speed;
                if (keys.A.isDown) moveX -= player.speed;
                if (keys.D.isDown) moveX += player.speed;

                // Update position
                player.x += moveX;
                player.y += moveY;

                // Update angle based on movement direction
                if (moveX !== 0 || moveY !== 0) {
                    player.angle = Math.atan2(moveY, moveX);
                }

                // Clamp player to map bounds
                player.x = Math.max(TILE_SIZE, Math.min(MAP_WIDTH * TILE_SIZE - TILE_SIZE, player.x));
                player.y = Math.max(TILE_SIZE, Math.min(MAP_HEIGHT * TILE_SIZE - TILE_SIZE, player.y));
            }

            // Camera follows player
            camera.x = player.x - window.innerWidth / 2;
            camera.y = player.y - window.innerHeight / 2;

            // Clamp camera
            camera.x = Math.max(0, Math.min(MAP_WIDTH * TILE_SIZE - window.innerWidth, camera.x));
            camera.y = Math.max(0, Math.min(MAP_HEIGHT * TILE_SIZE - window.innerHeight, camera.y));

            graphics.clear();

            // Calculate visible tile range
            const startTileX = Math.max(0, Math.floor(camera.x / TILE_SIZE) - 1);
            const startTileY = Math.max(0, Math.floor(camera.y / TILE_SIZE) - 1);
            const endTileX = Math.min(MAP_WIDTH, Math.ceil((camera.x + window.innerWidth) / TILE_SIZE) + 1);
            const endTileY = Math.min(MAP_HEIGHT, Math.ceil((camera.y + window.innerHeight) / TILE_SIZE) + 1);

            // Draw terrain
            for (let y = startTileY; y < endTileY; y++) {
                for (let x = startTileX; x < endTileX; x++) {
                    const screenX = x * TILE_SIZE - camera.x;
                    const screenY = y * TILE_SIZE - camera.y;

                    const terrain = terrainMap[y][x];
                    let color;
                    switch (terrain) {
                        case TERRAIN.GRASS:
                            color = ((x + y) % 2 === 0) ? 0x2d4a2d : 0x264026;
                            break;
                        case TERRAIN.SAND:
                            color = ((x + y) % 2 === 0) ? 0x8b7355 : 0x7a6548;
                            break;
                        case TERRAIN.WATER:
                            color = ((x + y) % 2 === 0) ? 0x2255aa : 0x1a4488;
                            break;
                        case TERRAIN.STONE:
                            color = ((x + y) % 2 === 0) ? 0x555566 : 0x4a4a5a;
                            break;
                        case TERRAIN.DARK_STONE:
                            color = ((x + y) % 2 === 0) ? 0x3a3a4a : 0x33333f;
                            break;
                    }

                    graphics.fillStyle(color);
                    graphics.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw ore deposits (optimized)
            for (let y = startTileY; y < endTileY; y++) {
                for (let x = startTileX; x < endTileX; x++) {
                    if (oreMap[y][x]) {
                        const screenX = x * TILE_SIZE - camera.x;
                        const screenY = y * TILE_SIZE - camera.y;
                        const ore = oreMap[y][x];
                        const color = getOreColor(ore);
                        
                        // Base ore patch
                        graphics.fillStyle(color, 0.4);
                        graphics.fillRoundedRect(screenX + 4, screenY + 4, TILE_SIZE - 8, TILE_SIZE - 8, 3);
                        
                        // Simplified crystal texture (reduced from 3-5 to 2-3 crystals)
                        const seed = x * 13 + y * 17;
                        const numCrystals = ore === 'titanium' ? 3 : 2;
                        
                        for (let i = 0; i < numCrystals; i++) {
                            const cx = screenX + 8 + ((seed * (i + 1) * 7) % (TILE_SIZE - 16));
                            const cy = screenY + 8 + ((seed * (i + 1) * 11) % (TILE_SIZE - 16));
                            const size = 3 + ((seed * i) % 3);
                            
                            graphics.fillStyle(color, 0.9);
                            graphics.fillCircle(cx, cy, size);
                        }
                        
                        // Simplified ore-specific details
                        if (ore === 'copper') {
                            graphics.fillStyle(0xffaa66, 0.2);
                            graphics.fillRect(screenX + 6, screenY + 6, TILE_SIZE - 12, TILE_SIZE - 12);
                        } else if (ore === 'lead') {
                            graphics.fillStyle(0xaaaaaa, 0.25);
                            graphics.fillRect(screenX + 7, screenY + 7, TILE_SIZE - 14, 2);
                        } else if (ore === 'titanium') {
                            graphics.fillStyle(0x66aaff, 0.25);
                            graphics.fillCircle(screenX + TILE_SIZE/2, screenY + TILE_SIZE/2, 5);
                        }
                    }
                }
            }

            // Draw spawn point indicator
            const spawnScreenX = spawnPoint.x * TILE_SIZE - camera.x;
            const spawnScreenY = spawnPoint.y * TILE_SIZE - camera.y;
            const pulse = Math.sin(time / 300) * 0.3 + 0.5;
            graphics.fillStyle(0xff0000, pulse * 0.3);
            graphics.fillCircle(spawnScreenX + TILE_SIZE/2, spawnScreenY + TILE_SIZE/2, TILE_SIZE * 2);
            graphics.lineStyle(2, 0xff0000, pulse);
            graphics.strokeCircle(spawnScreenX + TILE_SIZE/2, spawnScreenY + TILE_SIZE/2, TILE_SIZE * 1.5);

            // Draw construction queue (semi-transparent ghosts)
            constructionQueue.forEach(b => {
                const screenX = b.x * TILE_SIZE - camera.x;
                const screenY = b.y * TILE_SIZE - camera.y;
                const width = (b.width || 1) * TILE_SIZE;
                const height = (b.height || 1) * TILE_SIZE;

                // Only draw if on screen
                if (screenX > -TILE_SIZE * 2 && screenX < window.innerWidth + TILE_SIZE &&
                    screenY > -TILE_SIZE * 2 && screenY < window.innerHeight + TILE_SIZE) {

                    const buildTime = BUILDINGS[b.type].buildTime || 1;
                    const progress = Math.min(1, b.buildProgress / buildTime);

                    // Semi-transparent white/blue tint for ghost
                    graphics.fillStyle(0x88ccff, 0.3);
                    graphics.fillRect(screenX, screenY, width, height);

                    // Border
                    graphics.lineStyle(2, 0x88ccff, 0.6);
                    graphics.strokeRect(screenX, screenY, width, height);

                    // Progress bar
                    const barHeight = 4;
                    const barY = screenY + height + 4;
                    graphics.fillStyle(0x333333, 0.8);
                    graphics.fillRect(screenX, barY, width, barHeight);
                    graphics.fillStyle(0x44ff44, 0.9);
                    graphics.fillRect(screenX, barY, width * progress, barHeight);
                }
            });

            // Draw buildings
            buildings.forEach(b => {
                // Skip tile references - only draw master buildings
                if (b.isTileRef) return;

                const screenX = b.x * TILE_SIZE - camera.x;
                const screenY = b.y * TILE_SIZE - camera.y;

                // Only draw if on screen
                if (screenX > -TILE_SIZE * 2 && screenX < window.innerWidth + TILE_SIZE &&
                    screenY > -TILE_SIZE * 2 && screenY < window.innerHeight + TILE_SIZE) {
                    drawBuilding(b, screenX, screenY);
                }
            });

            // Update items smoothly every frame
            updateItems();

            // Update miners
            for (let i = miners.length - 1; i >= 0; i--) {
                const miner = miners[i];
                const targetWorldX = miner.targetX * TILE_SIZE + TILE_SIZE / 2;
                const targetWorldY = miner.targetY * TILE_SIZE + TILE_SIZE / 2;
                
                // Move towards target but stop at a distance to show laser better
                const dx = targetWorldX - miner.x;
                const dy = targetWorldY - miner.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const miningDistance = TILE_SIZE * 1.5; // Stop 1.5 tiles away

                if (dist > miningDistance) {
                    // Move towards ore
                    const speed = 2;
                    let newX = miner.x + (dx / dist) * speed;
                    let newY = miner.y + (dy / dist) * speed;

                    // Check collision with other miners
                    const minerRadius = 12; // Collision radius for miners
                    let collided = false;
                    for (let j = 0; j < miners.length; j++) {
                        if (i === j) continue;
                        const other = miners[j];
                        const odx = newX - other.x;
                        const ody = newY - other.y;
                        const oDist = Math.sqrt(odx * odx + ody * ody);

                        if (oDist < minerRadius * 2) {
                            // Collision detected - push away slightly
                            collided = true;
                            const pushDist = (minerRadius * 2 - oDist) / 2;
                            if (oDist > 0) {
                                newX += (odx / oDist) * pushDist;
                                newY += (ody / oDist) * pushDist;
                            }
                        }
                    }

                    miner.x = newX;
                    miner.y = newY;
                } else {
                    // At mining distance - mine it
                    miner.miningCooldown -= delta;
                    if (miner.miningCooldown <= 0) {
                        miner.miningCooldown = 1000; // Mine every 1 second
                        resources[miner.oreType] = (resources[miner.oreType] || 0) + 1;
                        updateResourceUI();
                        spawnParticles(targetWorldX, targetWorldY, getOreColor(miner.oreType), 2);
                    }
                }
                
                // Check if miner is damaged by enemies
                enemies.forEach(e => {
                    const dx = e.x - miner.x;
                    const dy = e.y - miner.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < TILE_SIZE) {
                        miner.health -= 0.1; // Damage over time
                    }
                });
                
                // Remove dead miners
                if (miner.health <= 0) {
                    spawnParticles(miner.x, miner.y, 0xff4444, 10);
                    miners.splice(i, 1);
                }
            }

            // Draw items using world coordinates
            items.forEach(item => {
                const screenX = item.worldX - camera.x;
                const screenY = item.worldY - camera.y;

                // Only draw if on screen
                if (screenX > -10 && screenX < window.innerWidth + 10 &&
                    screenY > -10 && screenY < window.innerHeight + 10) {
                    graphics.fillStyle(getOreColor(item.type));
                    graphics.fillCircle(screenX, screenY, 5);
                    // Add a small highlight for 3D effect
                    graphics.fillStyle(0xffffff, 0.3);
                    graphics.fillCircle(screenX - 1, screenY - 1, 2);
                }
            });

            // Draw miners
            miners.forEach(miner => {
                const screenX = miner.x - camera.x;
                const screenY = miner.y - camera.y;

                if (screenX > -20 && screenX < window.innerWidth + 20 &&
                    screenY > -20 && screenY < window.innerHeight + 20) {

                    // Draw green mining laser if miner is at mining distance
                    const targetWorldX = miner.targetX * TILE_SIZE + TILE_SIZE / 2;
                    const targetWorldY = miner.targetY * TILE_SIZE + TILE_SIZE / 2;
                    const distToTarget = Math.sqrt((miner.x - targetWorldX)**2 + (miner.y - targetWorldY)**2);
                    const miningDistance = TILE_SIZE * 1.5;

                    if (distToTarget <= miningDistance) {
                        // Miner is at target, draw green laser (wider and brighter)
                        const targetScreenX = targetWorldX - camera.x;
                        const targetScreenY = targetWorldY - camera.y;
                        const laserPulse = Math.sin(Date.now() / 80) * 0.3 + 0.7;

                        // Outer glow (green) - wider
                        graphics.lineStyle(12, 0x00ff00, laserPulse * 0.3);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Middle glow - brighter
                        graphics.lineStyle(6, 0x44ff44, laserPulse * 0.7);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Core beam - very bright
                        graphics.lineStyle(3, 0xccffcc, laserPulse * 0.95);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Impact effect at target - larger and brighter
                        graphics.fillStyle(0x00ff00, laserPulse * 0.7);
                        graphics.fillCircle(targetScreenX, targetScreenY, 10);
                        graphics.fillStyle(0xffffff, laserPulse * 0.6);
                        graphics.fillCircle(targetScreenX, targetScreenY, 5);
                    }

                    // Miner body (small drone)
                    graphics.fillStyle(0x4CAF50);
                    graphics.fillCircle(screenX, screenY, 8);

                    // Propellers
                    const propAngle = (Date.now() / 50) % (Math.PI * 2);
                    graphics.lineStyle(2, 0x888888);
                    graphics.strokeCircle(screenX - 6, screenY - 6, 3);
                    graphics.strokeCircle(screenX + 6, screenY - 6, 3);

                    // Health bar
                    const healthPct = miner.health / miner.maxHealth;
                    graphics.fillStyle(0x333333);
                    graphics.fillRect(screenX - 10, screenY + 12, 20, 3);
                    graphics.fillStyle(healthPct > 0.5 ? 0x4CAF50 : 0xff4444);
                    graphics.fillRect(screenX - 10, screenY + 12, 20 * healthPct, 3);
                }
            });

            // Update and draw enemies
            const core = buildings.find(b => b.type === 'core');
            enemies.forEach((enemy, idx) => {
                if (enemy.delay > 0) {
                    enemy.delay -= delta;
                    return;
                }

                // Find target - priority system: transport < defense < power < production < core
                // Also attack anything in the way
                let targetX, targetY;
                let targetBuilding = null;
                let minDist = Infinity;
                let highestPriority = -1;
                
                const getPriority = (building) => {
                    if (building.isTileRef) building = building.master;
                    if (!building) return -1;
                    const category = BUILDINGS[building.type]?.category;
                    if (building.type === 'core') return 5; // Highest priority
                    if (category === 'production') return 4;
                    if (category === 'power') return 3;
                    if (category === 'defense') return 2;
                    if (category === 'transport') return 1;
                    return 0;
                };

                // Find highest priority target within 5 tile radius
                const SEARCH_RADIUS = TILE_SIZE * 5;
                
                buildings.forEach(b => {
                    if (b.isTileRef) return; // Skip tile refs, we'll handle via master
                    
                    const bx = b.x * TILE_SIZE + TILE_SIZE/2;
                    const by = b.y * TILE_SIZE + TILE_SIZE/2;
                    const dist = Math.sqrt((enemy.x - bx)**2 + (enemy.y - by)**2);
                    
                    // Only consider buildings within 5 tile radius
                    if (dist > SEARCH_RADIUS) return;
                    
                    const priority = getPriority(b);
                    
                    // Prioritize by: 1) Priority level, 2) Distance for same priority
                    if (priority > highestPriority || (priority === highestPriority && dist < minDist)) {
                        highestPriority = priority;
                        minDist = dist;
                        targetBuilding = b;
                        targetX = bx;
                        targetY = by;
                    }
                });

                // If no target found in radius, default to core
                if (!targetBuilding && core) {
                    targetX = (core.x + 1) * TILE_SIZE;
                    targetY = (core.y + 1) * TILE_SIZE;
                    targetBuilding = core;
                }

                enemy.targetBuilding = targetBuilding;

                // Move towards target
                const dx = targetX - enemy.x;
                const dy = targetY - enemy.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Attack anything in the way (within 1 tile) - or explode if kamikaze
                buildings.forEach(b => {
                    if (b.isTileRef) return;
                    const bx = b.x * TILE_SIZE + TILE_SIZE/2;
                    const by = b.y * TILE_SIZE + TILE_SIZE/2;
                    const distToBuilding = Math.sqrt((enemy.x - bx)**2 + (enemy.y - by)**2);

                    // Kamikaze enemies explode on contact with buildings
                    if (enemy.isKamikaze && distToBuilding < TILE_SIZE * 0.8) {
                        // Deal damage to building
                        b.health -= enemy.damage;

                        // Damage nearby buildings in explosion range
                        const expRange = (enemy.explosionRange || 1) * TILE_SIZE;
                        buildings.forEach(nearbyB => {
                            if (nearbyB.isTileRef) return;
                            const nbx = nearbyB.x * TILE_SIZE + TILE_SIZE/2;
                            const nby = nearbyB.y * TILE_SIZE + TILE_SIZE/2;
                            const distToNearby = Math.sqrt((enemy.x - nbx)**2 + (enemy.y - nby)**2);
                            if (distToNearby < expRange && nearbyB !== b) {
                                const falloff = 1 - (distToNearby / expRange);
                                nearbyB.health -= enemy.damage * falloff * 0.5;
                            }
                        });

                        // Explosion particles
                        for (let i = 0; i < 10; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 4 + 2;
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                color: 0xff6600,
                                life: Math.random() * 20 + 10
                            });
                        }

                        // Kill the kamikaze enemy
                        enemy.health = 0;
                        return;
                    }

                    // Regular enemies - if building is in the way (within 1.5 tiles) and between enemy and target
                    if (!enemy.isKamikaze && distToBuilding < TILE_SIZE * 1.5) {
                        const angleToTarget = Math.atan2(dy, dx);
                        const angleToBuilding = Math.atan2(by - enemy.y, bx - enemy.x);
                        const angleDiff = Math.abs(angleToTarget - angleToBuilding);

                        if (angleDiff < Math.PI / 4 || angleDiff > 7 * Math.PI / 4) {
                            // Building is roughly in direction of target - attack it
                            b.health -= 0.5; // Damage buildings in the way
                        }
                    }
                });

                // Shooting enemies stop at range and shoot instead of ramming
                const shootingRange = enemy.canShoot ? enemy.range * TILE_SIZE * 0.9 : TILE_SIZE;
                const shouldMove = !enemy.canShoot || dist > shootingRange;

                if (shouldMove && dist > TILE_SIZE) {
                    // Apply slow effect if active
                    let speedMultiplier = 1.0;
                    if (enemy.slowedUntil && Date.now() < enemy.slowedUntil) {
                        speedMultiplier = enemy.slowFactor || 0.5;
                    } else {
                        enemy.slowedUntil = null;
                        enemy.slowFactor = null;
                    }
                    
                    enemy.x += (dx / dist) * enemy.speed * speedMultiplier;
                    enemy.y += (dy / dist) * enemy.speed * speedMultiplier;
                }

                // Enemy shooting
                if (enemy.canShoot && enemy.fireCooldownMax) {
                    enemy.lastFire = (enemy.lastFire || 0) + delta;

                    if (enemy.useLaser) {
                        // Laser enemies fire with cooldown
                        const playerDist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);

                        if (player.respawnTimer <= 0 && playerDist < enemy.range * TILE_SIZE) {
                            // Only activate laser when cooldown is ready
                            if (enemy.lastFire >= enemy.fireCooldownMax) {
                                enemy.laserActive = true;
                                enemy.laserTarget = { x: player.x, y: player.y, isPlayer: true };
                                enemy.laserStartTime = Date.now();
                                enemy.lastFire = 0;
                            }

                            // Laser stays active for 300ms then turns off
                            if (enemy.laserActive && enemy.laserStartTime && Date.now() - enemy.laserStartTime > 300) {
                                enemy.laserActive = false;
                                enemy.laserTarget = null;
                            }

                            // Deal damage when laser is active
                            if (enemy.laserActive) {
                                player.health -= enemy.damage * 0.1; // Per frame damage while active
                                if (player.health <= 0 && player.respawnTimer <= 0) {
                                    respawnPlayer();
                                }
                            }
                        } else if (targetBuilding && dist < enemy.range * TILE_SIZE) {
                            // Only activate laser when cooldown is ready
                            if (enemy.lastFire >= enemy.fireCooldownMax) {
                                enemy.laserActive = true;
                                enemy.laserTarget = { x: targetX, y: targetY, building: targetBuilding };
                                enemy.laserStartTime = Date.now();
                                enemy.lastFire = 0;
                            }

                            // Laser stays active for 300ms then turns off
                            if (enemy.laserActive && enemy.laserStartTime && Date.now() - enemy.laserStartTime > 300) {
                                enemy.laserActive = false;
                                enemy.laserTarget = null;
                            }

                            // Deal damage to building when laser is active
                            if (enemy.laserActive && targetBuilding) {
                                targetBuilding.health -= enemy.damage * 0.05;
                            }
                        } else {
                            enemy.laserActive = false;
                            enemy.laserTarget = null;
                        }
                    } else {
                        // Regular bullet enemies
                        if (enemy.lastFire >= enemy.fireCooldownMax) {
                            // Shoot at player if in range (only if player is alive)
                            const playerDist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);

                            if (player.respawnTimer <= 0 && playerDist < enemy.range * TILE_SIZE) {
                                enemyBullets.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    startX: enemy.x,
                                    startY: enemy.y,
                                    targetX: player.x,
                                    targetY: player.y,
                                    speed: enemy.bulletSpeed || 4,
                                    damage: enemy.damage * 5,
                                    splash: enemy.splash,
                                    enemyType: enemy.type
                                });
                                enemy.lastFire = 0;
                            } else if (targetBuilding && dist < enemy.range * TILE_SIZE) {
                                // Shoot at building from range
                                enemyBullets.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    startX: enemy.x,
                                    startY: enemy.y,
                                    targetX: targetX,
                                    targetY: targetY,
                                    speed: enemy.bulletSpeed || 4,
                                    damage: enemy.damage * 3,
                                    targetBuilding: targetBuilding,
                                    splash: enemy.splash,
                                    enemyType: enemy.type
                                });
                                enemy.lastFire = 0;
                            }
                        }
                    }
                }

                // Only non-shooting enemies do melee damage
                if (!enemy.canShoot && dist < TILE_SIZE && targetBuilding) {
                    targetBuilding.health -= enemy.damage * 0.1;

                    if (targetBuilding.type === 'core') {
                        coreHealth = targetBuilding.health;
                        if (coreHealth <= 0) {
                            gameOver = true;
                            alert('Game Over! Wave ' + wave);
                        }
                    } else if (targetBuilding.health <= 0) {
                        destroyBuilding(targetBuilding);
                    }
                }

                // Fast enemies are kamikaze - explode on contact
                if (enemy.type === 'fast' && dist < TILE_SIZE * 1.5) {
                    const explosionRange = TILE_SIZE * 2.5;
                    const explosionDamage = 40 + wave * 8;

                    // Damage all buildings in range
                    const damagedBuildings = [];
                    buildings.forEach(b => {
                        const bx = b.x * TILE_SIZE + TILE_SIZE / 2;
                        const by = b.y * TILE_SIZE + TILE_SIZE / 2;
                        const bDist = Math.sqrt((bx - enemy.x)**2 + (by - enemy.y)**2);
                        if (bDist < explosionRange) {
                            const falloff = 1 - (bDist / explosionRange);
                            b.health -= explosionDamage * falloff;
                            if (b.type === 'core') {
                                coreHealth = b.health;
                                if (coreHealth <= 0) {
                                    gameOver = true;
                                    alert('Game Over! Wave ' + wave);
                                }
                            } else if (b.health <= 0) {
                                damagedBuildings.push(b);
                            }
                        }
                    });
                    damagedBuildings.forEach(b => destroyBuilding(b));

                    // Damage player if nearby
                    const playerDist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);
                    if (playerDist < explosionRange && player.respawnTimer <= 0 && player.invulnerable <= 0) {
                        const falloff = 1 - (playerDist / explosionRange);
                        player.health -= explosionDamage * falloff;
                        if (player.health <= 0) {
                            respawnPlayer();
                        }
                    }

                    // Explosion effect (reduced particles for performance)
                    for (let i = 0; i < 20; i++) {
                        const particleAngle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 6 + 3;
                        particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(particleAngle) * speed,
                            vy: Math.sin(particleAngle) * speed,
                            color: Math.random() > 0.5 ? 0xff6600 : 0xffaa00,
                            life: Math.random() * 40 + 30
                        });
                    }

                    // Kill the kamikaze enemy
                    enemy.health = 0;
                }

                // Draw enemy
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;

                if (screenX > -50 && screenX < window.innerWidth + 50 &&
                    screenY > -50 && screenY < window.innerHeight + 50) {

                    // Shadow
                    graphics.fillStyle(0x000000, 0.3);
                    graphics.fillEllipse(screenX, screenY + enemy.size * 0.8, enemy.size, enemy.size * 0.4);

                    // Body with type-specific designs
                    graphics.fillStyle(enemy.color);
                    
                    if (enemy.type === 'basic') {
                        // Basic enemy - hexagonal assault drone
                        graphics.fillCircle(screenX, screenY, enemy.size);
                        graphics.fillStyle(enemy.color * 0.7);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.6);
                        // Directional indicator
                        graphics.fillStyle(0xff8888);
                        const angle = Math.atan2(dy, dx);
                        graphics.fillCircle(screenX + Math.cos(angle) * 5, screenY + Math.sin(angle) * 5, 3);
                        // Side panels
                        graphics.fillStyle(0xaa3333);
                        graphics.fillRect(screenX - enemy.size, screenY - 2, enemy.size * 0.6, 4);
                        graphics.fillRect(screenX + enemy.size * 0.4, screenY - 2, enemy.size * 0.6, 4);
                    } else if (enemy.type === 'fast') {
                        // Fast enemy - sleek rocket with thrusters
                        const angle = Math.atan2(dy, dx);
                        graphics.fillCircle(screenX, screenY, enemy.size);
                        // Rocket body
                        graphics.fillStyle(0xff8800);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.7);
                        // Nose cone
                        graphics.fillStyle(0xffaa00);
                        graphics.fillCircle(screenX + Math.cos(angle) * 4, screenY + Math.sin(angle) * 4, enemy.size * 0.5);
                        // Thruster flames
                        const thrustX = screenX - Math.cos(angle) * enemy.size;
                        const thrustY = screenY - Math.sin(angle) * enemy.size;
                        graphics.fillStyle(0xff6600, 0.8);
                        graphics.fillCircle(thrustX, thrustY, 4);
                        graphics.fillStyle(0xffff00, 0.6);
                        graphics.fillCircle(thrustX, thrustY, 2);
                        // Warning stripes (kamikaze indicator)
                        graphics.fillStyle(0xffff00);
                        graphics.fillRect(screenX - 4, screenY - 1, 3, 2);
                        graphics.fillRect(screenX + 1, screenY - 1, 3, 2);
                    } else {
                        // Default circular body for other types
                        graphics.fillCircle(screenX, screenY, enemy.size);
                    }

                    // Details based on type
                    const angle = Math.atan2(dy, dx);

                    if (enemy.type === 'shooter') {
                        // Gun barrel
                        graphics.fillStyle(0x333333);
                        graphics.fillRect(
                            screenX + Math.cos(angle) * enemy.size * 0.5 - 2,
                            screenY + Math.sin(angle) * enemy.size * 0.5 - 2,
                            enemy.size * 0.7, 4
                        );
                    }

                    if (enemy.type === 'sniper') {
                        // Long sniper barrel
                        graphics.fillStyle(0x222244);
                        graphics.fillRect(
                            screenX + Math.cos(angle) * enemy.size * 0.3 - 1,
                            screenY + Math.sin(angle) * enemy.size * 0.3 - 1,
                            enemy.size * 1.2, 3
                        );
                        // Scope
                        graphics.fillStyle(0x6666ff);
                        graphics.fillCircle(screenX, screenY - 3, 3);
                    }

                    if (enemy.type === 'artillery') {
                        // Mortar tube
                        graphics.fillStyle(0x224422);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.5);
                        graphics.fillStyle(0x335533);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.35);
                        // Barrel pointing up
                        graphics.fillStyle(0x113311);
                        graphics.fillRect(screenX - 3, screenY - enemy.size * 0.7, 6, enemy.size * 0.5);
                    }

                    if (enemy.type === 'tank') {
                        // Tank treads
                        graphics.fillStyle(0x443333);
                        graphics.fillRect(screenX - enemy.size, screenY - enemy.size * 0.4, enemy.size * 2, enemy.size * 0.8);
                        // Tank body
                        graphics.fillStyle(0x664444);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.6);
                        // Turret
                        graphics.fillStyle(0x553333);
                        graphics.fillRect(
                            screenX + Math.cos(angle) * 2 - 2,
                            screenY + Math.sin(angle) * 2 - 2,
                            enemy.size * 0.8, 4
                        );
                    }

                    if (enemy.type === 'swarm') {
                        // Small fast wings
                        const wingFlap = Math.sin(time / 30) * 3;
                        graphics.fillStyle(0xcc66cc);
                        graphics.fillEllipse(screenX - 4, screenY + wingFlap, 3, 5);
                        graphics.fillEllipse(screenX + 4, screenY - wingFlap, 3, 5);
                    }

                    if (enemy.type === 'boss') {
                        // Boss armor
                        graphics.fillStyle(0x880000);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.7);
                        // Crown/horns
                        graphics.fillStyle(0xffcc00);
                        graphics.beginPath();
                        graphics.moveTo(screenX - 8, screenY - enemy.size);
                        graphics.lineTo(screenX - 4, screenY - enemy.size - 8);
                        graphics.lineTo(screenX, screenY - enemy.size);
                        graphics.lineTo(screenX + 4, screenY - enemy.size - 8);
                        graphics.lineTo(screenX + 8, screenY - enemy.size);
                        graphics.closePath();
                        graphics.fillPath();
                        // Glowing aura
                        graphics.lineStyle(2, 0xffff00, Math.sin(time / 100) * 0.3 + 0.7);
                        graphics.strokeCircle(screenX, screenY, enemy.size + 4);
                        // Gun turrets
                        graphics.fillStyle(0x333333);
                        graphics.fillRect(screenX - enemy.size * 0.8, screenY - 4, enemy.size * 0.6, 4);
                        graphics.fillRect(screenX + enemy.size * 0.3, screenY - 4, enemy.size * 0.6, 4);
                    }

                    // Health bar
                    if (enemy.health < enemy.maxHealth) {
                        const healthPct = enemy.health / enemy.maxHealth;
                        graphics.fillStyle(0x333333);
                        graphics.fillRect(screenX - enemy.size, screenY - enemy.size - 8, enemy.size * 2, 4);
                        graphics.fillStyle(healthPct > 0.5 ? 0x44ff44 : (healthPct > 0.25 ? 0xffff00 : 0xff4444));
                        graphics.fillRect(screenX - enemy.size, screenY - enemy.size - 8, enemy.size * 2 * healthPct, 4);
                    }

                    // Draw laser beam if active
                    if (enemy.laserActive && enemy.laserTarget) {
                        const targetScreenX = enemy.laserTarget.x - camera.x;
                        const targetScreenY = enemy.laserTarget.y - camera.y;
                        const laserPulse = Math.sin(Date.now() / 60) * 0.3 + 0.7;
                        const color = enemy.laserColor || 0xff0000;

                        // Outer glow - wider for bigger enemies
                        const glowWidth = enemy.size > 20 ? 18 : (enemy.size > 15 ? 14 : 10);
                        graphics.lineStyle(glowWidth, color, laserPulse * 0.25);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Middle glow
                        graphics.lineStyle(glowWidth * 0.5, color, laserPulse * 0.6);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Core beam - very bright
                        graphics.lineStyle(glowWidth * 0.25, 0xffffff, laserPulse * 0.95);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Impact effect at target
                        graphics.fillStyle(color, laserPulse * 0.7);
                        graphics.fillCircle(targetScreenX, targetScreenY, 14);
                        graphics.fillStyle(0xffffff, laserPulse * 0.5);
                        graphics.fillCircle(targetScreenX, targetScreenY, 7);
                    }
                }
            });

            enemies = enemies.filter(e => e.health > 0);
            document.getElementById('enemy-count').textContent = enemies.length;

            // Enemy bullets
            enemyBullets.forEach(bullet => {
                const dx = bullet.targetX - bullet.x;
                const dy = bullet.targetY - bullet.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist > bullet.speed) {
                    bullet.x += (dx / dist) * bullet.speed;
                    bullet.y += (dy / dist) * bullet.speed;
                } else {
                    bullet.hit = true;

                    // Check if hit player (only if not respawning/invulnerable)
                    if (player.respawnTimer <= 0 && player.invulnerable <= 0) {
                        const playerDist = Math.sqrt((player.x - bullet.x)**2 + (player.y - bullet.y)**2);
                        if (playerDist < 20) {
                            player.health -= bullet.damage;
                            updatePlayerHealthUI();
                            spawnParticles(player.x, player.y, 0xff0000, 5);

                            if (player.health <= 0) {
                                respawnPlayer();
                            }
                        }
                    }

                    // Splash damage for artillery
                    if (bullet.splash) {
                        spawnParticles(bullet.x, bullet.y, 0x448844, 5); // Reduced from 15
                        spawnParticles(bullet.x, bullet.y, 0xffaa00, 3); // Reduced from 10

                        // Damage buildings in splash radius
                        const splashRadius = TILE_SIZE * 2;
                        const damagedBuildings = [];
                        buildings.forEach(b => {
                            const bx = b.x * TILE_SIZE + TILE_SIZE / 2;
                            const by = b.y * TILE_SIZE + TILE_SIZE / 2;
                            const bDist = Math.sqrt((bx - bullet.x)**2 + (by - bullet.y)**2);
                            if (bDist < splashRadius) {
                                const falloff = 1 - (bDist / splashRadius);
                                b.health -= bullet.damage * falloff;
                                if (b.type === 'core') {
                                    coreHealth = b.health;
                                    if (coreHealth <= 0) {
                                        gameOver = true;
                                        alert('Game Over! Wave ' + wave);
                                    }
                                } else if (b.health <= 0) {
                                    damagedBuildings.push(b);
                                }
                            }
                        });
                        // Remove destroyed buildings
                        damagedBuildings.forEach(b => {
                            destroyBuilding(b);
                        });
                    }

                    // Check if hit building (non-splash)
                    if (bullet.targetBuilding && !bullet.splash) {
                        bullet.targetBuilding.health -= bullet.damage;
                        if (bullet.targetBuilding.type === 'core') {
                            coreHealth = bullet.targetBuilding.health;
                            if (coreHealth <= 0) {
                                gameOver = true;
                                alert('Game Over! Wave ' + wave);
                            }
                        } else if (bullet.targetBuilding.health <= 0) {
                            destroyBuilding(bullet.targetBuilding);
                        }
                    }
                }

                if (!bullet.hit) {
                    const screenX = bullet.x - camera.x;
                    const screenY = bullet.y - camera.y;

                    // Different bullet visuals based on enemy type
                    if (bullet.enemyType === 'sniper') {
                        graphics.fillStyle(0x8844ff);
                        graphics.fillCircle(screenX, screenY, 3);
                        // Trail
                        graphics.lineStyle(2, 0x8844ff, 0.5);
                        const trailLen = 15;
                        const dx = bullet.targetX - bullet.x;
                        const dy = bullet.targetY - bullet.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 0) {
                            graphics.lineBetween(screenX, screenY,
                                screenX - (dx/dist) * trailLen,
                                screenY - (dy/dist) * trailLen);
                        }
                    } else if (bullet.enemyType === 'artillery') {
                        // Arc indicator
                        const progress = 1 - (Math.sqrt((bullet.targetX - bullet.x)**2 + (bullet.targetY - bullet.y)**2) /
                                             Math.sqrt((bullet.targetX - bullet.startX)**2 + (bullet.targetY - bullet.startY)**2 + 1));
                        const arcHeight = Math.sin(progress * Math.PI) * 20;
                        graphics.fillStyle(0x88ff88);
                        graphics.fillCircle(screenX, screenY - arcHeight, 5);
                        // Shadow
                        graphics.fillStyle(0x000000, 0.3);
                        graphics.fillCircle(screenX, screenY + 5, 3);
                    } else {
                        graphics.fillStyle(0xff8800);
                        graphics.fillCircle(screenX, screenY, 4);
                    }
                }
            });

            enemyBullets = enemyBullets.filter(b => !b.hit);
            
            // Hard limit on bullets for performance
            if (enemyBullets.length > 100) {
                enemyBullets.splice(0, enemyBullets.length - 100);
            }

            // Turret AI
            buildings.forEach(b => {
                if (b.type === 'turret' || b.type === 'scatter' || b.type === 'laser' || b.type === 'alloy-turret' || b.type === 'stormer') {
                    if (b.type === 'laser' && !b.powered) return;
                    if ((b.type === 'turret' || b.type === 'scatter' || b.type === 'alloy-turret' || b.type === 'stormer') && b.ammo <= 0) return;

                    const data = BUILDINGS[b.type];
                    b.cooldown = (b.cooldown || 0) - delta;

                    const tx = b.x * TILE_SIZE + TILE_SIZE/2;
                    const ty = b.y * TILE_SIZE + TILE_SIZE/2;
                    const range = data.range * TILE_SIZE;

                    // Find closest enemy for targeting (always track, even when on cooldown)
                    let closest = null;
                    let closestDist = Infinity;

                    enemies.forEach(e => {
                        if (e.delay > 0) return;
                        const dist = Math.sqrt((e.x - tx)**2 + (e.y - ty)**2);
                        if (dist < closestDist && dist < range) {
                            closest = e;
                            closestDist = dist;
                        }
                    });

                    // Update turret rotation to track target smoothly
                    if (closest) {
                        const targetAngle = Math.atan2(closest.y - ty, closest.x - tx);
                        if (b.turretAngle === undefined) b.turretAngle = targetAngle;

                        // Smooth rotation toward target
                        let angleDiff = targetAngle - b.turretAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        b.turretAngle += angleDiff * 0.15; // Rotation speed
                    }

                    if (b.cooldown <= 0 && enemies.length > 0 && closest) {
                        if (b.type === 'turret') {
                            bullets.push({
                                x: tx, y: ty,
                                targetX: closest.x, targetY: closest.y,
                                speed: 10, damage: data.damage,
                                type: 'bullet'
                            });
                            b.ammo--;
                        } else if (b.type === 'alloy-turret') {
                            // Salvo fires rapid bursts
                            bullets.push({
                                x: tx, y: ty,
                                targetX: closest.x, targetY: closest.y,
                                speed: 12, damage: data.damage,
                                type: 'alloy'
                            });
                            b.ammo--;
                        } else if (b.type === 'scatter') {
                            for (let i = 0; i < data.shots; i++) {
                                const spread = (i - 1) * 0.2;
                                const angle = Math.atan2(closest.y - ty, closest.x - tx) + spread;
                                bullets.push({
                                    x: tx, y: ty,
                                    vx: Math.cos(angle) * 8,
                                    vy: Math.sin(angle) * 8,
                                    speed: 8, damage: data.damage,
                                    life: 30,
                                    type: 'scatter'
                                });
                            }
                            b.ammo -= 2;
                        } else if (b.type === 'laser') {
                            closest.health -= data.damage;
                            spawnParticles(closest.x, closest.y, 0x6666ff, 8);

                            const screenTx = tx - camera.x;
                            const screenTy = ty - camera.y;
                            const screenEx = closest.x - camera.x;
                            const screenEy = closest.y - camera.y;

                            graphics.lineStyle(3, 0x6666ff, 0.8);
                            graphics.lineBetween(screenTx, screenTy, screenEx, screenEy);

                            // Chain lightning
                            enemies.forEach(e2 => {
                                if (e2 !== closest && e2.delay <= 0) {
                                    const chainDist = Math.sqrt((e2.x - closest.x)**2 + (e2.y - closest.y)**2);
                                    if (chainDist < TILE_SIZE * 2) {
                                        e2.health -= data.damage * 0.5;
                                        const screen2x = e2.x - camera.x;
                                        const screen2y = e2.y - camera.y;
                                        graphics.lineStyle(2, 0x4444cc, 0.6);
                                        graphics.lineBetween(screenEx, screenEy, screen2x, screen2y);
                                    }
                                }
                            });
                        } else if (b.type === 'stormer') {
                            // Stormer fires continuous sand stream, hits multiple enemies in cone
                            const angle = b.turretAngle || Math.atan2(closest.y - ty, closest.x - tx);
                            const coneWidth = 0.4; // Cone spread in radians
                            
                            enemies.forEach(e => {
                                if (e.delay > 0) return;
                                const dist = Math.sqrt((e.x - tx)**2 + (e.y - ty)**2);
                                const angleToEnemy = Math.atan2(e.y - ty, e.x - tx);
                                let angleDiff = angleToEnemy - angle;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                                
                                if (dist < range && Math.abs(angleDiff) < coneWidth) {
                                    e.health -= data.damage;
                                    // Apply slow effect
                                    e.slowedUntil = Date.now() + 1000; // Slow for 1 second
                                    e.slowFactor = data.slowEffect; // 50% speed
                                    spawnParticles(e.x, e.y, 0xc9b592, 5);
                                }
                            });
                            
                            // Visual sand blast effect
                            const screenTx = tx - camera.x;
                            const screenTy = ty - camera.y;
                            for (let i = 0; i < 5; i++) {
                                const spreadAngle = angle + (Math.random() - 0.5) * coneWidth * 2;
                                const len = range * (0.7 + Math.random() * 0.3);
                                const ex = tx + Math.cos(spreadAngle) * len;
                                const ey = ty + Math.sin(spreadAngle) * len;
                                const screenEx = ex - camera.x;
                                const screenEy = ey - camera.y;
                                graphics.lineStyle(2 + Math.random() * 2, 0xc9b592, 0.3 + Math.random() * 0.3);
                                graphics.lineBetween(screenTx, screenTy, screenEx, screenEy);
                            }
                            
                            b.ammo--;
                        }
                        // Apply cooldown (slower when low power for laser)
                        const cooldownMult = (b.type === 'laser' && b.powerEfficiency) ? 
                            (1 / Math.max(0.2, b.powerEfficiency)) : 1.0;
                        b.cooldown = data.cooldown * cooldownMult;
                    }
                }
            });

            // Update bullets
            bullets.forEach(bullet => {
                if (bullet.type === 'scatter') {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    bullet.life--;

                    if (bullet.life <= 0) {
                        bullet.hit = true;
                    } else {
                        enemies.forEach(e => {
                            if (e.delay <= 0) {
                                const dist = Math.sqrt((e.x - bullet.x)**2 + (e.y - bullet.y)**2);
                                if (dist < e.size + 4) {
                                    e.health -= bullet.damage;
                                    bullet.hit = true;
                                    spawnParticles(bullet.x, bullet.y, 0xffaa00, 3);
                                }
                            }
                        });
                    }
                } else {
                    const dx = bullet.targetX - bullet.x;
                    const dy = bullet.targetY - bullet.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist > bullet.speed) {
                        bullet.x += (dx / dist) * bullet.speed;
                        bullet.y += (dy / dist) * bullet.speed;
                    } else {
                        bullet.hit = true;
                        enemies.forEach(e => {
                            const eDist = Math.sqrt((e.x - bullet.x)**2 + (e.y - bullet.y)**2);
                            if (eDist < 20) {
                                e.health -= bullet.damage;
                                spawnParticles(e.x, e.y, 0xffff00, 3);
                            }
                        });
                    }
                }

                if (!bullet.hit) {
                    const screenX = bullet.x - camera.x;
                    const screenY = bullet.y - camera.y;
                    const bulletColor = bullet.type === 'scatter' ? 0xffaa00 :
                                       bullet.type === 'alloy' ? 0xb8967a : 0xffff00;
                    graphics.fillStyle(bulletColor);
                    graphics.fillCircle(screenX, screenY, bullet.type === 'scatter' ? 3 : 4);
                }
            });

            bullets = bullets.filter(b => !b.hit);
            
            // Hard limit on bullets for performance
            if (bullets.length > 80) {
                bullets.splice(0, bullets.length - 80);
            }

            // Update particles
            // Update and draw particles (optimized with culling)
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }

                // Only draw particles on screen
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                if (screenX > -20 && screenX < window.innerWidth + 20 &&
                    screenY > -20 && screenY < window.innerHeight + 20) {
                    graphics.fillStyle(p.color, p.life / 30);
                    graphics.fillCircle(screenX, screenY, p.size * (p.life / 30));
                }
            }
            
            // Limit total particle count for performance
            if (particles.length > 1000) {
                particles.splice(0, particles.length - 1000);
            }

            // Draw player ship
            drawPlayer();

            // Building preview
            if (selectedBuilding && selectedBuilding !== 'delete') {
                const pointer = scene.input.activePointer;
                const world = screenToWorld(pointer.x, pointer.y);
                const tile = worldToTile(world.x, world.y);

                if (tile.x >= 0 && tile.x < MAP_WIDTH && tile.y >= 0 && tile.y < MAP_HEIGHT) {
                    const screenX = tile.x * TILE_SIZE - camera.x;
                    const screenY = tile.y * TILE_SIZE - camera.y;

                    const data = BUILDINGS[selectedBuilding];
                    const width = data.width || 1;
                    const height = data.height || 1;

                    const canPlace = map[tile.y][tile.x] === 0 &&
                                    terrainMap[tile.y][tile.x] !== TERRAIN.WATER &&
                                    canAfford(selectedBuilding);
                    const isDrill = selectedBuilding === 'drill' || selectedBuilding === 'pneumatic-drill' || selectedBuilding === 'alloy-drill';
                    
                    // For drills, check if ANY tile in the 2x2 area has ore
                    let hasOreOrSand = false;
                    if (isDrill) {
                        for (let dy = 0; dy < height; dy++) {
                            for (let dx = 0; dx < width; dx++) {
                                if (tile.y + dy >= MAP_HEIGHT || tile.x + dx >= MAP_WIDTH) continue;
                                if ((oreMap[tile.y + dy] && oreMap[tile.y + dy][tile.x + dx]) ||
                                    (terrainMap[tile.y + dy] && terrainMap[tile.y + dy][tile.x + dx] === TERRAIN.SAND)) {
                                    hasOreOrSand = true;
                                    break;
                                }
                            }
                            if (hasOreOrSand) break;
                        }
                    }
                    const needsOre = isDrill && !hasOreOrSand;

                    // Draw preview for full building size
                    graphics.fillStyle(needsOre ? 0xff0000 : (canPlace ? 0x00ff00 : 0xff0000), 0.3);
                    graphics.fillRect(screenX, screenY, TILE_SIZE * width, TILE_SIZE * height);

                    // Draw direction arrow in center for rotatable buildings
                    if (isDrill || selectedBuilding === 'conveyor' || selectedBuilding === 'alloy-conveyor' || selectedBuilding === 'graphite-press' || selectedBuilding === 'alloy-factory' || selectedBuilding === 'thermal-generator' || selectedBuilding === 'payload-conveyor') {
                        const centerX = screenX + (TILE_SIZE * width) / 2;
                        const centerY = screenY + (TILE_SIZE * height) / 2;
                        drawArrow(centerX, centerY, rotation, 0xffffff);
                    }

                    // Show range from center
                    if (data.range) {
                        const centerX = screenX + (TILE_SIZE * width) / 2;
                        const centerY = screenY + (TILE_SIZE * height) / 2;
                        graphics.lineStyle(1, 0x4444ff, 0.3);
                        graphics.strokeCircle(centerX, centerY, data.range * TILE_SIZE);
                    }
                    if (data.powerRange) {
                        const centerX = screenX + (TILE_SIZE * width) / 2;
                        const centerY = screenY + (TILE_SIZE * height) / 2;
                        graphics.lineStyle(1, 0xffcc00, 0.3);
                        graphics.strokeCircle(centerX, centerY, data.powerRange * TILE_SIZE);
                    }
                }
            }

            // Update tooltip continuously based on mouse position
            const pointer = scene.input.activePointer;
            const world = screenToWorld(pointer.x, pointer.y);
            const hoverTile = worldToTile(world.x, world.y);
            updateTooltip(pointer, hoverTile);

            // Draw minimap
            drawMinimap();
        }

        function drawPlayer() {
            // Don't draw if respawning
            if (player.respawnTimer > 0) {
                // Draw ghost/respawn indicator
                const screenX = player.x - camera.x;
                const screenY = player.y - camera.y;
                const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.3;
                graphics.fillStyle(0x4488ff, pulse);
                graphics.fillCircle(screenX, screenY, 15);
                graphics.lineStyle(2, 0xffffff, pulse);
                graphics.strokeCircle(screenX, screenY, 20 + Math.sin(Date.now() / 200) * 5);
                return;
            }

            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;

            // Invulnerability shield
            if (player.invulnerable > 0) {
                const shieldPulse = Math.sin(Date.now() / 50) * 0.3 + 0.5;
                graphics.fillStyle(0x44ffff, shieldPulse * 0.3);
                graphics.fillCircle(screenX, screenY, 25);
                graphics.lineStyle(2, 0x44ffff, shieldPulse);
                graphics.strokeCircle(screenX, screenY, 25);
            }

            // Save graphics state and rotate
            graphics.save();
            graphics.translate(screenX, screenY);
            graphics.rotate(player.angle);

            // Shadow (slightly offset)
            graphics.fillStyle(0x000000, 0.3);
            graphics.fillEllipse(2, 3, 16, 10);

            // Industrial ship body - rectangular with angled front
            // Main hull body
            graphics.fillStyle(0x555566);
            graphics.fillRect(-10, -8, 20, 16);

            // Front angled section
            graphics.fillStyle(0x666677);
            graphics.beginPath();
            graphics.moveTo(10, -8);  // right top
            graphics.lineTo(16, -4);  // nose right
            graphics.lineTo(16, 4);   // nose left
            graphics.lineTo(10, 8);   // left bottom
            graphics.closePath();
            graphics.fillPath();

            // Dark panel lines for industrial look
            graphics.lineStyle(1, 0x333344);
            graphics.lineBetween(-10, -3, 10, -3);
            graphics.lineBetween(-10, 3, 10, 3);
            graphics.lineBetween(0, -8, 0, 8);

            // Cockpit window (small and boxy)
            graphics.fillStyle(0x447788, 0.8);
            graphics.fillRect(6, -3, 6, 6);
            graphics.lineStyle(1, 0x223344);
            graphics.strokeRect(6, -3, 6, 6);

            // Side thrusters (industrial blocks)
            graphics.fillStyle(0x444455);
            graphics.fillRect(-12, -6, 3, 4);
            graphics.fillRect(-12, 2, 3, 4);

            // Engine glow
            const engineGlow = Math.sin(Date.now() / 40) * 0.3 + 0.7;
            const isMoving = keys.W?.isDown || keys.S?.isDown || keys.A?.isDown || keys.D?.isDown;
            const glowIntensity = isMoving ? 1 : 0.5;

            graphics.fillStyle(0xff4400, engineGlow * glowIntensity * 0.7);
            graphics.fillRect(-14, -5, 2, 3);
            graphics.fillRect(-14, 2, 2, 3);

            graphics.fillStyle(0xffaa00, engineGlow * glowIntensity * 0.5);
            graphics.fillRect(-13, -4, 1, 2);
            graphics.fillRect(-13, 2, 1, 2);

            // Warning stripes on front
            graphics.fillStyle(0xffcc00);
            graphics.fillRect(10, -6, 2, 2);
            graphics.fillRect(10, 4, 2, 2);

            // Restore graphics state
            graphics.restore();

            // Mining laser - yellow beam to target ore (wider and brighter)
            if (miningMode && miningTarget) {
                const targetScreenX = miningTarget.x - camera.x;
                const targetScreenY = miningTarget.y - camera.y;

                // Laser glow/pulse effect
                const laserPulse = Math.sin(Date.now() / 80) * 0.3 + 0.7;

                // Outer glow - wider
                graphics.lineStyle(14, 0xffff00, laserPulse * 0.3);
                graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                // Middle glow - brighter
                graphics.lineStyle(7, 0xffff44, laserPulse * 0.7);
                graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                // Core beam - very bright
                graphics.lineStyle(3, 0xffffcc, laserPulse * 0.95);
                graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                // Impact effect at target - larger and brighter
                graphics.fillStyle(0xffff00, laserPulse * 0.7);
                graphics.fillCircle(targetScreenX, targetScreenY, 12);
                graphics.fillStyle(0xffffff, laserPulse * 0.6);
                graphics.fillCircle(targetScreenX, targetScreenY, 6);
            } else if (miningMode) {
                // Show mining mode active indicator
                const miningPulse = Math.sin(Date.now() / 150) * 0.3 + 0.7;
                graphics.lineStyle(2, 0x44ff44, miningPulse * 0.6);
                graphics.strokeCircle(screenX, screenY, 30);
            }
        }

        function drawBuilding(b, screenX, screenY) {
            const px = screenX;
            const py = screenY;

            if (b.type === 'core') {
                // Large detailed core
                graphics.fillStyle(0x1a3a1a);
                graphics.fillRoundedRect(px + 2, py + 2, TILE_SIZE * 2 - 4, TILE_SIZE * 2 - 4, 8);

                // Outer ring
                graphics.fillStyle(0x2d5a2d);
                graphics.fillRoundedRect(px + 6, py + 6, TILE_SIZE * 2 - 12, TILE_SIZE * 2 - 12, 6);

                // Inner platform
                graphics.fillStyle(0x4CAF50);
                graphics.fillRoundedRect(px + 12, py + 12, TILE_SIZE * 2 - 24, TILE_SIZE * 2 - 24, 4);

                // Core crystal
                graphics.fillStyle(0x81C784);
                graphics.fillCircle(px + TILE_SIZE, py + TILE_SIZE, 12);

                // Glow effect
                const glow = Math.sin(Date.now() / 200) * 0.2 + 0.4;
                graphics.fillStyle(0xaaffaa, glow);
                graphics.fillCircle(px + TILE_SIZE, py + TILE_SIZE, 16);

                // Resource intake ports
                graphics.fillStyle(0x333333);
                graphics.fillRect(px + TILE_SIZE - 3, py + 2, 6, 4);
                graphics.fillRect(px + TILE_SIZE - 3, py + TILE_SIZE * 2 - 6, 6, 4);
                graphics.fillRect(px + 2, py + TILE_SIZE - 3, 4, 6);
                graphics.fillRect(px + TILE_SIZE * 2 - 6, py + TILE_SIZE - 3, 4, 6);

            } else if (b.type === 'drill') {
                // Industrial mining drill - 2x2 with better visuals
                const width = TILE_SIZE * 2;
                const height = TILE_SIZE * 2;
                
                // Base platform
                graphics.fillStyle(0x4a4a4a);
                graphics.fillRoundedRect(px + 2, py + 2, width - 4, height - 4, 6);

                // Metal housing
                graphics.fillStyle(0x777777);
                graphics.fillRoundedRect(px + 8, py + 8, width - 16, height - 16, 4);

                // Corner hydraulics
                graphics.fillStyle(0x555555);
                graphics.fillRect(px + 6, py + 6, 8, 8);
                graphics.fillRect(px + width - 14, py + 6, 8, 8);
                graphics.fillRect(px + 6, py + height - 14, 8, 8);
                graphics.fillRect(px + width - 14, py + height - 14, 8, 8);
                
                // Warning stripes on edges
                graphics.fillStyle(0xffcc00);
                graphics.fillRect(px + 12, py + 10, width - 24, 3);
                graphics.fillRect(px + 12, py + height - 13, width - 24, 3);

                // Rotating drill head assembly (larger for 2x2)
                const drillAngle = (Date.now() / 100) % (Math.PI * 2);
                
                // Large drill housing
                graphics.fillStyle(0x5a5a5a);
                graphics.fillCircle(px + width/2, py + height/2, 18);
                
                // Spinning drill bits (3 arms)
                graphics.fillStyle(0xcccccc);
                for (let i = 0; i < 3; i++) {
                    const a = drillAngle + i * Math.PI * 2 / 3;
                    const bitX = px + width/2 + Math.cos(a) * 13;
                    const bitY = py + height/2 + Math.sin(a) * 13;
                    graphics.fillCircle(bitX, bitY, 5);
                }
                
                // Center bolt
                graphics.fillStyle(0x333333);
                graphics.fillCircle(px + width/2, py + height/2, 8);
                graphics.fillStyle(0x666666);
                graphics.fillCircle(px + width/2, py + height/2, 4);

                // Ore count indicator (dots in corners)
                if (b.oreCount && b.oreCount > 1) {
                    graphics.fillStyle(0x4CAF50);
                    const dotSize = 3;
                    const positions = [
                        { x: px + 10, y: py + 10 },
                        { x: px + width - 10, y: py + 10 },
                        { x: px + 10, y: py + height - 10 },
                        { x: px + width - 10, y: py + height - 10 }
                    ];
                    for (let i = 0; i < Math.min(b.oreCount, 4); i++) {
                        graphics.fillCircle(positions[i].x, positions[i].y, dotSize);
                    }
                }

            } else if (b.type === 'pneumatic-drill') {
                // Pneumatic drill - 2x2 advanced drill with hydraulic details
                const width = TILE_SIZE * 2;
                const height = TILE_SIZE * 2;
                
                // Base platform with darker brown
                graphics.fillStyle(0x6a4a2a);
                graphics.fillRoundedRect(px + 2, py + 2, width - 4, height - 4, 6);

                // Copper/bronze housing
                graphics.fillStyle(0xB87333);
                graphics.fillRoundedRect(px + 8, py + 8, width - 16, height - 16, 4);

                // Pneumatic cylinders on corners
                graphics.fillStyle(0x8a6a4a);
                const cylinderSize = 10;
                graphics.fillRoundedRect(px + 6, py + 6, cylinderSize, cylinderSize, 2);
                graphics.fillRoundedRect(px + width - 16, py + 6, cylinderSize, cylinderSize, 2);
                graphics.fillRoundedRect(px + 6, py + height - 16, cylinderSize, cylinderSize, 2);
                graphics.fillRoundedRect(px + width - 16, py + height - 16, cylinderSize, cylinderSize, 2);

                // Piston rods extending from cylinders
                graphics.fillStyle(0xaaaaaa);
                graphics.fillRect(px + 11, py + 16, 2, 8);
                graphics.fillRect(px + width - 13, py + 16, 2, 8);
                graphics.fillRect(px + 11, py + height - 24, 2, 8);
                graphics.fillRect(px + width - 13, py + height - 24, 2, 8);

                // Fast rotating quad drill (larger for 2x2)
                const pDrillAngle = (Date.now() / 50) % (Math.PI * 2);
                
                // Drill housing ring
                graphics.fillStyle(0x6a5a4a);
                graphics.fillCircle(px + width/2, py + height/2, 16);
                
                // Rotating drill bits (4 sharp blades)
                graphics.fillStyle(0xdddddd);
                for (let i = 0; i < 4; i++) {
                    const a = pDrillAngle + i * Math.PI / 2;
                    const bitX = px + width/2 + Math.cos(a) * 12;
                    const bitY = py + height/2 + Math.sin(a) * 12;
                    // Draw blade shape
                    graphics.fillRect(bitX - 4, bitY - 2, 8, 4);
                    graphics.fillCircle(bitX + 2, bitY, 3);
                }
                
                // Center hub
                graphics.fillStyle(0x555555);
                graphics.fillCircle(px + width/2, py + height/2, 9);
                graphics.fillStyle(0x888888);
                graphics.fillCircle(px + width/2, py + height/2, 6);

                // Warning stripes
                graphics.fillStyle(0xffcc00);
                graphics.fillRect(px + 12, py + 8, width - 24, 3);
                graphics.fillRect(px + 8, py + 12, 3, height - 24);
                graphics.fillRect(px + width - 11, py + 12, 3, height - 24);
                graphics.fillRect(px + 12, py + height - 11, width - 24, 3);

                drawArrow(px + width/2, py + height/2, b.rotation, 0xffcc00);

                // Ore count indicator
                if (b.oreCount && b.oreCount > 1) {
                    graphics.fillStyle(0x4CAF50);
                    const dotSize = 3;
                    const positions = [
                        { x: px + 12, y: py + height - 12 },
                        { x: px + width - 12, y: py + height - 12 },
                        { x: px + 12, y: py + height - 18 },
                        { x: px + width - 12, y: py + height - 18 }
                    ];
                    for (let i = 0; i < Math.min(b.oreCount, 4); i++) {
                        graphics.fillCircle(positions[i].x, positions[i].y, dotSize);
                    }
                }

            } else if (b.type === 'alloy-drill') {
                // Alloy drill - 2x2 premium drill with advanced design
                const width = TILE_SIZE * 2;
                const height = TILE_SIZE * 2;
                
                // Premium alloy base
                graphics.fillStyle(0x7a5a4a);
                graphics.fillRoundedRect(px + 2, py + 2, width - 4, height - 4, 6);

                // Alloy housing with gradient effect
                graphics.fillStyle(0xb8967a);
                graphics.fillRoundedRect(px + 6, py + 6, width - 12, height - 12, 5);
                
                // Inner reinforced frame
                graphics.fillStyle(0xa88868);
                graphics.fillRoundedRect(px + 10, py + 10, width - 20, height - 20, 4);

                // Decorative corner reinforcements
                graphics.fillStyle(0xd4a574);
                const cornerSize = 8;
                graphics.fillRoundedRect(px + 8, py + 8, cornerSize, cornerSize, 2);
                graphics.fillRoundedRect(px + width - 16, py + 8, cornerSize, cornerSize, 2);
                graphics.fillRoundedRect(px + 8, py + height - 16, cornerSize, cornerSize, 2);
                graphics.fillRoundedRect(px + width - 16, py + height - 16, cornerSize, cornerSize, 2);

                // Ultra-fast rotating drill (4x speed, 6 blades)
                const aDrillAngle = (Date.now() / 25) % (Math.PI * 2);
                
                // Outer drill ring
                graphics.fillStyle(0x9a8a7a);
                graphics.fillCircle(px + width/2, py + height/2, 18);
                
                // Six rotating cutting blades
                graphics.fillStyle(0xeeeeee);
                for (let i = 0; i < 6; i++) {
                    const a = aDrillAngle + i * Math.PI / 3;
                    const bladeX = px + width/2 + Math.cos(a) * 14;
                    const bladeY = py + height/2 + Math.sin(a) * 14;
                    // Diamond-shaped blade
                    graphics.fillCircle(bladeX, bladeY, 5);
                    graphics.fillRect(bladeX - 2, bladeY - 4, 4, 8);
                }
                
                // Central hub with metallic look
                graphics.fillStyle(0x666666);
                graphics.fillCircle(px + width/2, py + height/2, 11);
                graphics.fillStyle(0xaaaaaa);
                graphics.fillCircle(px + width/2, py + height/2, 8);
                graphics.fillStyle(0xcccccc);
                graphics.fillCircle(px + width/2, py + height/2, 5);

                // Premium detail lines
                graphics.fillStyle(0xd4a574);
                // Horizontal and vertical accent lines
                graphics.fillRect(px + width/2 - 1, py + 12, 2, 10);
                graphics.fillRect(px + width/2 - 1, py + height - 22, 2, 10);
                graphics.fillRect(px + 12, py + height/2 - 1, 10, 2);
                graphics.fillRect(px + width - 22, py + height/2 - 1, 10, 2);

                drawArrow(px + width/2, py + height/2, b.rotation, 0xd4a574);

                // Ore count indicator (use brighter green to distinguish from premium dots)
                if (b.oreCount && b.oreCount > 1) {
                    graphics.fillStyle(0x44ff44);
                    const dotSize = 4;
                    // Position near center top
                    const startX = px + width/2 - (b.oreCount - 1) * 5;
                    for (let i = 0; i < Math.min(b.oreCount, 4); i++) {
                        graphics.fillCircle(startX + i * 10, py + 8, dotSize);
                    }
                }

            } else if (b.type === 'graphite-press') {
                // 2x2 Graphite Press - top-down view
                const pressW = TILE_SIZE * 2;
                const pressH = TILE_SIZE * 2;
                
                // Main press body - dark gray base
                graphics.fillStyle(0x1a1a1a);
                graphics.fillRoundedRect(px + 2, py + 2, pressW - 4, pressH - 4, 6);
                
                // Press platform
                graphics.fillStyle(0x2a2a2a);
                graphics.fillRoundedRect(px + 6, py + 6, pressW - 12, pressH - 12, 4);
                
                // Four compression pistons at corners
                const pistonSize = b.craftProgress ? 
                    8 + Math.sin((b.craftProgress / BUILDINGS['graphite-press'].craftTime) * Math.PI * 2) * 3 : 8;
                graphics.fillStyle(0x555555);
                graphics.fillCircle(px + 16, py + 16, pistonSize);
                graphics.fillCircle(px + pressW - 16, py + 16, pistonSize);
                graphics.fillCircle(px + 16, py + pressH - 16, pistonSize);
                graphics.fillCircle(px + pressW - 16, py + pressH - 16, pistonSize);
                
                // Central compression chamber
                graphics.fillStyle(0x3a3a3a);
                graphics.fillRoundedRect(px + pressW/2 - 12, py + pressH/2 - 12, 24, 24, 3);
                
                // Compression indicator in center
                if (b.craftProgress > 0) {
                    const progress = b.craftProgress / BUILDINGS['graphite-press'].craftTime;
                    graphics.fillStyle(0x222222, 0.3 + progress * 0.5);
                    graphics.fillCircle(px + pressW/2, py + pressH/2, 10);
                }
                
                // Storage indicators - coal on left, graphite output on right
                if (b.coalStored > 0) {
                    const coalPct = Math.min(1, b.coalStored / 2);
                    graphics.fillStyle(0x444444);
                    graphics.fillRect(px + 8, py + pressH/2 - 8, 12 * coalPct, 16);
                }
                
                // Output direction arrow
                drawArrow(px + pressW/2, py + pressH/2, b.rotation, 0x666666);

            } else if (b.type === 'alloy-factory') {
                // 2x2 Alloy Factory - highly visible industrial building
                const factoryW = TILE_SIZE * 2;
                const factoryH = TILE_SIZE * 2;
                
                // Main factory building - dark industrial brown
                graphics.fillStyle(0x443322);
                graphics.fillRoundedRect(px + 2, py + 2, factoryW - 4, factoryH - 4, 6);
                
                // Factory walls
                graphics.fillStyle(0x665544);
                graphics.fillRoundedRect(px + 6, py + 6, factoryW - 12, factoryH - 12, 4);
                
                // Lead and titanium input hoppers
                graphics.fillStyle(0x888899);  // Lead hopper
                graphics.fillRect(px + 8, py + 8, 12, 10);
                graphics.fillStyle(0x4a7c9b);  // Titanium hopper
                graphics.fillRect(px + factoryW - 20, py + 8, 12, 10);
                
                // Furnace glow in center
                const glowIntensity = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                graphics.fillStyle(0xff6600, glowIntensity * 0.6);
                graphics.fillCircle(px + factoryW/2, py + factoryH/2, 14);
                graphics.fillStyle(0xffaa00, glowIntensity * 0.8);
                graphics.fillCircle(px + factoryW/2, py + factoryH/2, 10);
                
                // Chimney with smoke
                graphics.fillStyle(0x333333);
                graphics.fillRect(px + factoryW - 16, py + 4, 8, 12);
                if (b.powered) {
                    const smokeOffset = (Date.now() / 100) % 20;
                    graphics.fillStyle(0x666666, 0.4);
                    graphics.fillCircle(px + factoryW - 12, py - smokeOffset, 4);
                    graphics.fillCircle(px + factoryW - 10, py - smokeOffset - 6, 3);
                }
                
                // Alloy output chute
                graphics.fillStyle(0xb8967a);
                graphics.fillRect(px + factoryW/2 - 6, py + factoryH - 8, 12, 6);
                
                // Windows
                graphics.fillStyle(0xffcc66, glowIntensity * 0.4);
                graphics.fillRect(px + 12, py + 24, 8, 10);
                graphics.fillRect(px + factoryW - 20, py + 24, 8, 10);
                
                // Storage indicators
                if (b.leadStored > 0) {
                    const leadBar = Math.min(1, b.leadStored / 10);
                    graphics.fillStyle(0x888899);
                    graphics.fillRect(px + 4, py + factoryH - 8, 10 * leadBar, 4);
                }
                if (b.titaniumStored > 0) {
                    const titaniumBar = Math.min(1, b.titaniumStored / 10);
                    graphics.fillStyle(0x4a7c9b);
                    graphics.fillRect(px + factoryW - 14, py + factoryH - 8, 10 * titaniumBar, 4);
                }
                
                // Craft progress indicator
                if (b.craftProgress > 0) {
                    const progress = b.craftProgress / BUILDINGS['alloy-factory'].craftTime;
                    graphics.fillStyle(0x44ff44);
                    graphics.fillRect(px + 4, py + 4, (factoryW - 8) * progress, 3);
                }
                
                // Power indicator
                if (!b.powered) {
                    graphics.fillStyle(0xff4444, 0.6);
                    graphics.fillRect(px + factoryW/2 - 8, py + factoryH/2 - 2, 16, 4);
                    graphics.fillStyle(0xff4444);
                    graphics.fillCircle(px + 8, py + 8, 3);
                }

            } else if (b.type === 'miner-constructor') {
                // 2x2 Miner Constructor
                const consW = TILE_SIZE * 2;
                const consH = TILE_SIZE * 2;

                // Base platform
                graphics.fillStyle(0x2a4a2a);
                graphics.fillRoundedRect(px + 2, py + 2, consW - 4, consH - 4, 6);

                // Construction bay
                graphics.fillStyle(0x44aa44);
                graphics.fillRoundedRect(px + 8, py + 8, consW - 16, consH - 16, 4);

                // Assembly arms
                graphics.fillStyle(0x666666);
                graphics.fillRect(px + 10, py + 10, 4, consH - 20);
                graphics.fillRect(px + consW - 14, py + 10, 4, consH - 20);

                // Lead and titanium input hoppers
                graphics.fillStyle(0x888899);  // Lead hopper
                graphics.fillRect(px + 8, py + 8, 12, 10);
                graphics.fillStyle(0x4a7c9b);  // Titanium hopper
                graphics.fillRect(px + consW - 20, py + 8, 12, 10);

                // Construction platform in center (animated if crafting)
                if (b.craftProgress > 0) {
                    const progress = b.craftProgress / BUILDINGS['miner-constructor'].craftTime;

                    // Draw semi-transparent miner sprite being fabricated
                    const minerAlpha = progress * 0.7; // Fade in as progress increases
                    const centerX = px + consW/2;
                    const centerY = py + consH/2;

                    // Miner body (ghost image)
                    graphics.fillStyle(0x4CAF50, minerAlpha);
                    graphics.fillCircle(centerX, centerY, 8);

                    // Miner propeller effect
                    graphics.fillStyle(0x66BB66, minerAlpha * 0.5);
                    graphics.fillCircle(centerX - 6, centerY - 6, 3);
                    graphics.fillCircle(centerX + 6, centerY - 6, 3);

                    // Scanning line animation (back and forth quickly)
                    const scanTime = Date.now() % 800; // 800ms loop (faster)
                    const scanProgress = scanTime < 400 ? scanTime / 400 : (800 - scanTime) / 400; // Back and forth
                    const scanX = px + 12 + (consW - 24) * scanProgress;

                    // Vertical scanning line
                    graphics.lineStyle(2, 0x44ffff, 0.8);
                    graphics.lineBetween(scanX, py + 12, scanX, py + consH - 12);

                    // Glow effect on scanning line
                    graphics.lineStyle(6, 0x44ffff, 0.3);
                    graphics.lineBetween(scanX, py + 12, scanX, py + consH - 12);

                    // Assembly effect particles
                    const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                    graphics.fillStyle(0x44ff44, pulse * 0.4);
                    graphics.fillCircle(centerX, centerY, 16);
                }

                // Storage indicators
                if (b.leadStored > 0) {
                    const leadBar = Math.min(1, b.leadStored / 100);
                    graphics.fillStyle(0x888899);
                    graphics.fillRect(px + 4, py + consH - 8, 20 * leadBar, 4);
                }
                if (b.titaniumStored > 0) {
                    const titaniumBar = Math.min(1, b.titaniumStored / 100);
                    graphics.fillStyle(0x4a7c9b);
                    graphics.fillRect(px + consW - 24, py + consH - 8, 20 * titaniumBar, 4);
                }

                // Craft progress indicator
                if (b.craftProgress > 0) {
                    const progress = b.craftProgress / BUILDINGS['miner-constructor'].craftTime;
                    graphics.fillStyle(0x44ff44);
                    graphics.fillRect(px + 4, py + 4, (consW - 8) * progress, 3);
                }

            } else if (b.type === 'conveyor' || b.type === 'alloy-conveyor') {
                // Conveyor belt base - extends to full tile edges
                // Use different colors for alloy variant
                const isAlloy = b.type === 'alloy-conveyor';
                graphics.fillStyle(isAlloy ? 0x4a3a2a : 0x333333);
                graphics.fillRect(px, py, TILE_SIZE, TILE_SIZE);

                const dir = getDirection(b.rotation);
                const beltSpeed = isAlloy ? 75 : 150; // Alloy is 2x faster
                const beltPhase = (Date.now() / beltSpeed) % 1;

                // Animated belt surface with chevron pattern - full tile
                graphics.fillStyle(isAlloy ? 0x6a5a4a : 0x444444);
                graphics.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);

                // Moving chevron/arrow indicators
                for (let i = 0; i < 4; i++) {
                    const progress = ((i / 4 + beltPhase) % 1);
                    let arrowX, arrowY;

                    if (dir.x !== 0) {
                        // Horizontal conveyor
                        arrowX = px + 4 + progress * (TILE_SIZE - 8);
                        arrowY = py + TILE_SIZE / 2;

                        // Draw chevron pointing in direction
                        graphics.fillStyle(isAlloy ? 0x8a7a6a : 0x666666);
                        if (dir.x > 0) {
                            graphics.beginPath();
                            graphics.moveTo(arrowX - 3, arrowY - 4);
                            graphics.lineTo(arrowX + 2, arrowY);
                            graphics.lineTo(arrowX - 3, arrowY + 4);
                            graphics.closePath();
                            graphics.fillPath();
                        } else {
                            graphics.beginPath();
                            graphics.moveTo(arrowX + 3, arrowY - 4);
                            graphics.lineTo(arrowX - 2, arrowY);
                            graphics.lineTo(arrowX + 3, arrowY + 4);
                            graphics.closePath();
                            graphics.fillPath();
                        }
                    } else {
                        // Vertical conveyor
                        arrowX = px + TILE_SIZE / 2;
                        arrowY = py + 4 + progress * (TILE_SIZE - 8);

                        graphics.fillStyle(isAlloy ? 0x8a7a6a : 0x666666);
                        if (dir.y > 0) {
                            graphics.beginPath();
                            graphics.moveTo(arrowX - 4, arrowY - 3);
                            graphics.lineTo(arrowX, arrowY + 2);
                            graphics.lineTo(arrowX + 4, arrowY - 3);
                            graphics.closePath();
                            graphics.fillPath();
                        } else {
                            graphics.beginPath();
                            graphics.moveTo(arrowX - 4, arrowY + 3);
                            graphics.lineTo(arrowX, arrowY - 2);
                            graphics.lineTo(arrowX + 4, arrowY + 3);
                            graphics.closePath();
                            graphics.fillPath();
                        }
                    }
                }

                // Metallic side rails - extend to edges
                graphics.fillStyle(isAlloy ? 0x9a8a7a : 0x777777);
                if (dir.x !== 0) {
                    graphics.fillRect(px, py, TILE_SIZE, 3);
                    graphics.fillRect(px, py + TILE_SIZE - 3, TILE_SIZE, 3);
                    // Rail highlights
                    graphics.fillStyle(isAlloy ? 0xbaa99a : 0x999999);
                    graphics.fillRect(px, py, TILE_SIZE, 1);
                    graphics.fillRect(px, py + TILE_SIZE - 3, TILE_SIZE, 1);
                } else {
                    graphics.fillRect(px, py, 3, TILE_SIZE);
                    graphics.fillRect(px + TILE_SIZE - 3, py, 3, TILE_SIZE);
                    // Rail highlights
                    graphics.fillStyle(isAlloy ? 0xbaa99a : 0x999999);
                    graphics.fillRect(px, py, 1, TILE_SIZE);
                    graphics.fillRect(px + TILE_SIZE - 3, py, 1, TILE_SIZE);
                }

                // Roller wheels at edges
                graphics.fillStyle(isAlloy ? 0x6a5a4a : 0x555555);
                if (dir.x !== 0) {
                    graphics.fillCircle(px + 4, py + TILE_SIZE / 2, 2);
                    graphics.fillCircle(px + TILE_SIZE - 4, py + TILE_SIZE / 2, 2);
                } else {
                    graphics.fillCircle(px + TILE_SIZE / 2, py + 4, 2);
                    graphics.fillCircle(px + TILE_SIZE / 2, py + TILE_SIZE - 4, 2);
                }

            } else if (b.type === 'payload-conveyor') {
                // Payload conveyor - wider, reinforced conveyor for drones
                graphics.fillStyle(0x2a5c7b);
                graphics.fillRect(px, py, TILE_SIZE, TILE_SIZE);

                const dir = getDirection(b.rotation);
                const beltPhase = (Date.now() / 200) % 1; // Slower movement

                // Heavy-duty belt surface
                graphics.fillStyle(0x4a7c9b);
                graphics.fillRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);

                // Reinforced rails
                graphics.fillStyle(0x5a8cab);
                if (dir.x !== 0) {
                    graphics.fillRect(px, py + 2, TILE_SIZE, 4);
                    graphics.fillRect(px, py + TILE_SIZE - 6, TILE_SIZE, 4);
                } else {
                    graphics.fillRect(px + 2, py, 4, TILE_SIZE);
                    graphics.fillRect(px + TILE_SIZE - 6, py, 4, TILE_SIZE);
                }

                // Moving grid pattern to show it's active
                for (let i = 0; i < 3; i++) {
                    const progress = ((i / 3 + beltPhase) % 1);
                    graphics.fillStyle(0x6a9cbb, 0.4);

                    if (dir.x !== 0) {
                        const lineX = px + progress * TILE_SIZE;
                        graphics.fillRect(lineX, py + 4, 2, TILE_SIZE - 8);
                    } else {
                        const lineY = py + progress * TILE_SIZE;
                        graphics.fillRect(px + 4, lineY, TILE_SIZE - 8, 2);
                    }
                }

                // Show if it has a miner loaded
                if (b.payloadMiner) {
                    graphics.fillStyle(0x4CAF50, 0.8);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 6);
                }

            } else if (b.type === 'router') {
                graphics.fillStyle(0x555577);
                graphics.fillRoundedRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8, 4);
                graphics.fillStyle(0x666699);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 8);

                // Distribution arrows
                graphics.fillStyle(0x8888aa);
                for (let i = 0; i < 4; i++) {
                    const a = i * Math.PI / 2;
                    graphics.fillRect(
                        px + TILE_SIZE/2 + Math.cos(a) * 10 - 2,
                        py + TILE_SIZE/2 + Math.sin(a) * 10 - 2,
                        4, 4
                    );
                }

            } else if (b.type === 'junction') {
                graphics.fillStyle(0x775555);
                graphics.fillRoundedRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8, 4);
                graphics.lineStyle(2, 0x996666);
                graphics.lineBetween(px + 4, py + TILE_SIZE/2, px + TILE_SIZE - 4, py + TILE_SIZE/2);
                graphics.lineBetween(px + TILE_SIZE/2, py + 4, px + TILE_SIZE/2, py + TILE_SIZE - 4);

            } else if (b.type === 'generator') {
                // Coal generator with furnace
                graphics.fillStyle(0x442200);
                graphics.fillRoundedRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4, 4);

                // Furnace housing
                graphics.fillStyle(0x663300);
                graphics.fillRoundedRect(px + 5, py + 5, TILE_SIZE - 10, TILE_SIZE - 10, 3);

                // Fire window
                if (b.active) {
                    const flicker = Math.sin(Date.now() / 80) * 0.3 + 0.7;
                    graphics.fillStyle(0xff3300, flicker);
                    graphics.fillRect(px + 10, py + 10, TILE_SIZE - 20, TILE_SIZE - 20);
                    graphics.fillStyle(0xff6600, flicker * 0.8);
                    graphics.fillRect(px + 12, py + 12, TILE_SIZE - 24, TILE_SIZE - 24);
                    graphics.fillStyle(0xffaa00, flicker * 0.6);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 4);
                } else {
                    graphics.fillStyle(0x333333);
                    graphics.fillRect(px + 10, py + 10, TILE_SIZE - 20, TILE_SIZE - 20);
                }

                // Chimney
                graphics.fillStyle(0x555555);
                graphics.fillRect(px + TILE_SIZE - 10, py + 2, 6, 8);

                // Coal level indicator
                if (b.coalStored > 0) {
                    const coalPct = Math.min(1, b.coalStored / 10);
                    graphics.fillStyle(0x222222);
                    graphics.fillRect(px + 2, py + TILE_SIZE - 6, (TILE_SIZE - 4) * coalPct, 4);
                }

            } else if (b.type === 'thermal-generator') {
                // Thermal generator - 2x2 advanced power plant
                const width = TILE_SIZE * 2;
                const height = TILE_SIZE * 2;

                // Base structure
                graphics.fillStyle(0x553300);
                graphics.fillRoundedRect(px + 2, py + 2, width - 4, height - 4, 6);

                // Reactor core housing
                graphics.fillStyle(0x774400);
                graphics.fillRoundedRect(px + 8, py + 8, width - 16, height - 16, 4);

                // Central reactor chamber
                if (b.active) {
                    const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
                    graphics.fillStyle(0xff4400, pulse);
                    graphics.fillCircle(px + width/2, py + height/2, 20);
                    graphics.fillStyle(0xff6600, pulse * 0.8);
                    graphics.fillCircle(px + width/2, py + height/2, 15);
                    graphics.fillStyle(0xffaa00, pulse * 0.6);
                    graphics.fillCircle(px + width/2, py + height/2, 10);
                } else {
                    graphics.fillStyle(0x444444);
                    graphics.fillCircle(px + width/2, py + height/2, 20);
                }

                // Heat vents
                graphics.fillStyle(0x666666);
                for (let i = 0; i < 4; i++) {
                    const angle = i * Math.PI / 2;
                    const vx = px + width/2 + Math.cos(angle) * 22;
                    const vy = py + height/2 + Math.sin(angle) * 22;
                    graphics.fillRect(vx - 2, vy - 6, 4, 12);
                }

                // Chimneys/exhaust
                graphics.fillStyle(0x555555);
                graphics.fillRect(px + 10, py + 2, 8, 10);
                graphics.fillRect(px + width - 18, py + 2, 8, 10);

                // Resource indicators
                if (b.coalStored > 0) {
                    const coalPct = Math.min(1, b.coalStored / 10);
                    graphics.fillStyle(0x222222);
                    graphics.fillRect(px + 4, py + height - 10, (width - 8) * coalPct * 0.5, 4);
                }
                if (b.leadStored > 0) {
                    const leadPct = Math.min(1, b.leadStored / 10);
                    graphics.fillStyle(0x666666);
                    graphics.fillRect(px + 4 + (width - 8) * 0.5, py + height - 10, (width - 8) * leadPct * 0.5, 4);
                }

            } else if (b.type === 'power-node') {
                // Power distribution node
                graphics.fillStyle(0x554400);
                graphics.fillRoundedRect(px + 8, py + 8, TILE_SIZE - 16, TILE_SIZE - 16, 4);

                // Electric coil
                graphics.fillStyle(0x886600);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 8);

                // Glowing core
                const glow = Math.sin(Date.now() / 100) * 0.3 + 0.5;
                graphics.fillStyle(0xffcc00, glow);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 5);
                graphics.fillStyle(0xffff88, glow * 0.8);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 3);

                // Connection points
                graphics.fillStyle(0xccaa00);
                graphics.fillCircle(px + TILE_SIZE/2, py + 4, 3);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE - 4, 3);
                graphics.fillCircle(px + 4, py + TILE_SIZE/2, 3);
                graphics.fillCircle(px + TILE_SIZE - 4, py + TILE_SIZE/2, 3);

                // Draw power connections
                const range = BUILDINGS['power-node'].powerRange * TILE_SIZE;
                const nx = b.x * TILE_SIZE + TILE_SIZE/2;
                const ny = b.y * TILE_SIZE + TILE_SIZE/2;

                buildings.forEach(other => {
                    if (other === b) return;
                    // Connect to power sources, other power nodes, and all power consumers
                    const isPowerSource = other.type === 'generator' || other.type === 'thermal-generator';
                    const isPowerNode = other.type === 'power-node';
                    const isPowerConsumer = other.type === 'laser' || other.type === 'alloy-factory' || other.type === 'repair' || other.type === 'miner-constructor';

                    if (!isPowerSource && !isPowerNode && !isPowerConsumer) return;

                    const ow = other.width || 1;
                    const oh = other.height || 1;
                    const ox = (other.x + ow / 2) * TILE_SIZE;
                    const oy = (other.y + oh / 2) * TILE_SIZE;
                    const dist = Math.sqrt((ox - nx)**2 + (oy - ny)**2);

                    if (dist <= range) {
                        const screenOx = ox - camera.x;
                        const screenOy = oy - camera.y;
                        graphics.lineStyle(1, 0xffcc00, 0.4);
                        graphics.lineBetween(px + TILE_SIZE/2, py + TILE_SIZE/2, screenOx, screenOy);
                    }
                });

            } else if (b.type === 'turret') {
                // Duo turret - realistic top-down with rotation
                graphics.fillStyle(0x333333);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                // Turret base
                graphics.fillStyle(0x444444);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 12);

                // Gun housing
                graphics.fillStyle(0xcc4444);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                // Dual barrels - rotated toward target
                const angle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                const cx = px + TILE_SIZE/2;
                const cy = py + TILE_SIZE/2;
                const barrelLength = 12;
                const barrelSpacing = 4;

                graphics.fillStyle(0x666666);
                // Left barrel
                const lx1 = cx + Math.cos(angle) * barrelLength + Math.cos(angle + Math.PI/2) * barrelSpacing;
                const ly1 = cy + Math.sin(angle) * barrelLength + Math.sin(angle + Math.PI/2) * barrelSpacing;
                const lx2 = cx + Math.cos(angle + Math.PI/2) * barrelSpacing;
                const ly2 = cy + Math.sin(angle + Math.PI/2) * barrelSpacing;
                graphics.lineStyle(3, 0x666666);
                graphics.lineBetween(lx2, ly2, lx1, ly1);

                // Right barrel
                const rx1 = cx + Math.cos(angle) * barrelLength + Math.cos(angle - Math.PI/2) * barrelSpacing;
                const ry1 = cy + Math.sin(angle) * barrelLength + Math.sin(angle - Math.PI/2) * barrelSpacing;
                const rx2 = cx + Math.cos(angle - Math.PI/2) * barrelSpacing;
                const ry2 = cy + Math.sin(angle - Math.PI/2) * barrelSpacing;
                graphics.lineBetween(rx2, ry2, rx1, ry1);

                // Barrel tips
                graphics.fillStyle(0x888888);
                graphics.fillCircle(lx1, ly1, 2);
                graphics.fillCircle(rx1, ry1, 2);

                // Ammo indicator
                if (b.ammo !== undefined) {
                    const ammoPct = Math.min(1, b.ammo / 20);
                    graphics.fillStyle(ammoPct > 0.3 ? 0x44ff44 : 0xff4444);
                    graphics.fillRect(px + 3, py + TILE_SIZE - 5, (TILE_SIZE - 6) * ammoPct, 2);
                }

            } else if (b.type === 'scatter') {
                // Scatter turret - triple barrel with rotation
                graphics.fillStyle(0x333333);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                graphics.fillStyle(0x444444);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 12);

                graphics.fillStyle(0xcc6633);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                // Triple barrels - rotated toward target
                const scatterAngle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                const scx = px + TILE_SIZE/2;
                const scy = py + TILE_SIZE/2;
                const scBarrelLength = 11;

                graphics.lineStyle(4, 0x666666);
                for (let i = -1; i <= 1; i++) {
                    const spreadAngle = scatterAngle + i * 0.15;
                    const bx1 = scx;
                    const by1 = scy;
                    const bx2 = scx + Math.cos(spreadAngle) * scBarrelLength;
                    const by2 = scy + Math.sin(spreadAngle) * scBarrelLength;
                    graphics.lineBetween(bx1, by1, bx2, by2);
                }

                // Ammo indicator
                if (b.ammo !== undefined) {
                    const ammoPct = Math.min(1, b.ammo / 20);
                    graphics.fillStyle(ammoPct > 0.3 ? 0x44ff44 : 0xff4444);
                    graphics.fillRect(px + 3, py + TILE_SIZE - 5, (TILE_SIZE - 6) * ammoPct, 2);
                }

            } else if (b.type === 'laser') {
                // Arc turret - electric with rotation
                graphics.fillStyle(0x222244);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                graphics.fillStyle(0x333366);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 12);

                if (b.powered) {
                    graphics.fillStyle(0x4466cc);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                    // Electric arcs
                    const spark = Math.sin(Date.now() / 50) * 0.5 + 0.5;
                    graphics.fillStyle(0x88aaff, spark);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 5);

                    // Tesla coil pointing toward target
                    const laserAngle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                    const coilX = px + TILE_SIZE/2 + Math.cos(laserAngle) * 8;
                    const coilY = py + TILE_SIZE/2 + Math.sin(laserAngle) * 8;
                    graphics.fillStyle(0xaaccff, spark);
                    graphics.fillCircle(coilX + Math.sin(Date.now() / 30) * 2, coilY + Math.cos(Date.now() / 30) * 2, 3);
                } else {
                    graphics.fillStyle(0x445566);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                    // No power X
                    graphics.lineStyle(2, 0xff4444, 0.8);
                    graphics.lineBetween(px + 8, py + 8, px + TILE_SIZE - 8, py + TILE_SIZE - 8);
                    graphics.lineBetween(px + TILE_SIZE - 8, py + 8, px + 8, py + TILE_SIZE - 8);
                }

            } else if (b.type === 'stormer') {
                // Stormer turret - sand blaster
                graphics.fillStyle(0x8a7a6a);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                // Turret base
                graphics.fillStyle(0xa89572);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 12);

                // Sand tank
                graphics.fillStyle(0xc9b592);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                // Nozzle pointing toward target
                const stormerAngle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                const nozzleLength = 13;
                const nozzleX = px + TILE_SIZE/2 + Math.cos(stormerAngle) * nozzleLength;
                const nozzleY = py + TILE_SIZE/2 + Math.sin(stormerAngle) * nozzleLength;
                
                graphics.lineStyle(4, 0x8a7a6a);
                graphics.lineBetween(px + TILE_SIZE/2, py + TILE_SIZE/2, nozzleX, nozzleY);
                
                // Nozzle tip
                graphics.fillStyle(0x6a5a4a);
                graphics.fillCircle(nozzleX, nozzleY, 3);

                // Ammo indicator
                if (b.ammo !== undefined) {
                    const ammoPct = Math.min(1, b.ammo / 20);
                    graphics.fillStyle(ammoPct > 0.3 ? 0xc9b592 : 0xff4444);
                    graphics.fillRect(px + 3, py + TILE_SIZE - 5, (TILE_SIZE - 6) * ammoPct, 2);
                }

            } else if (b.type === 'wall') {
                // Stone wall
                graphics.fillStyle(0x555555);
                graphics.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);

                // Brick pattern
                graphics.fillStyle(0x666666);
                graphics.fillRect(px + 4, py + 4, TILE_SIZE/2 - 4, TILE_SIZE/2 - 4);
                graphics.fillRect(px + TILE_SIZE/2 + 2, py + TILE_SIZE/2 + 2, TILE_SIZE/2 - 4, TILE_SIZE/2 - 4);

                graphics.fillStyle(0x4a4a4a);
                graphics.fillRect(px + TILE_SIZE/2 + 2, py + 4, TILE_SIZE/2 - 4, TILE_SIZE/2 - 4);
                graphics.fillRect(px + 4, py + TILE_SIZE/2 + 2, TILE_SIZE/2 - 4, TILE_SIZE/2 - 4);

            } else if (b.type === 'titanium-wall') {
                // Reinforced titanium wall
                graphics.fillStyle(0x3a5c7b);
                graphics.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);

                graphics.fillStyle(0x4a7c9b);
                graphics.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);

                // Metal shine
                graphics.fillStyle(0x6a9cbb, 0.5);
                graphics.fillRect(px + 6, py + 6, TILE_SIZE - 12, 4);

                // Rivets
                graphics.fillStyle(0x2a4c6b);
                graphics.fillCircle(px + 6, py + 6, 2);
                graphics.fillCircle(px + TILE_SIZE - 6, py + 6, 2);
                graphics.fillCircle(px + 6, py + TILE_SIZE - 6, 2);
                graphics.fillCircle(px + TILE_SIZE - 6, py + TILE_SIZE - 6, 2);

            } else if (b.type === 'alloy-wall') {
                // Reinforced alloy wall
                graphics.fillStyle(0x8a6a5a);
                graphics.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);

                graphics.fillStyle(0xb8967a);
                graphics.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);

                // Metal shine
                graphics.fillStyle(0xd0b090, 0.5);
                graphics.fillRect(px + 6, py + 6, TILE_SIZE - 12, 4);

                // Heavy rivets
                graphics.fillStyle(0x6a4a3a);
                graphics.fillCircle(px + 6, py + 6, 3);
                graphics.fillCircle(px + TILE_SIZE - 6, py + 6, 3);
                graphics.fillCircle(px + 6, py + TILE_SIZE - 6, 3);
                graphics.fillCircle(px + TILE_SIZE - 6, py + TILE_SIZE - 6, 3);

            } else if (b.type === 'alloy-turret') {
                // Salvo turret - alloy rapid fire with rotation
                graphics.fillStyle(0x444444);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                // Turret base
                graphics.fillStyle(0x555555);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 12);

                // Gun housing - alloy colored
                graphics.fillStyle(0xb8967a);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                // Quad barrels - rotated toward target
                const salvoAngle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                const salvoX = px + TILE_SIZE/2;
                const salvoY = py + TILE_SIZE/2;
                const salvoBarrelLength = 13;

                graphics.lineStyle(2, 0x666666);
                for (let i = -1.5; i <= 1.5; i++) {
                    const spreadAngle = salvoAngle + i * 0.12;
                    const bx2 = salvoX + Math.cos(spreadAngle) * salvoBarrelLength;
                    const by2 = salvoY + Math.sin(spreadAngle) * salvoBarrelLength;
                    graphics.lineBetween(salvoX, salvoY, bx2, by2);
                }

                // Ammo indicator
                if (b.ammo !== undefined) {
                    const ammoPct = Math.min(1, b.ammo / 20);
                    graphics.fillStyle(ammoPct > 0.3 ? 0x44ff44 : 0xff4444);
                    graphics.fillRect(px + 3, py + TILE_SIZE - 5, (TILE_SIZE - 6) * ammoPct, 2);
                }

            } else if (b.type === 'explosive') {
                // Explosive bomb
                const pulseAlpha = Math.sin(Date.now() / 300) * 0.2 + 0.8;

                graphics.fillStyle(0x332211);
                graphics.fillRoundedRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8, 4);

                // Bomb body
                graphics.fillStyle(0x883311);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 10);

                // Warning stripes
                graphics.fillStyle(0xffcc00);
                graphics.fillRect(px + TILE_SIZE/2 - 6, py + TILE_SIZE/2 - 2, 12, 2);
                graphics.fillRect(px + TILE_SIZE/2 - 6, py + TILE_SIZE/2 + 2, 12, 2);

                // Fuse
                graphics.lineStyle(2, 0x666666);
                graphics.lineBetween(px + TILE_SIZE/2, py + 4, px + TILE_SIZE/2, py + 8);

                // Sparking fuse tip
                const spark = Math.random() > 0.5;
                if (spark) {
                    graphics.fillStyle(0xff6600, pulseAlpha);
                    graphics.fillCircle(px + TILE_SIZE/2, py + 4, 2);
                }

            } else if (b.type === 'repair') {
                // Repair station
                graphics.fillStyle(0x225522);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                graphics.fillStyle(0x338833);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 10);

                // Green cross
                graphics.fillStyle(0x44aa44);
                graphics.fillRect(px + TILE_SIZE/2 - 2, py + TILE_SIZE/2 - 8, 4, 16);
                graphics.fillRect(px + TILE_SIZE/2 - 8, py + TILE_SIZE/2 - 2, 16, 4);

                // Healing glow when enemies nearby
                if (enemies.length > 0) {
                    const healGlow = Math.sin(Date.now() / 200) * 0.2 + 0.3;
                    graphics.fillStyle(0x88ff88, healGlow);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 14);
                }
            }

            // Health bar for damaged buildings
            if (b.type !== 'core' && b.health < b.maxHealth) {
                const healthPct = b.health / b.maxHealth;
                graphics.fillStyle(0x333333);
                graphics.fillRect(px, py - 5, TILE_SIZE, 3);
                graphics.fillStyle(healthPct > 0.5 ? 0x44ff44 : (healthPct > 0.25 ? 0xffff00 : 0xff4444));
                graphics.fillRect(px, py - 5, TILE_SIZE * healthPct, 3);
            }
        }

        function drawArrow(x, y, rot, color) {
            const dir = getDirection(rot);
            const len = 8;
            graphics.lineStyle(2, color);
            graphics.lineBetween(x - dir.x * len, y - dir.y * len, x + dir.x * len, y + dir.y * len);

            const headLen = 5;
            const perpX = -dir.y;
            const perpY = dir.x;
            graphics.lineBetween(
                x + dir.x * len, y + dir.y * len,
                x + dir.x * (len - headLen) + perpX * headLen/2,
                y + dir.y * (len - headLen) + perpY * headLen/2
            );
            graphics.lineBetween(
                x + dir.x * len, y + dir.y * len,
                x + dir.x * (len - headLen) - perpX * headLen/2,
                y + dir.y * (len - headLen) - perpY * headLen/2
            );
        }

        function drawMinimap() {
            const minimap = document.getElementById('minimap');
            const ctx = minimap.getContext('2d');

            minimap.width = 150;
            minimap.height = 112;

            const scaleX = minimap.width / (MAP_WIDTH * TILE_SIZE);
            const scaleY = minimap.height / (MAP_HEIGHT * TILE_SIZE);

            // Draw terrain
            ctx.fillStyle = '#2a3a2a';
            ctx.fillRect(0, 0, minimap.width, minimap.height);

            // Draw buildings
            buildings.forEach(b => {
                if (b.type === 'core') {
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(b.x * TILE_SIZE * scaleX, b.y * TILE_SIZE * scaleY, TILE_SIZE * 2 * scaleX, TILE_SIZE * 2 * scaleY);
                } else {
                    ctx.fillStyle = b.type.includes('turret') || b.type === 'scatter' || b.type === 'laser' ? '#cc4444' :
                                   b.type.includes('wall') ? '#666666' :
                                   b.type === 'drill' || b.type === 'pneumatic-drill' ? '#8B4513' :
                                   '#555555';
                    ctx.fillRect(b.x * TILE_SIZE * scaleX, b.y * TILE_SIZE * scaleY, TILE_SIZE * scaleX, TILE_SIZE * scaleY);
                }
            });

            // Draw enemies
            ctx.fillStyle = '#ff4444';
            enemies.forEach(e => {
                if (e.delay <= 0) {
                    ctx.fillRect(e.x * scaleX - 1, e.y * scaleY - 1, 3, 3);
                }
            });

            // Draw player
            ctx.fillStyle = '#4488ff';
            ctx.fillRect(player.x * scaleX - 2, player.y * scaleY - 2, 5, 5);

            // Draw viewport rectangle
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(
                camera.x * scaleX,
                camera.y * scaleY,
                window.innerWidth * scaleX,
                window.innerHeight * scaleY
            );

            // Draw spawn point
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(spawnPoint.x * TILE_SIZE * scaleX + TILE_SIZE * scaleX / 2,
                   spawnPoint.y * TILE_SIZE * scaleY + TILE_SIZE * scaleY / 2, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // Initialize
        updateResourceUI();
        updatePlayerHealthUI();
    </script>
</body>
</html>
