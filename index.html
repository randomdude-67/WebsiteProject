<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindustry Clone</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        /* Top Resource Bar */
        #resource-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(180deg, rgba(22, 33, 62, 0.95) 0%, rgba(22, 33, 62, 0.8) 100%);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            z-index: 100;
            border-bottom: 2px solid #333;
        }

        .resource-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .resource-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .resource-count {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            min-width: 40px;
        }

        #wave-display {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #wave-display span {
            color: #ff6b6b;
            font-size: 14px;
        }

        #player-health-bar {
            width: 150px;
            height: 20px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #player-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.2s;
        }

        #player-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 11px;
            text-shadow: 1px 1px 2px black;
        }

        /* Bottom Build Bar */
        #build-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, rgba(22, 33, 62, 0.95) 0%, rgba(22, 33, 62, 0.8) 100%);
            z-index: 100;
            border-top: 2px solid #333;
        }

        #category-tabs {
            display: flex;
            gap: 5px;
            padding: 8px 15px;
            border-bottom: 1px solid #444;
        }

        .category-tab {
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 5px 5px 0 0;
            color: #aaa;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.2s;
        }

        .category-tab:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .category-tab.active {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }

        #building-grid {
            display: flex;
            gap: 8px;
            padding: 12px 15px;
            flex-wrap: wrap;
        }

        .build-btn {
            width: 60px;
            height: 60px;
            border: 2px solid #444;
            border-radius: 8px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: inherit;
        }

        .build-btn:hover {
            transform: scale(1.05);
            border-color: #666;
        }

        .build-btn.selected {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .build-btn:disabled,
        .build-btn.unaffordable {
            opacity: 0.5;
        }

        .build-btn:disabled {
            cursor: not-allowed;
        }

        .build-btn .icon {
            font-size: 24px;
        }

        .build-btn .name {
            font-size: 8px;
            color: #fff;
            margin-top: 2px;
        }

        .build-btn .hotkey {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 9px;
            color: #888;
        }

        .build-btn .cost {
            position: absolute;
            bottom: 2px;
            font-size: 8px;
            color: #aaa;
        }

        /* Minimap */
        #minimap {
            position: fixed;
            bottom: 130px;
            right: 10px;
            width: 180px;
            height: 135px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #444;
            border-radius: 5px;
            z-index: 90;
        }

        /* Tooltip - fixed in bottom right */
        .tooltip {
            position: fixed;
            bottom: 130px;
            right: 170px;
            background: linear-gradient(135deg, rgba(22, 33, 62, 0.98), rgba(30, 45, 75, 0.98));
            color: white;
            padding: 14px 18px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            min-width: 240px;
            max-width: 320px;
            border: 2px solid #4CAF50;
            box-shadow: 0 6px 16px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.1);
            display: none;
        }

        .tooltip-title {
            font-weight: bold;
            font-size: 15px;
            color: #4CAF50;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(76, 175, 80, 0.3);
            padding-bottom: 6px;
            text-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

        .tooltip-stat {
            margin: 6px 0;
            color: #ddd;
            line-height: 1.5;
        }

        .tooltip-stat-label {
            color: #4CAF50;
            font-weight: 600;
            margin-right: 6px;
        }

        /* FPS counter */
        #fps-counter {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 4px;
            color: #4CAF50;
            font-size: 12px;
            font-weight: bold;
            z-index: 100;
        }

        #fps-counter.low {
            color: #ff6b6b;
        }

        #fps-counter.medium {
            color: #ffaa00;
        }

        #version-display {
            position: fixed;
            bottom: 130px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 3px;
            color: #888;
            font-size: 10px;
            z-index: 90;
        }

        #factory-indicator {
            position: fixed;
            pointer-events: none;
            z-index: 95;
        }

        /* Info panel */
        #info-panel {
            position: fixed;
            top: 60px;
            left: 10px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px;
            border-radius: 5px;
            color: #aaa;
            font-size: 10px;
            z-index: 90;
            max-width: 180px;
            transition: all 0.3s ease;
        }

        #info-panel.collapsed {
            width: 80px;
            height: 30px;
            overflow: hidden;
            padding: 5px 10px;
        }

        #info-panel.collapsed .panel-content {
            display: none;
        }

        #panel-toggle {
            cursor: pointer;
            color: #4CAF50;
            font-weight: bold;
            user-select: none;
            display: inline-block;
            margin-bottom: 5px;
        }

        #panel-toggle:hover {
            color: #66dd66;
        }

        #info-panel b {
            color: #4CAF50;
        }

        #game {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #game canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Top Resource Bar -->
    <div id="resource-bar">
        <div class="resource-item">
            <div class="resource-icon" style="background: #d4a574;"></div>
            <span class="resource-count" id="copper-count">20</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #7799aa;"></div>
            <span class="resource-count" id="lead-count">20</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #444;"></div>
            <span class="resource-count" id="coal-count">0</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #4a7c9b;"></div>
            <span class="resource-count" id="titanium-count">0</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #2a2a2a;"></div>
            <span class="resource-count" id="graphite-count">0</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: linear-gradient(135deg, #d4a574, #7799aa);"></div>
            <span class="resource-count" id="alloy-count">0</span>
        </div>
        <div class="resource-item">
            <div class="resource-icon" style="background: #c9b592;"></div>
            <span class="resource-count" id="sand-count">0</span>
        </div>

        <div id="wave-display">
            <span>Wave: <b id="wave-num">0</b></span>
            <span>Enemies: <b id="enemy-count">0</b></span>
            <span>Next: <b id="next-wave">60s</b></span>
            <div id="player-health-bar">
                <div id="player-health-fill" style="width: 100%"></div>
                <span id="player-health-text">Ship: 100%</span>
            </div>
            <button id="debug-btn" style="margin-left: 10px; padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">âˆž Resources</button>
        </div>
    </div>

    <!-- Bottom Build Bar -->
    <div id="build-bar">
        <div id="category-tabs">
            <button class="category-tab active" data-category="production">Production</button>
            <button class="category-tab" data-category="transport">Transport</button>
            <button class="category-tab" data-category="units">Units</button>
            <button class="category-tab" data-category="power">Power</button>
            <button class="category-tab" data-category="defense">Defense</button>
            <button class="category-tab" data-category="tools">Tools</button>
        </div>
        <div id="building-grid"></div>
    </div>

    <!-- Minimap -->
    <canvas id="minimap"></canvas>

    <!-- Info Panel -->
    <div id="info-panel">
        <div id="panel-toggle" onclick="document.getElementById('info-panel').classList.toggle('collapsed')">
            ðŸ“– Tutorial
        </div>
        <div class="panel-content">
            <b>Controls:</b><br>
            WASD - Move ship<br>
            Click - Place/Mine<br>
            Middle-click - Pick building<br>
            Drag - Place multiple<br>
            Right-click - Delete<br>
            R/Scroll - Rotate<br>
            Space - Start wave<br>
            <br>
            <b>Tips:</b><br>
            Click with no building selected to mine copper/lead<br>
            Drills mine ore deposits<br>
            Conveyors transport to core<br>
            Duo uses copper, Scatter uses lead<br>
            Feed ammo via conveyors!<br>
            Arc turrets need power
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>
    <div id="fps-counter">FPS: 60</div>
    <div id="version-display">v0.4.0-alpha</div>
    <canvas id="factory-indicator" width="100" height="100"></canvas>

    <div id="game"></div>

    <script>
        // Game Constants
        const TILE_SIZE = 32;
        const MAP_WIDTH = 200;  // Expanded from 100
        const MAP_HEIGHT = 150; // Expanded from 75

        // Player ship
        let player = {
            x: MAP_WIDTH * TILE_SIZE / 2,
            y: MAP_HEIGHT * TILE_SIZE / 2,
            health: 100,
            maxHealth: 100,
            speed: 5,
            angle: 0,
            respawnTimer: 0,
            invulnerable: 0,
            deaths: 0,
            // Shooting properties (nerfed for balance)
            fireCooldown: 0,
            fireCooldownMax: 350, // ms between shots (slower fire rate)
            bulletSpeed: 10,
            bulletDamage: 8 // reduced damage
        };

        // Player bullets (separate from turret bullets)
        let playerBullets = [];

        // Camera
        let camera = { x: 0, y: 0 };
        let zoom = 1.0;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 2.0;

        // Resources
        let resources = {
            copper: 20,
            lead: 20,
            coal: 0,
            titanium: 0,
            graphite: 0,
            alloy: 0,
            sand: 0
        };

        // Terrain types
        const TERRAIN = {
            GRASS: 0,
            SAND: 1,
            WATER: 2,
            STONE: 3,
            DARK_STONE: 4
        };

        // Building definitions with categories
        const BUILDINGS = {
            drill: {
                category: 'production', cost: { copper: 12 }, health: 40,
                icon: 'â›', name: 'Drill', hotkey: '1',
                desc: 'Mines ore deposits', mineSpeed: 1,
                width: 2, height: 2, buildTime: 500
            },
            'pneumatic-drill': {
                category: 'production', cost: { copper: 45, graphite: 15 }, health: 50,
                icon: 'âš™', name: 'P-Drill', hotkey: '2',
                desc: 'Fast mining 2x speed', mineSpeed: 2,
                width: 2, height: 2, buildTime: 500
            },
            'alloy-drill': {
                category: 'production', cost: { alloy: 45, titanium: 30 }, health: 80,
                icon: 'ðŸ”©', name: 'A-Drill', hotkey: null,
                desc: 'Alloy drill 4x speed', mineSpeed: 4,
                width: 2, height: 2, buildTime: 1000
            },
            'graphite-press': {
                category: 'production', cost: { copper: 60, lead: 40 }, health: 60,
                icon: 'â¬›', name: 'Graphite Press', hotkey: null,
                desc: 'Compresses 2 coal into 1 graphite', craftTime: 2000,
                width: 2, height: 2, buildTime: 1500
            },
            'alloy-factory': {
                category: 'production', cost: { copper: 90, lead: 90 }, health: 60,
                icon: 'ðŸ­', name: 'Alloy Factory', hotkey: null,
                desc: 'Combines lead+titanium into alloy (needs power)', craftTime: 3000, powerUse: 5,
                width: 2, height: 2, buildTime: 2000
            },
            'miner-constructor': {
                category: 'units', cost: { lead: 120, titanium: 120 }, health: 100,
                icon: 'ðŸ—ï¸', name: 'Miner Constructor', hotkey: null,
                desc: 'Builds mining drones (50 lead+titanium, 30s)', craftTime: 30000,
                width: 2, height: 2, buildTime: 3000
            },
            conveyor: {
                category: 'transport', cost: { copper: 1 }, health: 20,
                icon: 'âž¡', name: 'Conveyor', hotkey: '3',
                desc: 'Moves items in one direction', buildTime: 200
            },
            'alloy-conveyor': {
                category: 'transport', cost: { alloy: 3 }, health: 40,
                icon: 'â‡’', name: 'A-Conveyor', hotkey: null,
                desc: 'Fast alloy conveyor 2x speed', speedMult: 2, buildTime: 300
            },
            router: {
                category: 'transport', cost: { copper: 15 }, health: 30,
                icon: 'âœš', name: 'Router', hotkey: '4',
                desc: 'Splits items 3 ways', buildTime: 300
            },
            junction: {
                category: 'transport', cost: { copper: 9, lead: 9 }, health: 25,
                icon: 'â•‹', name: 'Junction', hotkey: '5',
                desc: 'Items pass through', buildTime: 300
            },
            'payload-conveyor': {
                category: 'units', cost: { titanium: 15, alloy: 10 }, health: 35,
                icon: 'âŠž', name: 'Payload Conv', hotkey: null,
                desc: 'Transports miner drones', buildTime: 500,
                width: 2, height: 2
            },
            generator: {
                category: 'power', cost: { copper: 60, lead: 30 }, health: 60,
                icon: 'ðŸ”¥', name: 'Generator', hotkey: '6',
                desc: 'Burns coal for power', powerOutput: 10, coalConsume: 0.1, buildTime: 1000
            },
            'thermal-generator': {
                category: 'power', cost: { graphite: 80, lead: 120, titanium: 50 }, health: 100,
                icon: 'âš¡', name: 'Thermal Gen', hotkey: null,
                desc: 'Burns coal+lead for 30 power', powerOutput: 30, coalConsume: 0.15, leadConsume: 0.1,
                width: 2, height: 2, buildTime: 2000
            },
            'power-node': {
                category: 'power', cost: { copper: 15, lead: 15 }, health: 30,
                icon: 'âš¡', name: 'P-Node', hotkey: '7',
                desc: 'Distributes power', powerRange: 6, buildTime: 500
            },
            'large-power-node': {
                category: 'power', cost: { copper: 60, lead: 60, titanium: 30 }, health: 80,
                icon: 'âš¡', name: 'L-P-Node', hotkey: null,
                desc: 'Large power node 2x2, extended range', powerRange: 12, buildTime: 1500,
                width: 2, height: 2
            },
            turret: {
                category: 'defense', cost: { copper: 60 }, health: 50,
                icon: 'ðŸ”«', name: 'Duo', hotkey: '8',
                desc: 'Rapid fire turret (uses copper)', damage: 8, range: 6, cooldown: 400, ammoType: 'copper', ammoUse: 1, buildTime: 3000
            },
            scatter: {
                category: 'defense', cost: { copper: 90, lead: 60 }, health: 60,
                icon: 'ðŸ’¥', name: 'Scatter', hotkey: '9',
                desc: 'Fires 3 shot spread (uses lead)', damage: 4, range: 10, cooldown: 150, shots: 3, ammoType: 'lead', ammoUse: 2, buildTime: 4000
            },
            laser: {
                category: 'defense', cost: { copper: 120, lead: 90 }, health: 45,
                icon: 'âš¡', name: 'Arc', hotkey: '0',
                desc: 'Electric arc (needs power)', damage: 15, range: 8, cooldown: 800, powerUse: 2, buildTime: 3000
            },
            stormer: {
                category: 'defense', cost: { titanium: 70, copper: 50, lead: 40 }, health: 70,
                icon: 'ðŸŒª', name: 'Stormer', hotkey: null,
                desc: 'Blasts sand like flamethrower, slows enemies', damage: 2, range: 5, cooldown: 100, ammoType: 'sand', ammoUse: 1, slowEffect: 0.5, buildTime: 4000
            },
            wall: {
                category: 'defense', cost: { copper: 6 }, health: 80,
                icon: 'â–ª', name: 'Wall', hotkey: 'Q',
                desc: 'Basic defense', buildTime: 300
            },
            'titanium-wall': {
                category: 'defense', cost: { titanium: 15 }, health: 200,
                icon: 'â–£', name: 'Ti-Wall', hotkey: 'E',
                desc: 'Strong titanium wall', buildTime: 500
            },
            'alloy-wall': {
                category: 'defense', cost: { alloy: 24 }, health: 650,
                icon: 'â–¦', name: 'A-Wall', hotkey: null,
                desc: 'Reinforced alloy wall', buildTime: 1000
            },
            'alloy-turret': {
                category: 'defense', cost: { alloy: 75, titanium: 45 }, health: 100,
                icon: 'ðŸŽ¯', name: 'Salvo', hotkey: null,
                desc: 'Rapid alloy turret (uses alloy)', damage: 12, range: 8, cooldown: 250, ammoType: 'alloy', ammoUse: 1, buildTime: 5000
            },
            explosive: {
                category: 'defense', cost: { copper: 45, coal: 30 }, health: 30,
                icon: 'ðŸ’£', name: 'Bomb', hotkey: 'B',
                desc: 'Explodes when destroyed!', explosionDamage: 80, explosionRange: 3, buildTime: 1000
            },
            repair: {
                category: 'defense', cost: { copper: 75, lead: 45 }, health: 40,
                icon: 'ðŸ”§', name: 'Repair', hotkey: 'F',
                desc: 'Repairs nearby buildings (needs power)', repairRange: 5, powerUse: 1, buildTime: 2000
            },
            delete: {
                category: 'tools', cost: {}, health: 0,
                icon: 'ðŸ—‘', name: 'Delete', hotkey: 'X',
                desc: 'Remove buildings'
            }
        };

        // Game state
        let selectedBuilding = null;
        let miningMode = false;
        let currentCategory = 'production';
        let rotation = 0;
        let miningCooldown = 0;
        let miningTarget = null; // Store current mining target for laser rendering
        let tooltipCollapsed = false; // Track tooltip collapse state
        let buildings = [];
        let constructionQueue = []; // Buildings currently being built
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let items = [];
        let particles = [];
        let miners = []; // Mining drones
        let wave = 0;
        let waveTimer = 240; // Start with 240 seconds (4 minutes - first wave)
        let coreHealth = 500;
        let maxCoreHealth = 500;
        let gameOver = false;
        let isDragging = false;
        let lastDragTile = null;

        // Map data
        let map = [];
        let oreMap = [];
        let terrainMap = [];

        // Spawn point
        let spawnPoint = { x: 5, y: 5 };

        // Power system
        let powerGrid = { production: 0, consumption: 0 };

        // Phaser Config - Use AUTO to fallback to Canvas if WebGL unavailable
        const config = {
            type: Phaser.AUTO,  // AUTO allows fallback to Canvas if WebGL fails
            width: window.innerWidth,
            height: window.innerHeight,
            parent: 'game',
            backgroundColor: '#1a1a2e',
            scale: {
                mode: Phaser.Scale.RESIZE,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            render: {
                antialias: false,        // Disable for performance
                pixelArt: true,          // Optimized for pixel graphics
                roundPixels: true,       // Snap to pixels for crisp rendering
                transparent: false,
                powerPreference: 'high-performance',  // Request high-perf GPU
                batchSize: 4096          // Increased batch size for fewer draw calls
            },
            fps: {
                target: 60,
                forceSetTimeOut: false   // Use RAF for smoother frames
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        // Handle window resize
        window.addEventListener('resize', () => {
            game.scale.resize(window.innerWidth, window.innerHeight);
        });

        // Performance monitoring
        let lastFPS = 60;
        let frameCount = 0;
        let lastFPSUpdate = 0;

        let graphics, scene;
        let keys = {};

        // Terrain texture cache for GPU optimization
        let terrainCache = null;
        let terrainCacheDirty = true;

        // Object pooling for performance
        const bulletPool = [];
        const particlePool = [];
        const POOL_SIZE = 200;

        // Pre-allocate pool objects
        for (let i = 0; i < POOL_SIZE; i++) {
            bulletPool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, damage: 0, life: 0 });
            particlePool.push({ active: false, x: 0, y: 0, vx: 0, vy: 0, life: 0, color: 0, size: 0 });
        }

        // Spatial hash grid for fast collision lookups
        const GRID_CELL_SIZE = TILE_SIZE * 4; // 4 tiles per cell
        let spatialGrid = {};

        function getSpatialKey(x, y) {
            const gx = Math.floor(x / GRID_CELL_SIZE);
            const gy = Math.floor(y / GRID_CELL_SIZE);
            return `${gx},${gy}`;
        }

        function updateSpatialGrid() {
            spatialGrid = {};

            // Add enemies to grid
            enemies.forEach((e, idx) => {
                if (e.delay > 0) return;
                const key = getSpatialKey(e.x, e.y);
                if (!spatialGrid[key]) spatialGrid[key] = { enemies: [], buildings: [] };
                spatialGrid[key].enemies.push(idx);
            });

            // Add buildings to grid
            buildings.forEach((b, idx) => {
                const w = b.width || 1;
                const h = b.height || 1;
                const cx = (b.x + w / 2) * TILE_SIZE;
                const cy = (b.y + h / 2) * TILE_SIZE;
                const key = getSpatialKey(cx, cy);
                if (!spatialGrid[key]) spatialGrid[key] = { enemies: [], buildings: [] };
                spatialGrid[key].buildings.push(idx);
            });
        }

        function getNearbyEnemies(x, y, radius) {
            const results = [];
            const cellRadius = Math.ceil(radius / GRID_CELL_SIZE);
            const gx = Math.floor(x / GRID_CELL_SIZE);
            const gy = Math.floor(y / GRID_CELL_SIZE);

            for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                    const key = `${gx + dx},${gy + dy}`;
                    const cell = spatialGrid[key];
                    if (cell && cell.enemies) {
                        cell.enemies.forEach(idx => {
                            const e = enemies[idx];
                            if (e && e.delay <= 0) {
                                const dist = Math.sqrt((e.x - x) ** 2 + (e.y - y) ** 2);
                                if (dist <= radius) results.push(e);
                            }
                        });
                    }
                }
            }
            return results;
        }

        function preload() {}

        function create() {
            scene = this;
            graphics = this.add.graphics();

            // Generate terrain and map
            generateTerrain();
            generateMap();

            // Place core in center
            const coreX = Math.floor(MAP_WIDTH / 2);
            const coreY = Math.floor(MAP_HEIGHT / 2);
            placeCore(coreX, coreY);

            // Set spawn point in corner
            spawnPoint = { x: 3, y: 3 };

            // Center camera on player initially (center of 3x3 core)
            player.x = (coreX + 1.5) * TILE_SIZE;
            player.y = (coreY + 1.5) * TILE_SIZE;

            // Input handling
            this.input.on('pointerdown', handlePointerDown);
            this.input.on('pointermove', handlePointerMove);
            this.input.on('pointerup', handlePointerUp);

            // Disable context menu
            this.game.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            // Add mouse wheel rotation and zoom
            this.game.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.ctrlKey || e.metaKey) {
                    // Zoom with Ctrl+scroll
                    const zoomSpeed = 0.1;
                    if (e.deltaY < 0) {
                        zoom = Math.min(MAX_ZOOM, zoom + zoomSpeed);
                    } else if (e.deltaY > 0) {
                        zoom = Math.max(MIN_ZOOM, zoom - zoomSpeed);
                    }
                } else {
                    // Rotate building with scroll
                    if (e.deltaY < 0) {
                        rotation = (rotation + 1) % 4; // Scroll up = rotate clockwise
                    } else if (e.deltaY > 0) {
                        rotation = (rotation + 3) % 4; // Scroll down = rotate counter-clockwise
                    }
                }
            });

            // Keyboard
            keys = {
                W: this.input.keyboard.addKey('W'),
                A: this.input.keyboard.addKey('A'),
                S: this.input.keyboard.addKey('S'),
                D: this.input.keyboard.addKey('D'),
                R: this.input.keyboard.addKey('R'),
                SPACE: this.input.keyboard.addKey('SPACE')
            };

            this.input.keyboard.on('keydown-R', () => { rotation = (rotation + 1) % 4; });
            this.input.keyboard.on('keydown-SPACE', startWaveEarly);

            // Zoom hotkeys
            this.input.keyboard.on('keydown-PLUS', () => { zoom = Math.min(MAX_ZOOM, zoom + 0.1); });
            this.input.keyboard.on('keydown-MINUS', () => { zoom = Math.max(MIN_ZOOM, zoom - 0.1); });
            this.input.keyboard.on('keydown-EQUAL', () => { zoom = Math.min(MAX_ZOOM, zoom + 0.1); }); // = key (same as +)
            this.input.keyboard.on('keydown-OPEN_BRACKET', () => { zoom = Math.max(MIN_ZOOM, zoom - 0.1); }); // [ key alternate
            this.input.keyboard.on('keydown-CLOSED_BRACKET', () => { zoom = Math.min(MAX_ZOOM, zoom + 0.1); }); // ] key alternate

            // Building hotkeys
            Object.entries(BUILDINGS).forEach(([type, data]) => {
                if (data.hotkey) {
                    const keyCode = data.hotkey === '0' ? 'ZERO' :
                                   data.hotkey === '1' ? 'ONE' :
                                   data.hotkey === '2' ? 'TWO' :
                                   data.hotkey === '3' ? 'THREE' :
                                   data.hotkey === '4' ? 'FOUR' :
                                   data.hotkey === '5' ? 'FIVE' :
                                   data.hotkey === '6' ? 'SIX' :
                                   data.hotkey === '7' ? 'SEVEN' :
                                   data.hotkey === '8' ? 'EIGHT' :
                                   data.hotkey === '9' ? 'NINE' : data.hotkey;
                    this.input.keyboard.on('keydown-' + keyCode, () => selectBuilding(type));
                }
            });

            // Setup UI
            setupBuildUI();
            setupCategoryTabs();

            // Timers
            this.time.addEvent({ delay: 1000, callback: updateWaveTimer, loop: true });
            this.time.addEvent({ delay: 1500, callback: produceTick, loop: true });
            // Items now updated smoothly in main update loop
            this.time.addEvent({ delay: 1000, callback: repairTick, loop: true });
            this.time.addEvent({ delay: 500, callback: powerTick, loop: true });
            
            // Debug button handler
            document.getElementById('debug-btn').addEventListener('click', () => {
                // Give infinite resources (large amount)
                resources.copper = 999999;
                resources.lead = 999999;
                resources.coal = 999999;
                resources.titanium = 999999;
                resources.graphite = 999999;
                resources.alloy = 999999;
                resources.sand = 999999;
                updateResourceUI();
            });
        }

        function generateTerrain() {
            // Add randomness seed for variation
            const seed = Math.random() * 1000;

            for (let y = 0; y < MAP_HEIGHT; y++) {
                terrainMap[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    // Multiple noise layers for more organic terrain
                    const noise1 = Math.sin(x * 0.15 + seed) * Math.cos(y * 0.15 + seed);
                    const noise2 = Math.sin(x * 0.08 + seed * 2) * Math.cos(y * 0.12 + seed * 2) * 0.5;
                    const noise3 = Math.sin(x * 0.25 + seed * 3) * Math.cos(y * 0.2 + seed * 3) * 0.3;
                    const noise4 = Math.sin(x * 0.4 + seed * 4) * Math.cos(y * 0.35 + seed * 4) * 0.2;

                    const noise = noise1 + noise2 + noise3 + noise4;

                    // Add random variation
                    const randomFactor = (Math.random() - 0.5) * 0.3;
                    const finalNoise = noise + randomFactor;

                    // Water near edges
                    const edgeDist = Math.min(x, y, MAP_WIDTH - x - 1, MAP_HEIGHT - y - 1);

                    if (edgeDist < 3 && Math.random() < 0.4) {
                        terrainMap[y][x] = TERRAIN.WATER;
                    } else if (finalNoise > 0.7) {
                        terrainMap[y][x] = TERRAIN.STONE;
                    } else if (finalNoise > 0.45) {
                        terrainMap[y][x] = TERRAIN.DARK_STONE;
                    } else if (finalNoise < -0.4) {
                        terrainMap[y][x] = TERRAIN.SAND;
                    } else if (finalNoise < -0.2 && Math.random() < 0.3) {
                        terrainMap[y][x] = TERRAIN.SAND;
                    } else {
                        terrainMap[y][x] = TERRAIN.GRASS;
                    }
                }
            }

            // Generate flowing small ponds
            generatePonds(seed);

            // Clear center area for core (larger for 3x3 core)
            const cx = Math.floor(MAP_WIDTH / 2);
            const cy = Math.floor(MAP_HEIGHT / 2);
            for (let dy = -4; dy <= 5; dy++) {
                for (let dx = -4; dx <= 5; dx++) {
                    if (cy + dy >= 0 && cy + dy < MAP_HEIGHT && cx + dx >= 0 && cx + dx < MAP_WIDTH) {
                        terrainMap[cy + dy][cx + dx] = TERRAIN.DARK_STONE;
                    }
                }
            }
        }

        function generatePonds(seed) {
            // Generate 4-8 small flowing ponds scattered around the map
            // More ponds for larger map
            const pondCount = 12 + Math.floor(Math.random() * 10);
            const cx = Math.floor(MAP_WIDTH / 2);
            const cy = Math.floor(MAP_HEIGHT / 2);

            for (let p = 0; p < pondCount; p++) {
                // Start position - avoid center area where core is placed
                let startX, startY;
                let attempts = 0;
                do {
                    startX = 8 + Math.floor(Math.random() * (MAP_WIDTH - 16));
                    startY = 8 + Math.floor(Math.random() * (MAP_HEIGHT - 16));
                    attempts++;
                } while (Math.abs(startX - cx) < 8 && Math.abs(startY - cy) < 8 && attempts < 20);

                if (attempts >= 20) continue;

                // Create a flowing pond using a random walk with organic shapes
                const pondLength = 8 + Math.floor(Math.random() * 12); // 8-20 tiles long
                const pondWidth = 2 + Math.floor(Math.random() * 2); // 2-3 tiles wide

                let curX = startX;
                let curY = startY;

                // Random flow direction with slight bias
                let flowAngle = Math.random() * Math.PI * 2;

                for (let i = 0; i < pondLength; i++) {
                    // Place water in an organic blob around current position
                    for (let dy = -pondWidth; dy <= pondWidth; dy++) {
                        for (let dx = -pondWidth; dx <= pondWidth; dx++) {
                            const px = Math.floor(curX + dx);
                            const py = Math.floor(curY + dy);

                            // Skip if out of bounds or too close to edges
                            if (px < 5 || px >= MAP_WIDTH - 5 || py < 5 || py >= MAP_HEIGHT - 5) continue;

                            // Skip if too close to center (core area)
                            if (Math.abs(px - cx) < 6 && Math.abs(py - cy) < 6) continue;

                            // Organic shape - use distance and noise for natural edges
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const noiseVal = Math.sin(px * 0.5 + seed + p) * Math.cos(py * 0.5 + seed + p);
                            const threshold = pondWidth * (0.7 + noiseVal * 0.3);

                            if (dist <= threshold) {
                                terrainMap[py][px] = TERRAIN.WATER;
                            } else if (dist <= threshold + 1 && Math.random() < 0.5) {
                                // Sand around pond edges
                                if (terrainMap[py][px] !== TERRAIN.WATER) {
                                    terrainMap[py][px] = TERRAIN.SAND;
                                }
                            }
                        }
                    }

                    // Move along flow direction with some randomness
                    flowAngle += (Math.random() - 0.5) * 0.8; // Gentle turns
                    curX += Math.cos(flowAngle) * 1.5;
                    curY += Math.sin(flowAngle) * 1.5;

                    // Occasionally widen or narrow
                    if (Math.random() < 0.2) {
                        // Small variation handled by noise in the loop above
                    }
                }
            }
        }

        function generateMap() {
            for (let y = 0; y < MAP_HEIGHT; y++) {
                map[y] = [];
                oreMap[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    map[y][x] = 0;
                    oreMap[y][x] = null;
                }
            }

            // Generate ore clusters (increased counts and sizes for better visibility)
            // Scaled ore counts for larger map (4x area = ~3x ore deposits)
            const oreTypes = [
                { type: 'copper', count: 50, size: 16 },
                { type: 'lead', count: 40, size: 14 },
                { type: 'coal', count: 30, size: 12 },
                { type: 'titanium', count: 18, size: 10 }
            ];

            oreTypes.forEach(ore => {
                for (let i = 0; i < ore.count; i++) {
                    const cx = Math.floor(Math.random() * (MAP_WIDTH - 8)) + 4;
                    const cy = Math.floor(Math.random() * (MAP_HEIGHT - 8)) + 4;

                    for (let j = 0; j < ore.size; j++) {
                        const ox = cx + Math.floor(Math.random() * 5) - 2;
                        const oy = cy + Math.floor(Math.random() * 4) - 2;
                        if (ox >= 0 && ox < MAP_WIDTH && oy >= 0 && oy < MAP_HEIGHT) {
                            if (terrainMap[oy][ox] !== TERRAIN.WATER) {
                                oreMap[oy][ox] = ore.type;
                            }
                        }
                    }
                }
            });
        }

        function placeCore(x, y) {
            for (let dy = 0; dy < 3; dy++) {
                for (let dx = 0; dx < 3; dx++) {
                    map[y + dy][x + dx] = 'core';
                    oreMap[y + dy][x + dx] = null;
                }
            }
            buildings.push({
                type: 'core',
                x: x, y: y,
                width: 3, height: 3,
                health: maxCoreHealth,
                maxHealth: maxCoreHealth
            });
        }

        function setupCategoryTabs() {
            document.querySelectorAll('.category-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    currentCategory = tab.dataset.category;
                    renderBuildingGrid();
                });
            });
        }

        function setupBuildUI() {
            renderBuildingGrid();
        }

        function renderBuildingGrid() {
            const grid = document.getElementById('building-grid');
            grid.innerHTML = '';

            Object.entries(BUILDINGS).forEach(([type, data]) => {
                if (data.category !== currentCategory) return;

                const btn = document.createElement('button');
                btn.className = 'build-btn';
                btn.dataset.type = type;
                btn.style.background = getBuildingColor(type);

                btn.innerHTML = `
                    <span class="hotkey">${data.hotkey}</span>
                    <span class="icon">${data.icon}</span>
                    <span class="name">${data.name}</span>
                    <span class="cost">${getCostString(data.cost)}</span>
                `;

                btn.onclick = () => selectBuilding(type);

                if (selectedBuilding === type) {
                    btn.classList.add('selected');
                }

                if (!canAfford(type)) {
                    btn.classList.add('unaffordable');
                    // Don't use disabled attribute - just style it differently
                }

                // Add tooltip on hover
                btn.addEventListener('mouseenter', (e) => {
                    showBuildButtonTooltip(type, data);
                });

                btn.addEventListener('mouseleave', () => {
                    hideBuildButtonTooltip();
                });

                grid.appendChild(btn);
            });
        }

        function showBuildButtonTooltip(type, data) {
            const tooltip = document.querySelector('.tooltip');
            let html = `<div class="tooltip-title">${data.name}</div>`;
            html += `<div class="tooltip-stat">${data.desc}</div>`;
            
            // Show cost with color coding
            if (data.cost && Object.keys(data.cost).length > 0) {
                let costHtml = '<div class="tooltip-stat"><span class="tooltip-stat-label">Cost:</span> ';
                costHtml += Object.entries(data.cost).map(([res, amt]) => {
                    const hasEnough = (resources[res] || 0) >= amt;
                    const current = resources[res] || 0;
                    return `<span style="color:${hasEnough ? getOreColorCSS(res) : '#ff4444'}">${amt} ${res} (${current})</span>`;
                }).join(', ');
                html += costHtml + '</div>';
            }
            
            html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Health:</span> ${data.health}</div>`;
            if (data.damage) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Damage:</span> ${data.damage}</div>`;
            if (data.range) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Range:</span> ${data.range} tiles</div>`;
            if (data.cooldown) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Fire rate:</span> ${(1000/data.cooldown).toFixed(1)}/s</div>`;
            if (data.ammoType) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo type:</span> <span style="color:${getOreColorCSS(data.ammoType)}">${data.ammoType}</span></div>`;
            if (data.ammoUse) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo/shot:</span> ${data.ammoUse}</div>`;
            if (data.powerUse) {
                html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power use:</span> ${data.powerUse}</div>`;
                const surplus = powerGrid.production - powerGrid.consumption;
                const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
            }
            if (data.powerOutput) {
                html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power output:</span> ${data.powerOutput}</div>`;
                const surplus = powerGrid.production - powerGrid.consumption;
                const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
            }
            if (data.powerRange) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power range:</span> ${data.powerRange} tiles</div>`;
            if (data.mineSpeed) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Mine speed:</span> ${data.mineSpeed}x</div>`;
            if (data.repairRange) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Repair range:</span> ${data.repairRange} tiles</div>`;
            if (data.craftTime) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Craft time:</span> ${(data.craftTime/1000).toFixed(1)}s</div>`;
            if (data.slowEffect) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Slow effect:</span> ${(data.slowEffect * 100).toFixed(0)}%</div>`;
            
            tooltip.innerHTML = html;
            tooltip.style.display = 'block';
        }

        function hideBuildButtonTooltip() {
            const tooltip = document.querySelector('.tooltip');
            tooltip.style.display = 'none';
        }

        function getBuildingColor(type) {
            const colors = {
                drill: 'linear-gradient(135deg, #8B4513, #654321)',
                'pneumatic-drill': 'linear-gradient(135deg, #B87333, #8B5A2B)',
                'alloy-drill': 'linear-gradient(135deg, #b8967a, #8a6a5a)',
                'graphite-press': 'linear-gradient(135deg, #333333, #1a1a1a)',
                'alloy-factory': 'linear-gradient(135deg, #887766, #665544)',
                'miner-constructor': 'linear-gradient(135deg, #44aa44, #227722)',
                conveyor: 'linear-gradient(135deg, #555, #333)',
                'alloy-conveyor': 'linear-gradient(135deg, #b8967a, #8a6a5a)',
                'payload-conveyor': 'linear-gradient(135deg, #4a7c9b, #2a5c7b)',
                router: 'linear-gradient(135deg, #666699, #444477)',
                junction: 'linear-gradient(135deg, #996666, #774444)',
                generator: 'linear-gradient(135deg, #ff8800, #cc5500)',
                'thermal-generator': 'linear-gradient(135deg, #ff4400, #aa2200)',
                'power-node': 'linear-gradient(135deg, #ffcc00, #cc9900)',
                'large-power-node': 'linear-gradient(135deg, #ffdd44, #ddaa00)',
                turret: 'linear-gradient(135deg, #cc3333, #991111)',
                scatter: 'linear-gradient(135deg, #cc6633, #994411)',
                'alloy-turret': 'linear-gradient(135deg, #b8967a, #cc5555)',
                laser: 'linear-gradient(135deg, #3366cc, #224499)',
                stormer: 'linear-gradient(135deg, #c9b592, #a89572)',
                wall: 'linear-gradient(135deg, #555, #333)',
                'titanium-wall': 'linear-gradient(135deg, #4a7c9b, #2a5c7b)',
                'alloy-wall': 'linear-gradient(135deg, #b8967a, #8a6a5a)',
                explosive: 'linear-gradient(135deg, #ff6600, #cc3300)',
                repair: 'linear-gradient(135deg, #339933, #227722)',
                delete: 'linear-gradient(135deg, #ff4444, #cc2222)'
            };
            return colors[type] || '#444';
        }

        function getCostString(cost) {
            if (!cost || Object.keys(cost).length === 0) return '';
            return Object.entries(cost).map(([res, amt]) => {
                const abbrev = { copper: 'Cu', lead: 'Pb', coal: 'C', titanium: 'Ti', graphite: 'Gr', alloy: 'Al', sand: 'Sd' };
                return amt + abbrev[res];
            }).join(' ');
        }

        function selectBuilding(type) {
            selectedBuilding = type;
            miningMode = false; // Turn off mining mode when selecting a building
            renderBuildingGrid();

            // Switch to correct category
            if (type && BUILDINGS[type]) {
                const cat = BUILDINGS[type].category;
                if (cat !== currentCategory) {
                    currentCategory = cat;
                    document.querySelectorAll('.category-tab').forEach(t => {
                        t.classList.toggle('active', t.dataset.category === cat);
                    });
                    renderBuildingGrid();
                }
            }
        }

        function canAfford(type) {
            const data = BUILDINGS[type];
            if (!data || !data.cost) return true;
            for (let res in data.cost) {
                if ((resources[res] || 0) < data.cost[res]) return false;
            }
            return true;
        }

        function spend(type) {
            const data = BUILDINGS[type];
            if (!data || !data.cost) return;
            for (let res in data.cost) {
                resources[res] -= data.cost[res];
            }
            updateResourceUI();
        }

        function screenToWorld(screenX, screenY) {
            return {
                x: screenX / zoom + camera.x,
                y: screenY / zoom + camera.y
            };
        }

        function worldToTile(worldX, worldY) {
            return {
                x: Math.floor(worldX / TILE_SIZE),
                y: Math.floor(worldY / TILE_SIZE)
            };
        }

        function handlePointerDown(pointer) {
            if (gameOver) return;

            const world = screenToWorld(pointer.x, pointer.y);
            const tile = worldToTile(world.x, world.y);

            // Middle click - pick building type
            if (pointer.middleButtonDown()) {
                const building = buildings.find(b => {
                    if (b.type === 'core') return false; // Can't pick core
                    const w = b.width || 1;
                    const h = b.height || 1;
                    return tile.x >= b.x && tile.x < b.x + w && tile.y >= b.y && tile.y < b.y + h;
                });
                
                if (building) {
                    selectBuilding(building.type);
                }
                return;
            }

            if (pointer.rightButtonDown()) {
                // Right click - deselect or delete
                if (selectedBuilding) {
                    selectBuilding(null);
                } else {
                    deleteBuilding(tile.x, tile.y);
                }
                return;
            }

            // Left click when no building selected - toggle mining mode or mine
            if (!selectedBuilding) {
                miningMode = !miningMode;
                if (miningMode) {
                    manualMine();
                }
                return;
            }

            // Start drag placement if building is selected
            isDragging = true;
            lastDragTile = tile;
            tryPlaceBuilding(tile.x, tile.y);
        }

        function handlePointerMove(pointer) {
            if (!isDragging || !selectedBuilding) return;

            const world = screenToWorld(pointer.x, pointer.y);
            const tile = worldToTile(world.x, world.y);

            if (lastDragTile && (tile.x !== lastDragTile.x || tile.y !== lastDragTile.y)) {
                if (selectedBuilding === 'delete') {
                    // Drag deleting
                    tryDeleteBuilding(tile.x, tile.y);
                } else {
                    // Drag placing
                    tryPlaceBuilding(tile.x, tile.y);
                }
                lastDragTile = tile;
            }

            // Update tooltip
            updateTooltip(pointer, tile);
        }

        function handlePointerUp() {
            isDragging = false;
            lastDragTile = null;
        }

        function updateTooltip(pointer, tile) {
            const tooltip = document.getElementById('tooltip');

            if (tile.x >= 0 && tile.x < MAP_WIDTH && tile.y >= 0 && tile.y < MAP_HEIGHT) {
                const building = buildings.find(b =>
                    (b.x === tile.x && b.y === tile.y) ||
                    (b.type === 'core' && tile.x >= b.x && tile.x < b.x + 3 && tile.y >= b.y && tile.y < b.y + 3)
                );

                if (building) {
                    const data = BUILDINGS[building.type] || { desc: 'Your main base - protect it!', health: 500 };
                    const healthPct = Math.ceil((building.health / building.maxHealth) * 100);
                    const healthColor = healthPct > 50 ? '#4CAF50' : (healthPct > 25 ? '#ffaa00' : '#ff4444');

                    let html = `<div class="tooltip-title" style="cursor:pointer;user-select:none;" onclick="tooltipCollapsed = !tooltipCollapsed">${building.type === 'core' ? 'Core' : data.name} <span style="font-size:12px">${tooltipCollapsed ? 'â–¶' : 'â–¼'}</span></div>`;

                    if (!tooltipCollapsed) {
                        html += `<div class="tooltip-stat">${data.desc}</div>`;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Health:</span> <span style="color:${healthColor}">${Math.ceil(building.health)}/${building.maxHealth}</span></div>`;

                        // Show stored items
                        let hasStorage = false;
                        let storageHtml = '';
                        if (building.coalStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Coal:</span> <span style="color:${getOreColorCSS('coal')}">${Math.floor(building.coalStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (building.leadStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Lead:</span> <span style="color:${getOreColorCSS('lead')}">${Math.floor(building.leadStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (building.titaniumStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Titanium:</span> <span style="color:${getOreColorCSS('titanium')}">${Math.floor(building.titaniumStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (building.graphiteStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Graphite:</span> <span style="color:${getOreColorCSS('graphite')}">${Math.floor(building.graphiteStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (building.alloyStored > 0) {
                            storageHtml += `<div class="tooltip-stat"><span class="tooltip-stat-label">Alloy:</span> <span style="color:${getOreColorCSS('alloy')}">${Math.floor(building.alloyStored)}</span></div>`;
                            hasStorage = true;
                        }
                        if (hasStorage) {
                            html += `<div style="margin-top:6px;border-top:1px solid #444;padding-top:6px">${storageHtml}</div>`;
                        }
                    } else {
                        html += `<div class="tooltip-stat" style="color:#888;font-size:11px">Click to expand...</div>`;
                    }

                    if (!tooltipCollapsed) {

                    if (data.damage) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Damage:</span> ${data.damage}</div>`;
                    if (data.range) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Range:</span> ${data.range} tiles</div>`;
                    if (data.cooldown) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Fire rate:</span> ${(1000/data.cooldown).toFixed(1)}/s</div>`;
                    if (data.ammoType) {
                        const ammoColor = getOreColorCSS(data.ammoType);
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo type:</span> <span style="color:${ammoColor}">${data.ammoType}</span></div>`;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo/shot:</span> ${data.ammoUse}</div>`;
                    }
                    if (building.ammo !== undefined) {
                        const hasAmmo = building.ammo > 0;
                        const ammoPct = (building.ammo / (building.maxAmmo || 20)) * 100;
                        const ammoBarColor = ammoPct > 30 ? '#4CAF50' : '#ff4444';
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo:</span> <span style="color:${ammoBarColor}">${building.ammo}/${building.maxAmmo || 20}</span></div>`;
                        if (!hasAmmo) html += `<div class="tooltip-stat" style="color:#ff8844">âš  Feed ${BUILDINGS[building.type]?.ammoType || 'ammo'} via conveyor!</div>`;
                    }
                    if (data.powerUse) {
                        const powered = building.powered;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power:</span> <span style="color:${powered ? '#4CAF50' : '#ff4444'}">${powered ? 'âœ“ Connected' : 'âœ— NONE'}</span></div>`;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power use:</span> ${data.powerUse}</div>`;
                        
                        // Show grid surplus/deficit
                        const surplus = powerGrid.production - powerGrid.consumption;
                        const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                        const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
                    }
                    if (data.powerOutput) {
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power output:</span> ${data.powerOutput}</div>`;
                        
                        // Show grid surplus/deficit for generators too
                        const surplus = powerGrid.production - powerGrid.consumption;
                        const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                        const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
                    }
                    if (building.ore) {
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Mining:</span> <span style="color:${getOreColorCSS(building.ore)}">${building.ore}</span></div>`;
                        // Show ore count and speed bonus for drills
                        if (building.oreCount !== undefined && building.type && (building.type === 'drill' || building.type === 'pneumatic-drill' || building.type === 'alloy-drill')) {
                            const speedMultiplier = 1 + (building.oreCount - 1) * 0.25;
                            const effectiveSpeed = data.mineSpeed * speedMultiplier;
                            html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ore tiles:</span> ${building.oreCount}/4</div>`;
                            html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Effective speed:</span> ${effectiveSpeed.toFixed(2)}x <span style="color:#4CAF50">(+${((speedMultiplier - 1) * 100).toFixed(0)}%)</span></div>`;
                        }
                    }
                    if (data.mineSpeed) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Base speed:</span> ${data.mineSpeed}x</div>`;
                    if (data.repairRange) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Repair range:</span> ${data.repairRange} tiles</div>`;

                    // Position info
                    html += `<div class="tooltip-stat" style="margin-top:8px;color:#666;font-size:10px">Position: (${building.x}, ${building.y})</div>`;
                    } // Close tooltipCollapsed check

                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';
                } else if (oreMap[tile.y] && oreMap[tile.y][tile.x]) {
                    const ore = oreMap[tile.y][tile.x];
                    const oreColor = getOreColorCSS(ore);
                    let html = `<div class="tooltip-title" style="color:${oreColor}">${ore.charAt(0).toUpperCase() + ore.slice(1)} Ore</div>`;
                    html += `<div class="tooltip-stat">Place a drill here to mine</div>`;
                    html += `<div class="tooltip-stat" style="margin-top:8px;color:#666;font-size:10px">Position: (${tile.x}, ${tile.y})</div>`;
                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';
                } else if (selectedBuilding && BUILDINGS[selectedBuilding]) {
                    // Show selected building info when hovering empty tile
                    const data = BUILDINGS[selectedBuilding];
                    let html = `<div class="tooltip-title">${data.name}</div>`;
                    html += `<div class="tooltip-stat">${data.desc}</div>`;
                    // Show cost
                    if (data.cost && Object.keys(data.cost).length > 0) {
                        let costHtml = '<div class="tooltip-stat"><span class="tooltip-stat-label">Cost:</span> ';
                        costHtml += Object.entries(data.cost).map(([res, amt]) => {
                            const hasEnough = (resources[res] || 0) >= amt;
                            return `<span style="color:${hasEnough ? getOreColorCSS(res) : '#ff4444'}">${amt} ${res}</span>`;
                        }).join(', ');
                        html += costHtml + '</div>';
                    }
                    html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Health:</span> ${data.health}</div>`;
                    if (data.damage) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Damage:</span> ${data.damage}</div>`;
                    if (data.range) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Range:</span> ${data.range} tiles</div>`;
                    if (data.ammoType) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Ammo type:</span> <span style="color:${getOreColorCSS(data.ammoType)}">${data.ammoType}</span></div>`;
                    if (data.powerUse) {
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power use:</span> ${data.powerUse}</div>`;
                        const surplus = powerGrid.production - powerGrid.consumption;
                        const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                        const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
                    }
                    if (data.powerOutput) {
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Power output:</span> ${data.powerOutput}</div>`;
                        const surplus = powerGrid.production - powerGrid.consumption;
                        const surplusColor = surplus >= 0 ? '#4CAF50' : '#ff4444';
                        const surplusText = surplus >= 0 ? `+${surplus}` : surplus;
                        html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Grid balance:</span> <span style="color:${surplusColor}">${surplusText}</span> (${powerGrid.production}/${powerGrid.consumption})</div>`;
                    }
                    if (data.mineSpeed) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Mine speed:</span> ${data.mineSpeed}x</div>`;
                    if (data.explosionDamage) html += `<div class="tooltip-stat"><span class="tooltip-stat-label">Explosion:</span> ${data.explosionDamage} dmg, ${data.explosionRange} range</div>`;
                    html += `<div class="tooltip-stat" style="margin-top:8px;color:#666;font-size:10px">Position: (${tile.x}, ${tile.y})</div>`;
                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';
                } else {
                    // Show terrain info
                    const terrain = terrainMap[tile.y][tile.x];
                    const terrainNames = { 0: 'Grass', 1: 'Sand', 2: 'Water', 3: 'Stone', 4: 'Dark Stone' };
                    let html = `<div class="tooltip-title" style="color:#888">${terrainNames[terrain] || 'Unknown'}</div>`;
                    if (terrain === 2) {
                        html += `<div class="tooltip-stat" style="color:#ff6666">Cannot build here</div>`;
                    } else {
                        html += `<div class="tooltip-stat">Empty tile</div>`;
                    }
                    html += `<div class="tooltip-stat" style="margin-top:8px;color:#666;font-size:10px">Position: (${tile.x}, ${tile.y})</div>`;
                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';
                }
            } else {
                tooltip.style.display = 'none';
            }
        }

        function getOreColorCSS(type) {
            const colors = { copper: '#d4a574', lead: '#888899', coal: '#666666', titanium: '#4a7c9b', graphite: '#2a2a2a', alloy: '#b8967a', sand: '#c9b592' };
            return colors[type] || '#ffffff';
        }

        function getOreColor(type) {
            const colors = { copper: 0xd4a574, lead: 0x888899, coal: 0x444444, titanium: 0x4a7c9b, graphite: 0x2a2a2a, alloy: 0xb8967a, sand: 0xc9b592 };
            return colors[type] || 0xffffff;
        }

        function tryDeleteBuilding(x, y) {
            if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return;
            deleteBuilding(x, y);
        }

        function tryPlaceBuilding(x, y) {
            if (!selectedBuilding) return;
            if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return;

            if (selectedBuilding === 'delete') {
                deleteBuilding(x, y);
                return;
            }

            const data = BUILDINGS[selectedBuilding];
            const width = data.width || 1;
            const height = data.height || 1;

            // Check if all tiles are available for 2x2 buildings
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    if (checkX >= MAP_WIDTH || checkY >= MAP_HEIGHT) return;
                    if (map[checkY][checkX] !== 0) return;
                    if (terrainMap[checkY][checkX] === TERRAIN.WATER) return;
                }
            }

            if (!canAfford(selectedBuilding)) return;

            const isDrill = selectedBuilding === 'drill' || selectedBuilding === 'pneumatic-drill' || selectedBuilding === 'alloy-drill';
            if (isDrill) {
                // For 2x2 drills, check if ANY of the 4 tiles has ore OR is sand
                let hasOreOrSand = false;
                for (let dy = 0; dy < height; dy++) {
                    for (let dx = 0; dx < width; dx++) {
                        if ((oreMap[y + dy] && oreMap[y + dy][x + dx]) || 
                            (terrainMap[y + dy] && terrainMap[y + dy][x + dx] === TERRAIN.SAND)) {
                            hasOreOrSand = true;
                            break;
                        }
                    }
                    if (hasOreOrSand) break;
                }
                if (!hasOreOrSand) return;
            }

            spend(selectedBuilding);

            const building = {
                type: selectedBuilding,
                x: x, y: y,
                rotation: rotation,
                health: data.health,
                maxHealth: data.health,
                cooldown: 0,
                stored: 0,
                powered: false,
                ammo: 0,
                width: width,
                height: height,
                buildProgress: 0,
                isConstructing: true
            };

            if (isDrill) {
                // For 2x2 drills, count all ore tiles and pick highest priority
                // Priority: Sand < Coal < Copper < Lead < Titanium
                // Note: Titanium can only be mined by pneumatic-drill and alloy-drill
                const orePriority = { sand: 1, coal: 2, copper: 3, lead: 4, titanium: 5 };
                let highestPriorityOre = null;
                let highestPriority = 0;
                let oreCount = 0;
                const canMineTitanium = selectedBuilding === 'pneumatic-drill' || selectedBuilding === 'alloy-drill';
                
                for (let dy = 0; dy < height; dy++) {
                    for (let dx = 0; dx < width; dx++) {
                        let foundOre = null;
                        if (oreMap[y + dy] && oreMap[y + dy][x + dx]) {
                            foundOre = oreMap[y + dy][x + dx];
                            // Skip titanium if drill can't mine it
                            if (foundOre === 'titanium' && !canMineTitanium) {
                                continue;
                            }
                        } else if (terrainMap[y + dy] && terrainMap[y + dy][x + dx] === TERRAIN.SAND) {
                            foundOre = 'sand';
                        }
                        
                        if (foundOre) {
                            oreCount++;
                            const priority = orePriority[foundOre] || 0;
                            if (priority > highestPriority) {
                                highestPriority = priority;
                                highestPriorityOre = foundOre;
                            }
                        }
                    }
                }
                
                building.ore = highestPriorityOre;
                building.oreCount = oreCount; // Store count for speed bonus
            }

            if (selectedBuilding === 'generator') {
                building.coalStored = 0;
                building.active = false;
            }

            if (selectedBuilding === 'thermal-generator') {
                building.coalStored = 0;
                building.leadStored = 0;
                building.active = false;
            }

            // Alloy factory stores lead and titanium
            if (selectedBuilding === 'alloy-factory') {
                building.leadStored = 0;
                building.titaniumStored = 0;
                building.craftProgress = 0;
                building.powered = false;
            }

            // Miner constructor stores lead and titanium
            if (selectedBuilding === 'miner-constructor') {
                building.leadStored = 0;
                building.titaniumStored = 0;
                building.craftProgress = 0;
            }

            // Graphite press stores coal
            if (selectedBuilding === 'graphite-press') {
                building.coalStored = 0;
                building.craftProgress = 0;
            }

            // Turrets start with NO ammo - must be fed via conveyors
            if (selectedBuilding === 'turret' || selectedBuilding === 'scatter' || selectedBuilding === 'alloy-turret' || selectedBuilding === 'stormer') {
                building.ammo = 0;
                building.maxAmmo = 20;
            }

            // Add to construction queue instead of directly to buildings
            constructionQueue.push(building);

            // Mark tiles as occupied immediately to prevent overlapping placements
            if (width > 1 || height > 1) {
                for (let dy = 0; dy < height; dy++) {
                    for (let dx = 0; dx < width; dx++) {
                        map[y + dy][x + dx] = 'constructing';
                    }
                }
            } else {
                map[y][x] = 'constructing';
            }

            spawnParticles(x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2, 0xffaa00, 5);
        }

        function deleteBuilding(x, y) {
            // First check construction queue
            let constructionIdx = constructionQueue.findIndex(b => {
                const w = b.width || 1;
                const h = b.height || 1;
                return x >= b.x && x < b.x + w && y >= b.y && y < b.y + h;
            });

            if (constructionIdx !== -1) {
                const b = constructionQueue[constructionIdx];
                const data = BUILDINGS[b.type];
                const w = b.width || 1;
                const h = b.height || 1;

                // Refund full cost for buildings under construction
                if (data && data.cost) {
                    for (let res in data.cost) {
                        resources[res] += data.cost[res];
                    }
                    updateResourceUI();
                }

                // Remove from construction queue
                constructionQueue.splice(constructionIdx, 1);

                // Clear tiles
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        map[b.y + dy][b.x + dx] = 0;
                    }
                }

                spawnParticles(b.x * TILE_SIZE + TILE_SIZE/2, b.y * TILE_SIZE + TILE_SIZE/2, 0xff4444, 5);
                return;
            }

            // Then check completed buildings
            let idx = buildings.findIndex(b => {
                if (b.type === 'core') return false;
                const w = b.width || 1;
                const h = b.height || 1;
                return x >= b.x && x < b.x + w && y >= b.y && y < b.y + h;
            });
            if (idx !== -1) {
                let b = buildings[idx];

                // Resolve to master if it's a tile reference
                if (b.isTileRef) {
                    b = b.master;
                    idx = buildings.indexOf(b);
                }

                const data = BUILDINGS[b.type];
                const w = b.width || 1;
                const h = b.height || 1;

                if (data && data.cost) {
                    for (let res in data.cost) {
                        resources[res] += Math.floor(data.cost[res] * 0.5);
                    }
                    updateResourceUI();
                }

                // Remove master and all tile references
                if (b.isMaster) {
                    buildings = buildings.filter(building => {
                        if (building === b) return false;
                        if (building.isTileRef && building.master === b) return false;
                        return true;
                    });
                } else {
                    buildings.splice(idx, 1);
                }

                // Clear all tiles
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        map[b.y + dy][b.x + dx] = 0;
                    }
                }

                spawnParticles(b.x * TILE_SIZE + TILE_SIZE/2, b.y * TILE_SIZE + TILE_SIZE/2, 0xff4444, 5);
            }
        }

        function destroyBuilding(building) {
            const idx = buildings.indexOf(building);
            if (idx !== -1 && building.type !== 'core') {
                // Check if explosive - trigger explosion
                if (building.type === 'explosive') {
                    const expData = BUILDINGS.explosive;
                    const expRange = expData.explosionRange * TILE_SIZE;
                    const expDamage = expData.explosionDamage;
                    const targetX = building.x * TILE_SIZE + TILE_SIZE / 2;
                    const targetY = building.y * TILE_SIZE + TILE_SIZE / 2;

                    // Damage enemies in range
                    enemies.forEach(e => {
                        const dx = e.x - targetX;
                        const dy = e.y - targetY;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < expRange) {
                            const falloff = 1 - (dist / expRange);
                            e.health -= expDamage * falloff;
                            spawnParticles(e.x, e.y, 0xff6600, 5);
                        }
                    });

                    // Explosion particles (reduced for performance)
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 5 + 2;
                        particles.push({
                            x: targetX,
                            y: targetY,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            color: Math.random() > 0.5 ? 0xff6600 : 0xffcc00,
                            life: Math.random() * 30 + 20
                        });
                    }
                }

                // Remove from map - handle multi-tile buildings
                const w = building.width || 1;
                const h = building.height || 1;
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        map[building.y + dy][building.x + dx] = 0;
                    }
                }
                
                buildings.splice(idx, 1);
                spawnParticles(building.x * TILE_SIZE + TILE_SIZE/2, building.y * TILE_SIZE + TILE_SIZE/2, 0x666666, 10);
            }
        }

        function produceTick() {
            buildings.forEach(b => {
                if ((b.type === 'drill' || b.type === 'pneumatic-drill' || b.type === 'alloy-drill') && b.ore) {
                    // Safety check: normal drills cannot mine titanium
                    if (b.type === 'drill' && b.ore === 'titanium') {
                        return; // Skip - normal drill can't mine titanium
                    }
                    const data = BUILDINGS[b.type];
                    // Speed bonus: each ore tile adds 25% speed (1 tile = 1x, 2 tiles = 1.25x, 3 tiles = 1.5x, 4 tiles = 1.75x)
                    const oreCount = b.oreCount || 1;
                    const speedMultiplier = 1 + (oreCount - 1) * 0.25;
                    b.stored = (b.stored || 0) + data.mineSpeed * speedMultiplier;
                    if (b.stored >= 2) {
                        outputItem(b, b.ore);
                        b.stored = 0;
                    }
                }
            });
        }

        // Ammo tick removed - turrets now get ammo from conveyor items only

        function powerTick() {
            let totalProduction = 0;
            let totalConsumption = 0;

            buildings.forEach(b => {
                if (b.type === 'generator') {
                    const data = BUILDINGS.generator;
                    if (b.coalStored > data.coalConsume) {
                        b.coalStored -= data.coalConsume;
                        b.active = true;
                        totalProduction += data.powerOutput;
                    } else {
                        b.active = false;
                    }
                }
                if (b.type === 'thermal-generator') {
                    const data = BUILDINGS['thermal-generator'];
                    if (b.coalStored > data.coalConsume && b.leadStored > data.leadConsume) {
                        b.coalStored -= data.coalConsume;
                        b.leadStored -= data.leadConsume;
                        b.active = true;
                        totalProduction += data.powerOutput;
                    } else {
                        b.active = false;
                    }
                }
            });

            // Count power consumers
            buildings.forEach(b => {
                if (b.type === 'laser') {
                    totalConsumption += BUILDINGS.laser.powerUse;
                }
                if (b.type === 'alloy-factory') {
                    totalConsumption += BUILDINGS['alloy-factory'].powerUse;
                }
                if (b.type === 'repair') {
                    totalConsumption += BUILDINGS.repair.powerUse;
                }
                if (b.type === 'miner-constructor' && b.craftProgress > 0) {
                    totalConsumption += 20; // 20 power when crafting
                }
            });

            // Calculate power efficiency (everything runs slower when low on power)
            const powerEfficiency = totalConsumption > 0 ? 
                Math.min(1.0, totalProduction / totalConsumption) : 1.0;

            // Power all connected consumers (they all run but slower if not enough power)
            buildings.filter(b => b.type === 'laser' || b.type === 'alloy-factory' || b.type === 'repair').forEach(consumer => {
                const cw = consumer.width || 1;
                const ch = consumer.height || 1;
                const cx = (consumer.x + cw / 2) * TILE_SIZE;
                const cy = (consumer.y + ch / 2) * TILE_SIZE;

                const connected = buildings.some(node => {
                    // Power nodes can connect to generators, other power nodes, and any building that produces power
                    if (node.type !== 'power-node' && node.type !== 'large-power-node' && node.type !== 'generator' && node.type !== 'thermal-generator') return false;
                    const nw = node.width || 1;
                    const nh = node.height || 1;
                    const nx = (node.x + nw / 2) * TILE_SIZE;
                    const ny = (node.y + nh / 2) * TILE_SIZE;
                    const dist = Math.sqrt((cx - nx)**2 + (cy - ny)**2);
                    const nodeData = BUILDINGS[node.type];
                    const range = nodeData.powerRange || BUILDINGS['power-node'].powerRange;
                    return dist <= range * TILE_SIZE;
                });

                consumer.powered = connected;
                consumer.powerEfficiency = connected ? powerEfficiency : 0;
            });

            // Construction queue - progress buildings under construction (iterate backwards to safely remove)
            for (let i = constructionQueue.length - 1; i >= 0; i--) {
                const building = constructionQueue[i];
                const buildTime = BUILDINGS[building.type].buildTime || 0;

                if (buildTime === 0) {
                    // Instant build (like core or buildings without buildTime)
                    building.isConstructing = false;
                    building.buildProgress = buildTime;
                } else {
                    // Progress construction by 500ms per tick
                    building.buildProgress += 500;
                }

                // Check if construction is complete
                if (building.buildProgress >= buildTime) {
                    // Remove from construction queue
                    constructionQueue.splice(i, 1);
                    building.isConstructing = false;

                    // Add to buildings array
                    const width = building.width || 1;
                    const height = building.height || 1;

                    buildings.push(building);

                    // For 2x2 buildings, create tile references
                    if (width > 1 || height > 1) {
                        building.isMaster = true;
                        building.tileX = building.x;
                        building.tileY = building.y;

                        for (let dy = 0; dy < height; dy++) {
                            for (let dx = 0; dx < width; dx++) {
                                if (dx === 0 && dy === 0) continue; // Skip top-left (master)

                                const tileRef = new Proxy({
                                    _isTileRef: true,
                                    _master: building,
                                    _x: building.x + dx,
                                    _y: building.y + dy
                                }, {
                                    get(target, prop) {
                                        if (prop === 'isTileRef') return true;
                                        if (prop === 'master') return target._master;
                                        if (prop === 'x') return target._x;
                                        if (prop === 'y') return target._y;
                                        if (prop === 'width') return 1;
                                        if (prop === 'height') return 1;
                                        return target._master[prop];
                                    },
                                    set(target, prop, value) {
                                        if (prop === 'x' || prop === 'y') {
                                            target['_' + prop] = value;
                                            return true;
                                        }
                                        target._master[prop] = value;
                                        return true;
                                    }
                                });

                                buildings.push(tileRef);
                                map[building.y + dy][building.x + dx] = building.type;
                            }
                        }
                        map[building.y][building.x] = building.type;
                    } else {
                        map[building.y][building.x] = building.type;
                    }

                    spawnParticles(building.x * TILE_SIZE + TILE_SIZE/2, building.y * TILE_SIZE + TILE_SIZE/2, 0x44ff44, 8);
                }
            }

            // Graphite press crafting (no power required) - only process master buildings, not tile refs
            buildings.filter(b => b.type === 'graphite-press' && !b.isTileRef).forEach(press => {
                if ((press.coalStored || 0) >= 2) {
                    press.craftProgress = (press.craftProgress || 0) + 500; // Progress per tick (500ms)
                    if (press.craftProgress >= BUILDINGS['graphite-press'].craftTime) {
                        press.craftProgress = 0;
                        press.coalStored -= 2;
                        // Output graphite
                        outputItem(press, 'graphite');
                    }
                }
            });

            // Alloy factory crafting (slower when low power) - only process master buildings, not tile refs
            buildings.filter(b => b.type === 'alloy-factory' && !b.isTileRef).forEach(factory => {
                if (factory.powered && (factory.leadStored || 0) >= 1 && (factory.titaniumStored || 0) >= 1) {
                    const progressRate = 500 * (factory.powerEfficiency || 0); // Slowed by power efficiency
                    factory.craftProgress = (factory.craftProgress || 0) + progressRate;
                    if (factory.craftProgress >= BUILDINGS['alloy-factory'].craftTime) {
                        factory.craftProgress = 0;
                        factory.leadStored = (factory.leadStored || 0) - 1;
                        factory.titaniumStored = (factory.titaniumStored || 0) - 1;
                        // Output alloy
                        outputItem(factory, 'alloy');
                    }
                }
            });

            // Miner constructor crafting (uses 20 power when active)
            buildings.filter(b => b.type === 'miner-constructor').forEach(constructor => {
                if (constructor.leadStored >= 50 && constructor.titaniumStored >= 50) {
                    // Craft speed affected by powerEfficiency, but always makes some progress (min 20%)
                    const effectivePower = Math.max(0.2, powerEfficiency); // Minimum 20% speed even with no power
                    constructor.craftProgress = (constructor.craftProgress || 0) + (500 * effectivePower); // Progress per tick (500ms)
                    if (constructor.craftProgress >= BUILDINGS['miner-constructor'].craftTime) {
                        constructor.craftProgress = 0;
                        constructor.leadStored -= 50;
                        constructor.titaniumStored -= 50;
                        // Spawn a miner unit
                        spawnMiner(constructor);
                    }
                }
            });

            powerGrid.production = totalProduction;
            powerGrid.consumption = totalConsumption;
        }

        // Track which ore nodes are being mined by how many drones (for slot-based pathfinding)
        let oreNodeMiners = {}; // Key: "x,y", Value: array of miner indices
        const MAX_MINERS_PER_NODE = 3; // Maximum drones that can mine a single ore node

        function getOreNodeKey(x, y) {
            return `${x},${y}`;
        }

        function countMinersAtNode(x, y) {
            const key = getOreNodeKey(x, y);
            return miners.filter(m => m.targetX === x && m.targetY === y && m.state !== 'returning').length;
        }

        function findBestOreNode(startX, startY, targetOreType) {
            // Find ore nodes with available slots (fewer than MAX_MINERS_PER_NODE drones)
            let bestOre = null;
            let bestScore = Infinity;

            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const ore = oreMap[y] && oreMap[y][x];
                    if (ore === targetOreType) {
                        const minerCount = countMinersAtNode(x, y);
                        if (minerCount < MAX_MINERS_PER_NODE) {
                            const dist = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
                            // Score combines distance and crowding (prefer less crowded nodes)
                            const score = dist + minerCount * 20;
                            if (score < bestScore) {
                                bestScore = score;
                                bestOre = { x, y, type: ore };
                            }
                        }
                    }
                }
            }
            return bestOre;
        }

        function spawnMiner(constructor) {
            // Determine which ore to target based on current resources
            // Target lead if more copper, target copper if more lead
            const targetOreType = (resources.copper || 0) > (resources.lead || 0) ? 'lead' : 'copper';

            // Get spawn position based on constructor rotation (orientation)
            const dir = getDirection(constructor.rotation);
            const constructorCenterX = constructor.x + 1;
            const constructorCenterY = constructor.y + 1;

            // Spawn drone at the edge of the constructor in the rotation direction
            const spawnX = (constructorCenterX + dir.x * 1.5) * TILE_SIZE;
            const spawnY = (constructorCenterY + dir.y * 1.5) * TILE_SIZE;

            // Find ore node with available slots
            let targetOre = findBestOreNode(constructorCenterX, constructorCenterY, targetOreType);

            // If no ore of target type found with slots, try the other type
            if (!targetOre) {
                const fallbackType = targetOreType === 'copper' ? 'lead' : 'copper';
                targetOre = findBestOreNode(constructorCenterX, constructorCenterY, fallbackType);
            }

            if (targetOre) {
                miners.push({
                    x: spawnX,
                    y: spawnY,
                    targetX: targetOre.x,
                    targetY: targetOre.y,
                    oreType: targetOre.type,
                    miningCooldown: 0,
                    health: 50,
                    maxHealth: 50,
                    // Inventory system
                    inventory: 0,
                    maxInventory: 30,
                    state: 'mining', // 'mining' or 'returning'
                    homeX: constructorCenterX, // Remember where we came from
                    homeY: constructorCenterY
                });
                spawnParticles(spawnX, spawnY, 0x44ff44, 8);
            }
        }

        function outputItem(building, itemType) {
            // For drills, check all edges of the 2x2 drill
            const isDrill = building.type === 'drill' || building.type === 'pneumatic-drill' || building.type === 'alloy-drill';
            
            if (isDrill) {
                // For 2x2 drills, check all tiles on all 4 edges
                const width = building.width || 1;
                const height = building.height || 1;
                const edges = [];
                
                // Right edge
                for (let dy = 0; dy < height; dy++) {
                    edges.push({ x: building.x + width, y: building.y + dy });
                }
                // Left edge
                for (let dy = 0; dy < height; dy++) {
                    edges.push({ x: building.x - 1, y: building.y + dy });
                }
                // Bottom edge
                for (let dx = 0; dx < width; dx++) {
                    edges.push({ x: building.x + dx, y: building.y + height });
                }
                // Top edge
                for (let dx = 0; dx < width; dx++) {
                    edges.push({ x: building.x + dx, y: building.y - 1 });
                }
                
                for (const pos of edges) {
                    if (pos.x < 0 || pos.x >= MAP_WIDTH || pos.y < 0 || pos.y >= MAP_HEIGHT) continue;
                    
                    const target = buildings.find(t =>
                        t.x === pos.x && t.y === pos.y ||
                        (t.type === 'core' && pos.x >= t.x && pos.x < t.x + 3 && pos.y >= t.y && pos.y < t.y + 3)
                    );
                    
                    if (target && tryOutputToTarget(building, target, pos.x, pos.y, itemType)) {
                        return; // Successfully output, stop checking
                    }
                }
            } else {
                // For 2x2 buildings, check all edges for valid conveyors (not just rotation direction)
                const width = building.width || 1;
                const height = building.height || 1;

                // Generate all possible output positions on all edges
                const outputPositions = [];
                if (width === 2 && height === 2) {
                    // Right edge
                    outputPositions.push({ x: building.x + 2, y: building.y });
                    outputPositions.push({ x: building.x + 2, y: building.y + 1 });
                    // Left edge
                    outputPositions.push({ x: building.x - 1, y: building.y });
                    outputPositions.push({ x: building.x - 1, y: building.y + 1 });
                    // Bottom edge
                    outputPositions.push({ x: building.x, y: building.y + 2 });
                    outputPositions.push({ x: building.x + 1, y: building.y + 2 });
                    // Top edge
                    outputPositions.push({ x: building.x, y: building.y - 1 });
                    outputPositions.push({ x: building.x + 1, y: building.y - 1 });
                } else {
                    // For 1x1, use rotation direction
                    const dir = getDirection(building.rotation);
                    outputPositions.push({ x: building.x + dir.x, y: building.y + dir.y });
                }

                // Try each output position
                for (const pos of outputPositions) {
                    if (pos.x < 0 || pos.x >= MAP_WIDTH || pos.y < 0 || pos.y >= MAP_HEIGHT) continue;

                    const target = buildings.find(t => {
                        // Check exact tile match
                        if (t.x === pos.x && t.y === pos.y) return true;
                        // Check 2x2 buildings
                        const w = t.width || 1;
                        const h = t.height || 1;
                        if (w > 1 || h > 1) {
                            return pos.x >= t.x && pos.x < t.x + w && pos.y >= t.y && pos.y < t.y + h;
                        }
                        return false;
                    });

                    if (target && tryOutputToTarget(building, target, pos.x, pos.y, itemType)) {
                        return; // Successfully output
                    }
                }
            }
        }

        function tryOutputToTarget(building, target, outX, outY, itemType) {
            if (target.type === 'core') {
                resources[itemType] = (resources[itemType] || 0) + 1;
                updateResourceUI();
                spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                return true;
            } else if (target.type === 'generator' && itemType === 'coal') {
                target.coalStored = (target.coalStored || 0) + 1;
                return true;
            } else if (target.type === 'thermal-generator') {
                if (itemType === 'coal' && target.coalStored < 10) {
                    target.coalStored++;
                    return true;
                } else if (itemType === 'lead' && target.leadStored < 10) {
                    target.leadStored++;
                    return true;
                }
            } else if (target.type === 'graphite-press' && itemType === 'coal') {
                if ((target.coalStored || 0) < 10) { // Allow storing more coal
                    target.coalStored = (target.coalStored || 0) + 1;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                }
            } else if (target.type === 'alloy-factory') {
                // Alloy factory accepts lead and titanium
                if (itemType === 'lead' && (target.leadStored || 0) < 10) {
                    target.leadStored = (target.leadStored || 0) + 1;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                } else if (itemType === 'titanium' && (target.titaniumStored || 0) < 10) {
                    target.titaniumStored = (target.titaniumStored || 0) + 1;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                }
            } else if (target.type === 'miner-constructor') {
                // Miner constructor accepts lead and titanium
                if (itemType === 'lead' && target.leadStored < 100) {
                    target.leadStored++;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                } else if (itemType === 'titanium' && target.titaniumStored < 100) {
                    target.titaniumStored++;
                    spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                    return true;
                }
            } else if (target.type === 'conveyor' || target.type === 'alloy-conveyor' || target.type === 'router' || target.type === 'junction') {
                // Don't output to a conveyor that's facing towards us (it wants to output TO us, not receive FROM us)
                if (target.type === 'conveyor' || target.type === 'alloy-conveyor') {
                    const conveyorOutputDir = getDirection(target.rotation);
                    const conveyorOutputX = target.x + conveyorOutputDir.x;
                    const conveyorOutputY = target.y + conveyorOutputDir.y;

                    // Check if the conveyor is outputting towards the source building
                    const bw = building.width || 1;
                    const bh = building.height || 1;
                    const conveyorPointsToSource = conveyorOutputX >= building.x && conveyorOutputX < building.x + bw &&
                                                     conveyorOutputY >= building.y && conveyorOutputY < building.y + bh;
                    if (conveyorPointsToSource) {
                        return false; // Can't output to a conveyor facing us
                    }
                }

                // Items now use world coordinates for smooth movement
                // For 2x2 buildings, use the center of the entire building, not just top-left
                const bw = building.width || 1;
                const bh = building.height || 1;
                const startWorldX = (building.x + bw / 2) * TILE_SIZE;
                const startWorldY = (building.y + bh / 2) * TILE_SIZE;

                // Calculate fromDir based on where the item exits the building
                let fromDir = -1;
                if (outX < building.x) fromDir = 2; // Exiting left, came from right
                else if (outX >= building.x + bw) fromDir = 0; // Exiting right, came from left
                else if (outY < building.y) fromDir = 3; // Exiting up, came from down
                else if (outY >= building.y + bh) fromDir = 1; // Exiting down, came from up

                // Check item limit for performance
                if (items.length >= MAX_ITEMS) {
                    // Too many items - skip spawning to prevent lag
                    return false;
                }
                items.push({
                    type: itemType,
                    worldX: startWorldX,
                    worldY: startWorldY,
                    targetTileX: outX,
                    targetTileY: outY,
                    fromDir: fromDir
                });
                return true;
            } else if ((target.type === 'turret' || target.type === 'scatter') &&
                       BUILDINGS[target.type].ammoType === itemType &&
                       target.ammo < (target.maxAmmo || 20)) {
                // Feed ammo to turret
                target.ammo++;
                spawnParticles(outX * TILE_SIZE + TILE_SIZE/2, outY * TILE_SIZE + TILE_SIZE/2, getOreColor(itemType), 3);
                return true;
            }
            return false;
        }

        // Smooth item movement speed (pixels per frame)
        const ITEM_SPEED = 1.5;
        // Maximum items on conveyors for performance
        const MAX_ITEMS = 800;  // Increased for larger map

        // Helper function to handle item reaching a target
        function handleItemTarget(item, target, nextX, nextY, dir, targetWorldX, targetWorldY, toRemove, idx) {
            if (target.type === 'core') {
                resources[item.type] = (resources[item.type] || 0) + 1;
                updateResourceUI();
                spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                toRemove.push(idx);
                return true;
            } else if (target.type === 'generator' && item.type === 'coal') {
                target.coalStored = (target.coalStored || 0) + 1;
                spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                toRemove.push(idx);
                return true;
            } else if (target.type === 'thermal-generator') {
                // Thermal generator accepts coal and lead
                if (item.type === 'coal' && target.coalStored < 10) {
                    target.coalStored = (target.coalStored || 0) + 1;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                } else if (item.type === 'lead' && target.leadStored < 10) {
                    target.leadStored = (target.leadStored || 0) + 1;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                }
            } else if (target.type === 'graphite-press' && item.type === 'coal') {
                if (target.coalStored < 2) {
                    target.coalStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                }
            } else if (target.type === 'alloy-factory') {
                // Alloy factory accepts lead and titanium
                if (item.type === 'lead' && target.leadStored < 10) {
                    target.leadStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                } else if (item.type === 'titanium' && target.titaniumStored < 10) {
                    target.titaniumStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                }
            } else if (target.type === 'miner-constructor') {
                // Miner constructor accepts lead and titanium
                if (item.type === 'lead' && target.leadStored < 100) {
                    target.leadStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                } else if (item.type === 'titanium' && target.titaniumStored < 100) {
                    target.titaniumStored++;
                    spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                    toRemove.push(idx);
                    return true;
                }
            } else if ((target.type === 'turret' || target.type === 'scatter' || target.type === 'alloy-turret' || target.type === 'stormer') &&
                       BUILDINGS[target.type].ammoType === item.type &&
                       target.ammo < (target.maxAmmo || 20)) {
                // Feed ammo to turret
                target.ammo++;
                spawnParticles(item.worldX, item.worldY, getOreColor(item.type), 3);
                toRemove.push(idx);
                return true;
            } else if (target.type === 'conveyor' || target.type === 'alloy-conveyor' || target.type === 'router' || target.type === 'junction') {
                // Check if next tile is blocked
                const occupied = items.some(i => i !== item &&
                    i.targetTileX === nextX && i.targetTileY === nextY &&
                    Math.sqrt((i.worldX - targetWorldX)**2 + (i.worldY - targetWorldY)**2) < TILE_SIZE * 0.6
                );
                if (!occupied) {
                    item.targetTileX = nextX;
                    item.targetTileY = nextY;
                    item.fromDir = (dir + 2) % 4;
                    return true;
                }
            }
            return false;
        }

        function updateItems() {
            const toRemove = [];

            items.forEach((item, idx) => {
                // Calculate target world position (center of target tile)
                const targetWorldX = item.targetTileX * TILE_SIZE + TILE_SIZE / 2;
                const targetWorldY = item.targetTileY * TILE_SIZE + TILE_SIZE / 2;

                // Move towards target
                const dx = targetWorldX - item.worldX;
                const dy = targetWorldY - item.worldY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > ITEM_SPEED) {
                    // Still moving to target
                    item.worldX += (dx / dist) * ITEM_SPEED;
                    item.worldY += (dy / dist) * ITEM_SPEED;
                } else {
                    // Reached target tile center - find next destination
                    item.worldX = targetWorldX;
                    item.worldY = targetWorldY;

                    let building = buildings.find(b => {
                        // Check if target tile is within building bounds
                        const w = b.width || 1;
                        const h = b.height || 1;
                        return item.targetTileX >= b.x && item.targetTileX < b.x + w &&
                               item.targetTileY >= b.y && item.targetTileY < b.y + h;
                    });
                    
                    // Resolve tile reference to master
                    if (building && building.isTileRef) {
                        building = building.master;
                    }
                    
                    if (!building) {
                        toRemove.push(idx);
                        return;
                    }

                    // Determine output directions and find valid targets
                    let moved = false;

                    if (building.type === 'conveyor' || building.type === 'alloy-conveyor') {
                        // Conveyor: single output direction
                        const dir = building.rotation;
                        const d = getDirection(dir);
                        const nextX = item.targetTileX + d.x;
                        const nextY = item.targetTileY + d.y;

                        if (nextX >= 0 && nextX < MAP_WIDTH && nextY >= 0 && nextY < MAP_HEIGHT) {
                            let target = buildings.find(b => {
                                // Check exact tile match
                                if (b.x === nextX && b.y === nextY) return true;
                                // Check 2x2 buildings
                                const w = b.width || 1;
                                const h = b.height || 1;
                                if (w > 1 || h > 1) {
                                    return nextX >= b.x && nextX < b.x + w && nextY >= b.y && nextY < b.y + h;
                                }
                                return false;
                            });

                            // Resolve tile reference to master
                            if (target && target.isTileRef) {
                                target = target.master;
                            }

                            if (target) {
                                moved = handleItemTarget(item, target, nextX, nextY, dir, targetWorldX, targetWorldY, toRemove, idx);
                            }
                        }
                    } else if (building.type === 'router') {
                        // Router: distribute evenly to valid outputs only
                        // Only outputs to: conveyors facing away, cores, and buildings that need this resource
                        let validOutputs = [];

                        for (let dirIdx = 0; dirIdx < 4; dirIdx++) {
                            if (dirIdx === item.fromDir) continue; // Skip input direction

                            const d = getDirection(dirIdx);
                            const nextX = item.targetTileX + d.x;
                            const nextY = item.targetTileY + d.y;

                            if (nextX < 0 || nextX >= MAP_WIDTH || nextY < 0 || nextY >= MAP_HEIGHT) continue;

                            let target = buildings.find(b => {
                                // Check exact tile match
                                if (b.x === nextX && b.y === nextY) return true;
                                // Check 2x2 buildings (core, graphite-press, alloy-factory, thermal-generator, drills)
                                const w = b.width || 1;
                                const h = b.height || 1;
                                if (w > 1 || h > 1) {
                                    return nextX >= b.x && nextX < b.x + w && nextY >= b.y && nextY < b.y + h;
                                }
                                return false;
                            });
                            
                            // Resolve tile reference to master
                            if (target && target.isTileRef) {
                                target = target.master;
                            }

                            if (target) {
                                let isValidTarget = false;
                                
                                // Always output to core
                                if (target.type === 'core') {
                                    isValidTarget = true;
                                }
                                // Output to generator if it needs coal
                                else if (target.type === 'generator' && item.type === 'coal') {
                                    isValidTarget = true;
                                }
                                // Output to thermal generator if it needs coal or lead
                                else if (target.type === 'thermal-generator') {
                                    if ((item.type === 'coal' && target.coalStored < 10) ||
                                        (item.type === 'lead' && target.leadStored < 10)) {
                                        isValidTarget = true;
                                    }
                                }
                                // Output to graphite press if it needs coal
                                else if (target.type === 'graphite-press' && item.type === 'coal' && target.coalStored < 2) {
                                    isValidTarget = true;
                                }
                                // Output to alloy factory if it needs copper or lead
                                else if (target.type === 'alloy-factory') {
                                    if ((item.type === 'lead' && target.leadStored < 10) ||
                                        (item.type === 'titanium' && target.titaniumStored < 10)) {
                                        isValidTarget = true;
                                    }
                                }
                                // Output to miner constructor if it needs lead or titanium
                                else if (target.type === 'miner-constructor') {
                                    if ((item.type === 'lead' && target.leadStored < 100) ||
                                        (item.type === 'titanium' && target.titaniumStored < 100)) {
                                        isValidTarget = true;
                                    }
                                }
                                // Output to turret if it needs ammo
                                else if ((target.type === 'turret' || target.type === 'scatter' || target.type === 'alloy-turret' || target.type === 'stormer') &&
                                         BUILDINGS[target.type].ammoType === item.type &&
                                         target.ammo < (target.maxAmmo || 20)) {
                                    isValidTarget = true;
                                }
                                // Output to conveyor ONLY if it's facing away from the router
                                else if (target.type === 'conveyor' || target.type === 'alloy-conveyor') {
                                    // A conveyor accepts input from behind (opposite of its output direction)
                                    // Router outputs in dirIdx direction, conveyor at (nextX, nextY)
                                    // Check: is the router outputting from the direction that the conveyor accepts input from?
                                    const conveyorOutputDir = target.rotation;
                                    const routerToConveyor = dirIdx; // Direction from router to conveyor
                                    const conveyorToRouter = (routerToConveyor + 2) % 4; // Direction from conveyor back to router

                                    // Conveyor accepts input from behind, which is opposite its output direction
                                    const conveyorInputDir = (conveyorOutputDir + 2) % 4;

                                    // Check if conveyor's input direction matches where the router is
                                    if (conveyorToRouter === conveyorInputDir) {
                                        isValidTarget = true;
                                    }
                                }
                                // Output to other routers and junctions
                                else if (target.type === 'router' || target.type === 'junction') {
                                    isValidTarget = true;
                                }

                                if (isValidTarget) {
                                    // Check if not blocked
                                    const occupied = items.some(i => i !== item &&
                                        i.targetTileX === nextX && i.targetTileY === nextY &&
                                        Math.sqrt((i.worldX - targetWorldX)**2 + (i.worldY - targetWorldY)**2) < TILE_SIZE * 0.6
                                    );
                                    if (!occupied) {
                                        validOutputs.push({ dir: dirIdx, target, nextX, nextY });
                                    }
                                }
                            }
                        }

                        if (validOutputs.length > 0) {
                            // Use random distribution
                            const chosenIdx = Math.floor(Math.random() * validOutputs.length);
                            const chosen = validOutputs[chosenIdx];

                            moved = handleItemTarget(item, chosen.target, chosen.nextX, chosen.nextY, chosen.dir, targetWorldX, targetWorldY, toRemove, idx);
                        }
                    } else if (building.type === 'junction') {
                        // Junction: pass through in same direction
                        const dir = (item.fromDir + 2) % 4;
                        const d = getDirection(dir);
                        const nextX = item.targetTileX + d.x;
                        const nextY = item.targetTileY + d.y;

                        if (nextX >= 0 && nextX < MAP_WIDTH && nextY >= 0 && nextY < MAP_HEIGHT) {
                            let target = buildings.find(b => {
                                // Check exact tile match
                                if (b.x === nextX && b.y === nextY) return true;
                                // Check 2x2 buildings
                                const w = b.width || 1;
                                const h = b.height || 1;
                                if (w > 1 || h > 1) {
                                    return nextX >= b.x && nextX < b.x + w && nextY >= b.y && nextY < b.y + h;
                                }
                                return false;
                            });

                            // Resolve tile reference to master
                            if (target && target.isTileRef) {
                                target = target.master;
                            }

                            if (target) {
                                moved = handleItemTarget(item, target, nextX, nextY, dir, targetWorldX, targetWorldY, toRemove, idx);
                            }
                        }
                    }

                    // If stuck, stay in place (item will wait)
                }
            });

            // Remove consumed items
            for (let i = toRemove.length - 1; i >= 0; i--) {
                items.splice(toRemove[i], 1);
            }
            
            // Hard limit on items for performance - increased to prevent items disappearing
            if (items.length > 1000) {
                items.splice(0, items.length - 1000);
            }
        }

        function repairTick() {
            buildings.forEach(b => {
                if (b.type === 'repair' && b.powered) { // Only repair when powered
                    const range = BUILDINGS.repair.repairRange * TILE_SIZE;
                    const rx = b.x * TILE_SIZE + TILE_SIZE/2;
                    const ry = b.y * TILE_SIZE + TILE_SIZE/2;

                    buildings.forEach(target => {
                        if (target === b || target.type === 'core') return;
                        if (target.health >= target.maxHealth) return;

                        const tx = target.x * TILE_SIZE + TILE_SIZE/2;
                        const ty = target.y * TILE_SIZE + TILE_SIZE/2;
                        const dist = Math.sqrt((tx - rx)**2 + (ty - ry)**2);

                        if (dist <= range) {
                            target.health = Math.min(target.maxHealth, target.health + 2);
                        }
                    });
                }
            });
        }

        function getDirection(rot) {
            const dirs = [{ x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 0, y: -1 }];
            return dirs[rot % 4];
        }

        function updateWaveTimer() {
            if (gameOver) return;
            waveTimer--;
            document.getElementById('next-wave').textContent = waveTimer + 's';
            if (waveTimer <= 0) {
                spawnWave();
            }
        }

        function manualMine() {
            if (player.respawnTimer > 0) {
                miningTarget = null;
                return;
            }

            // Find nearest ore node within range
            const playerTileX = Math.floor(player.x / TILE_SIZE);
            const playerTileY = Math.floor(player.y / TILE_SIZE);
            const mineRange = 3; // Can mine ore within 3 tiles

            let nearestOre = null;
            let nearestDist = Infinity;

            for (let dy = -mineRange; dy <= mineRange; dy++) {
                for (let dx = -mineRange; dx <= mineRange; dx++) {
                    const checkX = playerTileX + dx;
                    const checkY = playerTileY + dy;

                    if (checkX >= 0 && checkX < MAP_WIDTH && checkY >= 0 && checkY < MAP_HEIGHT) {
                        const ore = oreMap[checkY][checkX];

                        // Can only manually mine copper and lead
                        if (ore === 'copper' || ore === 'lead') {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestOre = {
                                    x: checkX * TILE_SIZE + TILE_SIZE / 2,
                                    y: checkY * TILE_SIZE + TILE_SIZE / 2,
                                    type: ore
                                };
                            }
                        }
                    }
                }
            }

            if (nearestOre) {
                miningTarget = nearestOre;
                resources[nearestOre.type] = (resources[nearestOre.type] || 0) + 1; // Mine 1 ore per 200ms
                updateResourceUI();
                spawnParticles(nearestOre.x, nearestOre.y, getOreColor(nearestOre.type), 3);
            } else {
                miningTarget = null;
            }
        }

        function startWaveEarly() {
            if (waveTimer > 5) {
                resources.copper += Math.floor(waveTimer / 2);
                updateResourceUI();
                spawnWave();
            }
        }

        function spawnWave() {
            wave++;
            document.getElementById('wave-num').textContent = wave;
            waveTimer = 120; // 2 minutes between waves

            // Start with 1 enemy, add 1 per wave (much slower progression)
            const baseCount = wave;

            for (let i = 0; i < baseCount; i++) {
                // Spawn from designated spawn point
                const spawnX = spawnPoint.x * TILE_SIZE + (Math.random() - 0.5) * TILE_SIZE * 4;
                const spawnY = spawnPoint.y * TILE_SIZE + (Math.random() - 0.5) * TILE_SIZE * 4;

                let enemyType = 'basic';
                const roll = Math.random();
                if (wave >= 3 && roll < 0.2) enemyType = 'fast';
                if (wave >= 5 && roll < 0.15) enemyType = 'shooter';
                if (wave >= 7 && roll < 0.12) enemyType = 'sniper';
                if (wave >= 9 && roll < 0.1) enemyType = 'artillery';
                if (wave >= 9 && roll < 0.15) enemyType = 'tank';
                if (wave >= 11 && roll < 0.08) enemyType = 'swarm';
                if (wave >= 15 && roll < 0.05) enemyType = 'boss';

                const stats = {
                    basic: { health: 40 + wave * 5, speed: 0.9, size: 12, color: 0xff5555, damage: 8, canShoot: true, range: 5, fireCooldown: 400, bulletSpeed: 9, useLaser: false },
                    fast: { health: 20 + wave * 3, speed: 1.8, size: 10, color: 0xffaa00, damage: 50, canShoot: false, isKamikaze: true, explosionRange: 1.5, useLaser: false },
                    shooter: { health: 30 + wave * 4, speed: 0.7, size: 11, color: 0xff8844, damage: 12, canShoot: true, range: 6, fireCooldown: 400, bulletSpeed: 10, useLaser: false },
                    sniper: { health: 25 + wave * 3, speed: 0.5, size: 10, color: 0x8844ff, damage: 18, canShoot: true, range: 10, fireCooldown: 1200, bulletSpeed: 14, useLaser: true, laserColor: 0x8844ff },
                    artillery: { health: 60 + wave * 6, speed: 0.3, size: 16, color: 0x448844, damage: 15, canShoot: true, range: 12, fireCooldown: 400, bulletSpeed: 8, splash: true, useLaser: false },
                    tank: { health: 100 + wave * 12, speed: 0.35, size: 18, color: 0x884444, damage: 20, canShoot: true, range: 6, fireCooldown: 800, bulletSpeed: 10, useLaser: true, laserColor: 0xff4444 },
                    swarm: { health: 15 + wave * 2, speed: 2.2, size: 8, color: 0xff88ff, damage: 35, canShoot: false, isKamikaze: true, explosionRange: 1, useLaser: false },
                    boss: { health: 300 + wave * 25, speed: 0.25, size: 26, color: 0xff0000, damage: 25, canShoot: true, range: 9, fireCooldown: 600, bulletSpeed: 12, useLaser: true, laserColor: 0xff0000 }
                }[enemyType];

                enemies.push({
                    x: spawnX,
                    y: spawnY,
                    ...stats,
                    maxHealth: stats.health,
                    type: enemyType,
                    delay: i * 300,
                    fireCooldownMax: stats.fireCooldown || 0,
                    lastFire: 0,
                    bulletSpeed: stats.bulletSpeed || 4,
                    splash: stats.splash || false,
                    useLaser: stats.useLaser || false,
                    laserColor: stats.laserColor || 0xff0000,
                    targetBuilding: null,
                    laserActive: false, // Track if laser is currently firing
                    laserTarget: null // Store laser target position
                });
            }
        }

        function updateResourceUI() {
            document.getElementById('copper-count').textContent = resources.copper || 0;
            document.getElementById('lead-count').textContent = resources.lead || 0;
            document.getElementById('coal-count').textContent = resources.coal || 0;
            document.getElementById('titanium-count').textContent = resources.titanium || 0;
            document.getElementById('graphite-count').textContent = resources.graphite || 0;
            document.getElementById('alloy-count').textContent = resources.alloy || 0;
            document.getElementById('sand-count').textContent = resources.sand || 0;
            renderBuildingGrid();
        }

        function updatePlayerHealthUI() {
            const pct = Math.max(0, (player.health / player.maxHealth) * 100);
            document.getElementById('player-health-fill').style.width = pct + '%';
            if (player.respawnTimer > 0) {
                document.getElementById('player-health-text').textContent = 'Respawn: ' + Math.ceil(player.respawnTimer / 1000) + 's';
            } else {
                document.getElementById('player-health-text').textContent = 'Ship: ' + Math.ceil(pct) + '%';
            }
        }

        function respawnPlayer() {
            player.deaths++;
            player.respawnTimer = 3000; // 3 second respawn
            player.health = 0;

            // Big explosion effect
            spawnParticles(player.x, player.y, 0xff4400, 20);
            spawnParticles(player.x, player.y, 0xffff00, 15);
            spawnParticles(player.x, player.y, 0xff0000, 10);

            updatePlayerHealthUI();
        }

        function completeRespawn() {
            // Respawn at core
            const core = buildings.find(b => b.type === 'core');
            if (core) {
                player.x = (core.x + 1.5) * TILE_SIZE;
                player.y = (core.y + 1.5) * TILE_SIZE;
            }

            player.health = player.maxHealth;
            player.respawnTimer = 0;
            player.invulnerable = 2000; // 2 seconds of invulnerability

            // Respawn particles
            spawnParticles(player.x, player.y, 0x44ff44, 15);
            spawnParticles(player.x, player.y, 0xffffff, 10);

            updatePlayerHealthUI();
        }

        // Maximum particles for performance optimization
        const MAX_PARTICLES = 300;  // Increased for larger map

        function spawnParticles(x, y, color, count) {
            // Reduce particle count for performance (max 5 per spawn)
            count = Math.min(count, 5);

            // Don't spawn if already at max - remove oldest particles if needed
            if (particles.length >= MAX_PARTICLES) {
                // Remove oldest particles to make room
                particles.splice(0, Math.min(count, particles.length - MAX_PARTICLES + count));
            }

            for (let i = 0; i < count; i++) {
                if (particles.length >= MAX_PARTICLES) break;
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 25, // Slightly shorter life for performance
                    color: color,
                    size: 2 + Math.random() * 2
                });
            }
        }

        function update(time, delta) {
            // Cache timestamp for performance
            const now = Date.now();

            // Update spatial grid for optimized collision detection (every frame)
            updateSpatialGrid();

            // FPS counter update (every 500ms)
            frameCount++;
            if (now - lastFPSUpdate >= 500) {
                lastFPS = Math.round(frameCount * 1000 / (now - lastFPSUpdate));
                frameCount = 0;
                lastFPSUpdate = now;
                const fpsEl = document.getElementById('fps-counter');
                fpsEl.textContent = `FPS: ${lastFPS} | GPU: WebGL`;
                fpsEl.className = lastFPS < 30 ? 'low' : (lastFPS < 50 ? 'medium' : '');
            }

            if (gameOver) {
                graphics.clear();
                graphics.fillStyle(0xff0000, 0.5);
                graphics.fillRect(0, 0, window.innerWidth, window.innerHeight);
                return;
            }

            // Handle respawn timer
            if (player.respawnTimer > 0) {
                player.respawnTimer -= delta;
                if (player.respawnTimer <= 0) {
                    completeRespawn();
                }
                updatePlayerHealthUI();
            }

            // Handle invulnerability timer
            if (player.invulnerable > 0) {
                player.invulnerable -= delta;
            }

            // Handle mining cooldown and auto-mine when in mining mode
            if (miningCooldown > 0) {
                miningCooldown -= delta;
            }
            if (miningMode && miningCooldown <= 0 && player.respawnTimer <= 0) {
                manualMine();
                miningCooldown = 200; // Mine every 200ms (faster)
            }

            // Player movement (only if alive)
            if (player.respawnTimer <= 0) {
                let moveX = 0;
                let moveY = 0;

                if (keys.W.isDown) moveY -= player.speed;
                if (keys.S.isDown) moveY += player.speed;
                if (keys.A.isDown) moveX -= player.speed;
                if (keys.D.isDown) moveX += player.speed;

                // Update position
                player.x += moveX;
                player.y += moveY;

                // Update angle based on movement direction
                if (moveX !== 0 || moveY !== 0) {
                    player.angle = Math.atan2(moveY, moveX);
                }

                // Clamp player to map bounds
                player.x = Math.max(TILE_SIZE, Math.min(MAP_WIDTH * TILE_SIZE - TILE_SIZE, player.x));
                player.y = Math.max(TILE_SIZE, Math.min(MAP_HEIGHT * TILE_SIZE - TILE_SIZE, player.y));

                // Player shooting - hold left mouse button to shoot (when no building selected)
                if (player.fireCooldown > 0) {
                    player.fireCooldown -= delta;
                }

                const pointer = scene.input.activePointer;
                if (pointer.isDown && pointer.leftButtonDown() && !selectedBuilding && !isDragging && !miningMode && player.fireCooldown <= 0) {
                    // Calculate target position in world coordinates
                    const targetWorld = screenToWorld(pointer.x, pointer.y);

                    // Calculate angle to mouse
                    const dx = targetWorld.x - player.x;
                    const dy = targetWorld.y - player.y;
                    const angle = Math.atan2(dy, dx);

                    // Update player angle to face the shooting direction
                    player.angle = angle;

                    // Spawn bullet from front of ship
                    const bulletStartX = player.x + Math.cos(angle) * 20;
                    const bulletStartY = player.y + Math.sin(angle) * 20;

                    playerBullets.push({
                        x: bulletStartX,
                        y: bulletStartY,
                        vx: Math.cos(angle) * player.bulletSpeed,
                        vy: Math.sin(angle) * player.bulletSpeed,
                        damage: player.bulletDamage,
                        life: 60 // frames before despawn
                    });

                    // Muzzle flash particles
                    spawnParticles(bulletStartX, bulletStartY, 0xffff00, 3);

                    player.fireCooldown = player.fireCooldownMax;
                }
            }

            // Camera follows player (adjusted for zoom)
            const viewWidth = window.innerWidth / zoom;
            const viewHeight = window.innerHeight / zoom;
            camera.x = player.x - viewWidth / 2;
            camera.y = player.y - viewHeight / 2;

            // Clamp camera
            camera.x = Math.max(0, Math.min(MAP_WIDTH * TILE_SIZE - viewWidth, camera.x));
            camera.y = Math.max(0, Math.min(MAP_HEIGHT * TILE_SIZE - viewHeight, camera.y));

            graphics.clear();

            // Apply zoom - scale graphics and reset position
            graphics.setScale(zoom);
            graphics.setPosition(0, 0);

            // Calculate visible tile range (adjusted for zoom)
            const startTileX = Math.max(0, Math.floor(camera.x / TILE_SIZE) - 1);
            const startTileY = Math.max(0, Math.floor(camera.y / TILE_SIZE) - 1);
            const endTileX = Math.min(MAP_WIDTH, Math.ceil((camera.x + viewWidth) / TILE_SIZE) + 1);
            const endTileY = Math.min(MAP_HEIGHT, Math.ceil((camera.y + viewHeight) / TILE_SIZE) + 1);

            // OPTIMIZED terrain rendering with GPU-friendly batching
            // Pre-calculate animated values once per frame
            const waterTime = time * 0.001;

            // Batch terrain by type for fewer state changes
            // First pass: Draw all base tiles (most efficient)
            for (let y = startTileY; y < endTileY; y++) {
                for (let x = startTileX; x < endTileX; x++) {
                    const screenX = x * TILE_SIZE - camera.x;
                    const screenY = y * TILE_SIZE - camera.y;
                    const terrain = terrainMap[y][x];
                    const checker = (x + y) % 2;

                    // Base colors - simple fills are fastest
                    let baseColor;
                    switch (terrain) {
                        case TERRAIN.GRASS:
                            baseColor = checker ? 0x2a4528 : 0x243d22;
                            break;
                        case TERRAIN.SAND:
                            baseColor = checker ? 0x9a8060 : 0x8a7050;
                            break;
                        case TERRAIN.WATER:
                            baseColor = checker ? 0x1a4488 : 0x153a78;
                            break;
                        case TERRAIN.STONE:
                            baseColor = checker ? 0x5a5a6a : 0x505060;
                            break;
                        case TERRAIN.DARK_STONE:
                            baseColor = checker ? 0x3a3a48 : 0x32323e;
                            break;
                        default:
                            baseColor = 0x2d4a2d;
                    }
                    graphics.fillStyle(baseColor, 1);
                    graphics.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                }
            }

            // Second pass: Add details only to visible special tiles (sparse)
            for (let y = startTileY; y < endTileY; y++) {
                for (let x = startTileX; x < endTileX; x++) {
                    const screenX = x * TILE_SIZE - camera.x;
                    const screenY = y * TILE_SIZE - camera.y;
                    const terrain = terrainMap[y][x];
                    const seed = (x * 73 + y * 97) % 256;

                    switch (terrain) {
                        case TERRAIN.GRASS:
                            // Sparse grass details (only 1 in 3 tiles)
                            if (seed % 3 === 0) {
                                graphics.fillStyle(0x3a5a35, 0.6);
                                graphics.fillRect(screenX + 8 + (seed % 12), screenY + 6, 2, 5);
                                graphics.fillRect(screenX + 18 + (seed % 8), screenY + 10, 2, 4);
                            }
                            break;

                        case TERRAIN.SAND:
                            // Sand ripple (every tile, simple)
                            graphics.fillStyle(0xaa9070, 0.25);
                            graphics.fillRect(screenX, screenY + 10 + (seed % 10), TILE_SIZE, 2);
                            break;

                        case TERRAIN.WATER:
                            // Animated water highlight - most complex but worth it
                            const waveX = screenX + 16 + Math.sin(waterTime + x * 0.8) * 8;
                            const waveY = screenY + 16 + Math.cos(waterTime * 0.7 + y * 0.6) * 8;
                            graphics.fillStyle(0x3366bb, 0.35);
                            graphics.fillCircle(waveX, waveY, 5);
                            // Wave line
                            graphics.fillStyle(0x4477cc, 0.2);
                            graphics.fillRect(screenX + 2, screenY + 14 + Math.sin(waterTime + x) * 3, TILE_SIZE - 4, 2);
                            break;

                        case TERRAIN.STONE:
                            // Stone crack (sparse)
                            if (seed % 2 === 0) {
                                graphics.fillStyle(0x404050, 0.5);
                                graphics.fillRect(screenX + 6 + (seed % 10), screenY, 1, TILE_SIZE);
                            }
                            break;

                        case TERRAIN.DARK_STONE:
                            // Grid lines only
                            graphics.fillStyle(0x2a2a38, 0.4);
                            graphics.fillRect(screenX, screenY, TILE_SIZE, 1);
                            graphics.fillRect(screenX, screenY, 1, TILE_SIZE);
                            // Rivet on every 4th tile
                            if ((x % 4 === 0) && (y % 4 === 0)) {
                                graphics.fillStyle(0x505058);
                                graphics.fillCircle(screenX + 4, screenY + 4, 2);
                            }
                            break;
                    }
                }
            }

            // Draw ore deposits (enhanced visibility)
            for (let y = startTileY; y < endTileY; y++) {
                for (let x = startTileX; x < endTileX; x++) {
                    if (oreMap[y][x]) {
                        const screenX = x * TILE_SIZE - camera.x;
                        const screenY = y * TILE_SIZE - camera.y;
                        const ore = oreMap[y][x];
                        const color = getOreColor(ore);

                        // Outer glow for better visibility
                        graphics.fillStyle(color, 0.25);
                        graphics.fillRoundedRect(screenX + 1, screenY + 1, TILE_SIZE - 2, TILE_SIZE - 2, 4);

                        // Base ore patch (larger and more opaque)
                        graphics.fillStyle(color, 0.6);
                        graphics.fillRoundedRect(screenX + 3, screenY + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                        // Crystal texture (more crystals for visibility)
                        const seed = x * 13 + y * 17;
                        const numCrystals = ore === 'titanium' ? 5 : (ore === 'coal' ? 4 : 4);

                        for (let i = 0; i < numCrystals; i++) {
                            const cx = screenX + 6 + ((seed * (i + 1) * 7) % (TILE_SIZE - 12));
                            const cy = screenY + 6 + ((seed * (i + 1) * 11) % (TILE_SIZE - 12));
                            const size = 3 + ((seed * i) % 4);

                            graphics.fillStyle(color, 1.0);
                            graphics.fillCircle(cx, cy, size);

                            // Highlight on crystals
                            graphics.fillStyle(0xffffff, 0.4);
                            graphics.fillCircle(cx - 1, cy - 1, size * 0.4);
                        }

                        // Enhanced ore-specific details
                        if (ore === 'copper') {
                            // Copper veins
                            graphics.fillStyle(0xffcc88, 0.5);
                            graphics.fillRect(screenX + 5, screenY + TILE_SIZE/2 - 1, TILE_SIZE - 10, 3);
                            graphics.fillRect(screenX + TILE_SIZE/2 - 1, screenY + 5, 3, TILE_SIZE - 10);
                        } else if (ore === 'lead') {
                            // Lead striations
                            graphics.fillStyle(0xcccccc, 0.5);
                            graphics.fillRect(screenX + 5, screenY + 8, TILE_SIZE - 10, 2);
                            graphics.fillRect(screenX + 5, screenY + TILE_SIZE - 10, TILE_SIZE - 10, 2);
                        } else if (ore === 'titanium') {
                            // Titanium glow
                            graphics.fillStyle(0x88ccff, 0.4);
                            graphics.fillCircle(screenX + TILE_SIZE/2, screenY + TILE_SIZE/2, 8);
                            graphics.fillStyle(0xaaddff, 0.6);
                            graphics.fillCircle(screenX + TILE_SIZE/2, screenY + TILE_SIZE/2, 5);
                        } else if (ore === 'coal') {
                            // Coal dark center
                            graphics.fillStyle(0x222222, 0.6);
                            graphics.fillRoundedRect(screenX + 8, screenY + 8, TILE_SIZE - 16, TILE_SIZE - 16, 3);
                        }

                        // Border outline for all ores
                        graphics.lineStyle(1, color, 0.8);
                        graphics.strokeRoundedRect(screenX + 2, screenY + 2, TILE_SIZE - 4, TILE_SIZE - 4, 4);
                    }
                }
            }

            // Draw spawn point indicator
            const spawnScreenX = spawnPoint.x * TILE_SIZE - camera.x;
            const spawnScreenY = spawnPoint.y * TILE_SIZE - camera.y;
            const pulse = Math.sin(time / 300) * 0.3 + 0.5;
            graphics.fillStyle(0xff0000, pulse * 0.3);
            graphics.fillCircle(spawnScreenX + TILE_SIZE/2, spawnScreenY + TILE_SIZE/2, TILE_SIZE * 2);
            graphics.lineStyle(2, 0xff0000, pulse);
            graphics.strokeCircle(spawnScreenX + TILE_SIZE/2, spawnScreenY + TILE_SIZE/2, TILE_SIZE * 1.5);

            // Draw construction queue (semi-transparent ghosts)
            constructionQueue.forEach(b => {
                const screenX = b.x * TILE_SIZE - camera.x;
                const screenY = b.y * TILE_SIZE - camera.y;
                const width = (b.width || 1) * TILE_SIZE;
                const height = (b.height || 1) * TILE_SIZE;

                // Only draw if on screen
                if (screenX > -TILE_SIZE * 2 && screenX < window.innerWidth + TILE_SIZE &&
                    screenY > -TILE_SIZE * 2 && screenY < window.innerHeight + TILE_SIZE) {

                    const buildTime = BUILDINGS[b.type].buildTime || 1;
                    const progress = Math.min(1, b.buildProgress / buildTime);

                    // Semi-transparent white/blue tint for ghost
                    graphics.fillStyle(0x88ccff, 0.3);
                    graphics.fillRect(screenX, screenY, width, height);

                    // Border
                    graphics.lineStyle(2, 0x88ccff, 0.6);
                    graphics.strokeRect(screenX, screenY, width, height);

                    // Progress bar
                    const barHeight = 4;
                    const barY = screenY + height + 4;
                    graphics.fillStyle(0x333333, 0.8);
                    graphics.fillRect(screenX, barY, width, barHeight);
                    graphics.fillStyle(0x44ff44, 0.9);
                    graphics.fillRect(screenX, barY, width * progress, barHeight);
                }
            });

            // Draw buildings
            buildings.forEach(b => {
                // Skip tile references - only draw master buildings
                if (b.isTileRef) return;

                const screenX = b.x * TILE_SIZE - camera.x;
                const screenY = b.y * TILE_SIZE - camera.y;

                // Only draw if on screen
                if (screenX > -TILE_SIZE * 2 && screenX < window.innerWidth + TILE_SIZE &&
                    screenY > -TILE_SIZE * 2 && screenY < window.innerHeight + TILE_SIZE) {
                    drawBuilding(b, screenX, screenY);
                }
            });

            // Update items smoothly every frame
            updateItems();

            // Update miners with intelligent pathfinding and inventory system
            for (let i = miners.length - 1; i >= 0; i--) {
                const miner = miners[i];

                // Initialize state if not set (for backwards compatibility)
                if (!miner.state) miner.state = 'mining';
                if (!miner.inventory) miner.inventory = 0;
                if (!miner.maxInventory) miner.maxInventory = 30;

                // Find the core for returning
                const core = buildings.find(b => b.type === 'core');

                // Determine target based on state
                let targetWorldX, targetWorldY;
                if (miner.state === 'returning' && core) {
                    // Return to core center
                    targetWorldX = (core.x + 1.5) * TILE_SIZE;
                    targetWorldY = (core.y + 1.5) * TILE_SIZE;
                } else {
                    // Go to ore
                    targetWorldX = miner.targetX * TILE_SIZE + TILE_SIZE / 2;
                    targetWorldY = miner.targetY * TILE_SIZE + TILE_SIZE / 2;
                }

                // Move towards target but stop at a distance to show laser better
                const dx = targetWorldX - miner.x;
                const dy = targetWorldY - miner.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const interactionDistance = miner.state === 'returning' ? TILE_SIZE * 2 : TILE_SIZE * 1.5;
                const minerRadius = 14; // Collision radius for miners
                const avoidanceRadius = minerRadius * 4; // Increased detection radius for better avoidance

                if (dist > interactionDistance) {
                    // Calculate base movement direction
                    const speed = miner.state === 'returning' ? 3.5 : 2.5; // Faster when returning
                    let moveX = (dx / dist) * speed;
                    let moveY = (dy / dist) * speed;

                    // Pathfinding: check for other miners and calculate avoidance
                    let avoidX = 0;
                    let avoidY = 0;
                    let nearbyMinerCount = 0;

                    for (let j = 0; j < miners.length; j++) {
                        if (i === j) continue;
                        const other = miners[j];
                        const odx = miner.x - other.x;
                        const ody = miner.y - other.y;
                        const oDist = Math.sqrt(odx * odx + ody * ody);

                        // If within avoidance radius, calculate steering force
                        if (oDist < avoidanceRadius && oDist > 0) {
                            nearbyMinerCount++;
                            // Stronger avoidance when closer
                            const avoidStrength = 1 - (oDist / avoidanceRadius);
                            const avoidForce = avoidStrength * avoidStrength * 4; // Increased force
                            avoidX += (odx / oDist) * avoidForce;
                            avoidY += (ody / oDist) * avoidForce;
                        }
                    }

                    // Apply avoidance steering with improved algorithm
                    if (nearbyMinerCount > 0) {
                        const avoidMag = Math.sqrt(avoidX * avoidX + avoidY * avoidY);
                        if (avoidMag > 0) {
                            // Calculate two perpendicular directions
                            const perpX1 = -moveY;
                            const perpY1 = moveX;
                            const perpX2 = moveY;
                            const perpY2 = -moveX;

                            // Dot product with avoidance to choose better perpendicular
                            const dot1 = perpX1 * avoidX + perpY1 * avoidY;
                            const dot2 = perpX2 * avoidX + perpY2 * avoidY;

                            let steerX, steerY;
                            if (dot1 > dot2) {
                                steerX = perpX1 * 0.6 + avoidX / avoidMag * 0.4;
                                steerY = perpY1 * 0.6 + avoidY / avoidMag * 0.4;
                            } else {
                                steerX = perpX2 * 0.6 + avoidX / avoidMag * 0.4;
                                steerY = perpY2 * 0.6 + avoidY / avoidMag * 0.4;
                            }

                            // Blend original movement with steering based on urgency
                            // Miners at same ore node should steer more aggressively
                            const sameTargetCount = miners.filter((m, idx) =>
                                idx !== i && m.targetX === miner.targetX && m.targetY === miner.targetY && m.state === 'mining'
                            ).length;
                            const urgency = Math.min(0.9, nearbyMinerCount * 0.3 + sameTargetCount * 0.2);
                            moveX = moveX * (1 - urgency) + steerX * speed * urgency;
                            moveY = moveY * (1 - urgency) + steerY * speed * urgency;
                        }
                    }

                    // Calculate new position
                    let newX = miner.x + moveX;
                    let newY = miner.y + moveY;

                    // Hard collision resolution - ensure no overlap with increased push
                    for (let j = 0; j < miners.length; j++) {
                        if (i === j) continue;
                        const other = miners[j];
                        const odx = newX - other.x;
                        const ody = newY - other.y;
                        const oDist = Math.sqrt(odx * odx + ody * ody);

                        if (oDist < minerRadius * 2.5) {
                            // Collision! Push apart more aggressively
                            const overlap = minerRadius * 2.5 - oDist;
                            if (oDist > 0.1) {
                                // Add some randomness to break deadlocks
                                const jitter = (Math.random() - 0.5) * 0.3;
                                newX += (odx / oDist + jitter) * overlap * 0.7;
                                newY += (ody / oDist + jitter) * overlap * 0.7;
                            } else {
                                // Nearly overlapping, push in random direction
                                const randAngle = Math.random() * Math.PI * 2;
                                newX += Math.cos(randAngle) * overlap * 1.5;
                                newY += Math.sin(randAngle) * overlap * 1.5;
                            }
                        }
                    }

                    // Keep within map bounds
                    newX = Math.max(TILE_SIZE, Math.min(MAP_WIDTH * TILE_SIZE - TILE_SIZE, newX));
                    newY = Math.max(TILE_SIZE, Math.min(MAP_HEIGHT * TILE_SIZE - TILE_SIZE, newY));

                    // Store movement direction for visual feedback
                    miner.moveAngle = Math.atan2(newY - miner.y, newX - miner.x);
                    miner.isMoving = true;

                    miner.x = newX;
                    miner.y = newY;
                } else {
                    // At target - either mining or depositing
                    miner.isMoving = false;

                    if (miner.state === 'returning' && core) {
                        // Deposit resources to core
                        if (miner.inventory > 0) {
                            resources[miner.oreType] = (resources[miner.oreType] || 0) + miner.inventory;
                            updateResourceUI();
                            spawnParticles(miner.x, miner.y, getOreColor(miner.oreType), 5);
                            miner.inventory = 0;
                        }

                        // Decide what to mine next based on current resource balance
                        const newTargetType = (resources.copper || 0) > (resources.lead || 0) ? 'lead' : 'copper';
                        const newTarget = findBestOreNode(miner.x / TILE_SIZE, miner.y / TILE_SIZE, newTargetType);

                        if (newTarget) {
                            miner.targetX = newTarget.x;
                            miner.targetY = newTarget.y;
                            miner.oreType = newTarget.type;
                        } else {
                            // Try the other ore type
                            const fallbackType = newTargetType === 'copper' ? 'lead' : 'copper';
                            const fallbackTarget = findBestOreNode(miner.x / TILE_SIZE, miner.y / TILE_SIZE, fallbackType);
                            if (fallbackTarget) {
                                miner.targetX = fallbackTarget.x;
                                miner.targetY = fallbackTarget.y;
                                miner.oreType = fallbackTarget.type;
                            }
                        }

                        miner.state = 'mining';
                    } else {
                        // Mining ore
                        miner.miningCooldown -= delta;
                        if (miner.miningCooldown <= 0) {
                            miner.miningCooldown = 800; // Mine every 0.8 seconds
                            miner.inventory++;
                            spawnParticles(targetWorldX, targetWorldY, getOreColor(miner.oreType), 2);

                            // Check if inventory is full
                            if (miner.inventory >= miner.maxInventory) {
                                miner.state = 'returning';
                            }
                        }
                    }
                }

                // Check if miner is damaged by enemies
                enemies.forEach(e => {
                    const edx = e.x - miner.x;
                    const edy = e.y - miner.y;
                    const eDist = Math.sqrt(edx * edx + edy * edy);
                    if (eDist < TILE_SIZE) {
                        miner.health -= 0.1; // Damage over time
                    }
                });

                // Remove dead miners
                if (miner.health <= 0) {
                    spawnParticles(miner.x, miner.y, 0xff4444, 10);
                    miners.splice(i, 1);
                }
            }

            // Draw items using world coordinates
            items.forEach(item => {
                const screenX = item.worldX - camera.x;
                const screenY = item.worldY - camera.y;

                // Only draw if on screen
                if (screenX > -10 && screenX < window.innerWidth + 10 &&
                    screenY > -10 && screenY < window.innerHeight + 10) {
                    graphics.fillStyle(getOreColor(item.type));
                    graphics.fillCircle(screenX, screenY, 5);
                    // Add a small highlight for 3D effect
                    graphics.fillStyle(0xffffff, 0.3);
                    graphics.fillCircle(screenX - 1, screenY - 1, 2);
                }
            });

            // Draw miners with enhanced visuals
            miners.forEach(miner => {
                const screenX = miner.x - camera.x;
                const screenY = miner.y - camera.y;

                if (screenX > -20 && screenX < window.innerWidth + 20 &&
                    screenY > -20 && screenY < window.innerHeight + 20) {

                    const isReturning = miner.state === 'returning';
                    const core = buildings.find(b => b.type === 'core');

                    // Determine target based on state
                    let targetWorldX, targetWorldY;
                    if (isReturning && core) {
                        targetWorldX = (core.x + 1.5) * TILE_SIZE;
                        targetWorldY = (core.y + 1.5) * TILE_SIZE;
                    } else {
                        targetWorldX = miner.targetX * TILE_SIZE + TILE_SIZE / 2;
                        targetWorldY = miner.targetY * TILE_SIZE + TILE_SIZE / 2;
                    }
                    const distToTarget = Math.sqrt((miner.x - targetWorldX)**2 + (miner.y - targetWorldY)**2);
                    const interactionDistance = isReturning ? TILE_SIZE * 2 : TILE_SIZE * 1.5;

                    // Draw mining laser when at target (only when mining, not returning)
                    if (!isReturning && distToTarget <= interactionDistance) {
                        const targetScreenX = targetWorldX - camera.x;
                        const targetScreenY = targetWorldY - camera.y;
                        const laserPulse = Math.sin(Date.now() / 80) * 0.3 + 0.7;

                        // Outer glow (green) - wider
                        graphics.lineStyle(12, 0x00ff00, laserPulse * 0.3);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Middle glow - brighter
                        graphics.lineStyle(6, 0x44ff44, laserPulse * 0.7);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Core beam - very bright
                        graphics.lineStyle(3, 0xccffcc, laserPulse * 0.95);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Impact effect at target - larger and brighter
                        graphics.fillStyle(0x00ff00, laserPulse * 0.7);
                        graphics.fillCircle(targetScreenX, targetScreenY, 10);
                        graphics.fillStyle(0xffffff, laserPulse * 0.6);
                        graphics.fillCircle(targetScreenX, targetScreenY, 5);
                    }

                    // Animated propeller speed based on movement
                    const propSpeed = miner.isMoving ? 30 : 80;
                    const propAngle = (Date.now() / propSpeed) % (Math.PI * 2);

                    // Drone shadow for depth
                    graphics.fillStyle(0x000000, 0.2);
                    graphics.fillEllipse(screenX + 2, screenY + 12, 10, 4);

                    // Miner body (quadcopter drone design)
                    // Main body color changes based on state - yellow when returning
                    const bodyColor = isReturning ? 0x8a8a3a : 0x3a8a3a;
                    const highlightColor = isReturning ? 0xaaaa5a : 0x5aaa5a;
                    const coreColor = isReturning ? 0xffff88 : 0x88ff88;

                    graphics.fillStyle(bodyColor);
                    graphics.fillRoundedRect(screenX - 7, screenY - 5, 14, 10, 3);

                    // Body highlight
                    graphics.fillStyle(highlightColor, 0.6);
                    graphics.fillRect(screenX - 5, screenY - 4, 10, 3);

                    // Central core light
                    const corePulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;
                    graphics.fillStyle(coreColor, corePulse);
                    graphics.fillCircle(screenX, screenY, 3);

                    // Propeller arms
                    graphics.fillStyle(0x444444);
                    graphics.fillRect(screenX - 12, screenY - 2, 6, 4);
                    graphics.fillRect(screenX + 6, screenY - 2, 6, 4);
                    graphics.fillRect(screenX - 2, screenY - 10, 4, 6);
                    graphics.fillRect(screenX - 2, screenY + 4, 4, 6);

                    // Propeller motors
                    graphics.fillStyle(0x555555);
                    graphics.fillCircle(screenX - 10, screenY, 4);
                    graphics.fillCircle(screenX + 10, screenY, 4);
                    graphics.fillCircle(screenX, screenY - 8, 4);
                    graphics.fillCircle(screenX, screenY + 8, 4);

                    // Spinning propeller blades
                    graphics.lineStyle(2, 0xaaaaaa, 0.8);
                    const bladeLength = 5;
                    // Top-left prop
                    graphics.lineBetween(
                        screenX - 10 + Math.cos(propAngle) * bladeLength,
                        screenY + Math.sin(propAngle) * bladeLength,
                        screenX - 10 - Math.cos(propAngle) * bladeLength,
                        screenY - Math.sin(propAngle) * bladeLength
                    );
                    // Top-right prop
                    graphics.lineBetween(
                        screenX + 10 + Math.cos(-propAngle) * bladeLength,
                        screenY + Math.sin(-propAngle) * bladeLength,
                        screenX + 10 - Math.cos(-propAngle) * bladeLength,
                        screenY - Math.sin(-propAngle) * bladeLength
                    );
                    // Front prop
                    graphics.lineBetween(
                        screenX + Math.cos(propAngle + Math.PI/4) * bladeLength,
                        screenY - 8 + Math.sin(propAngle + Math.PI/4) * bladeLength,
                        screenX - Math.cos(propAngle + Math.PI/4) * bladeLength,
                        screenY - 8 - Math.sin(propAngle + Math.PI/4) * bladeLength
                    );
                    // Back prop
                    graphics.lineBetween(
                        screenX + Math.cos(-propAngle - Math.PI/4) * bladeLength,
                        screenY + 8 + Math.sin(-propAngle - Math.PI/4) * bladeLength,
                        screenX - Math.cos(-propAngle - Math.PI/4) * bladeLength,
                        screenY + 8 - Math.sin(-propAngle - Math.PI/4) * bladeLength
                    );

                    // Mining laser emitter (points toward target when mining)
                    if (!isReturning && distToTarget <= interactionDistance) {
                        const aimAngle = Math.atan2(targetWorldY - miner.y, targetWorldX - miner.x);
                        graphics.fillStyle(0x44ff44);
                        graphics.fillCircle(
                            screenX + Math.cos(aimAngle) * 6,
                            screenY + Math.sin(aimAngle) * 6,
                            2
                        );
                    }

                    // Cargo indicator (show ore type color when carrying resources)
                    if (miner.inventory && miner.inventory > 0) {
                        const oreColor = getOreColor(miner.oreType);
                        graphics.fillStyle(oreColor, 0.9);
                        graphics.fillCircle(screenX, screenY + 2, 4);
                        // Show fill level with size
                        const fillPct = miner.inventory / miner.maxInventory;
                        graphics.fillStyle(0xffffff, 0.5);
                        graphics.fillCircle(screenX, screenY + 2, 2 * fillPct);
                    }

                    // Health bar with border
                    const healthPct = miner.health / miner.maxHealth;
                    graphics.fillStyle(0x222222);
                    graphics.fillRect(screenX - 11, screenY + 14, 22, 5);
                    graphics.fillStyle(0x333333);
                    graphics.fillRect(screenX - 10, screenY + 15, 20, 3);
                    const healthColor = healthPct > 0.6 ? 0x4CAF50 : (healthPct > 0.3 ? 0xffaa00 : 0xff4444);
                    graphics.fillStyle(healthColor);
                    graphics.fillRect(screenX - 10, screenY + 15, 20 * healthPct, 3);

                    // Inventory bar (below health bar)
                    const invPct = (miner.inventory || 0) / (miner.maxInventory || 30);
                    graphics.fillStyle(0x222222);
                    graphics.fillRect(screenX - 11, screenY + 20, 22, 4);
                    graphics.fillStyle(0x333333);
                    graphics.fillRect(screenX - 10, screenY + 21, 20, 2);
                    graphics.fillStyle(getOreColor(miner.oreType));
                    graphics.fillRect(screenX - 10, screenY + 21, 20 * invPct, 2);
                }
            });

            // Update and draw enemies
            const core = buildings.find(b => b.type === 'core');
            enemies.forEach((enemy, idx) => {
                if (enemy.delay > 0) {
                    enemy.delay -= delta;
                    return;
                }

                // Find target - priority system: transport < defense < power < production < core
                // Also attack anything in the way
                let targetX, targetY;
                let targetBuilding = null;
                let minDist = Infinity;
                let highestPriority = -1;
                
                const getPriority = (building) => {
                    if (building.isTileRef) building = building.master;
                    if (!building) return -1;
                    const category = BUILDINGS[building.type]?.category;
                    if (building.type === 'core') return 5; // Highest priority
                    if (category === 'production') return 4;
                    if (category === 'power') return 3;
                    if (category === 'defense') return 2;
                    if (category === 'transport') return 1;
                    return 0;
                };

                // Find highest priority target within 5 tile radius
                const SEARCH_RADIUS = TILE_SIZE * 5;
                
                buildings.forEach(b => {
                    if (b.isTileRef) return; // Skip tile refs, we'll handle via master
                    
                    const bx = b.x * TILE_SIZE + TILE_SIZE/2;
                    const by = b.y * TILE_SIZE + TILE_SIZE/2;
                    const dist = Math.sqrt((enemy.x - bx)**2 + (enemy.y - by)**2);
                    
                    // Only consider buildings within 5 tile radius
                    if (dist > SEARCH_RADIUS) return;
                    
                    const priority = getPriority(b);
                    
                    // Prioritize by: 1) Priority level, 2) Distance for same priority
                    if (priority > highestPriority || (priority === highestPriority && dist < minDist)) {
                        highestPriority = priority;
                        minDist = dist;
                        targetBuilding = b;
                        targetX = bx;
                        targetY = by;
                    }
                });

                // If no target found in radius, default to core
                if (!targetBuilding && core) {
                    targetX = (core.x + 1.5) * TILE_SIZE;
                    targetY = (core.y + 1.5) * TILE_SIZE;
                    targetBuilding = core;
                }

                enemy.targetBuilding = targetBuilding;

                // Move towards target
                const dx = targetX - enemy.x;
                const dy = targetY - enemy.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Attack anything in the way (within 1 tile) - or explode if kamikaze
                buildings.forEach(b => {
                    if (b.isTileRef) return;
                    const bx = b.x * TILE_SIZE + TILE_SIZE/2;
                    const by = b.y * TILE_SIZE + TILE_SIZE/2;
                    const distToBuilding = Math.sqrt((enemy.x - bx)**2 + (enemy.y - by)**2);

                    // Kamikaze enemies explode on contact with buildings
                    if (enemy.isKamikaze && distToBuilding < TILE_SIZE * 0.8) {
                        // Deal damage to building
                        b.health -= enemy.damage;

                        // Damage nearby buildings in explosion range
                        const expRange = (enemy.explosionRange || 1) * TILE_SIZE;
                        buildings.forEach(nearbyB => {
                            if (nearbyB.isTileRef) return;
                            const nbx = nearbyB.x * TILE_SIZE + TILE_SIZE/2;
                            const nby = nearbyB.y * TILE_SIZE + TILE_SIZE/2;
                            const distToNearby = Math.sqrt((enemy.x - nbx)**2 + (enemy.y - nby)**2);
                            if (distToNearby < expRange && nearbyB !== b) {
                                const falloff = 1 - (distToNearby / expRange);
                                nearbyB.health -= enemy.damage * falloff * 0.5;
                            }
                        });

                        // Explosion particles
                        for (let i = 0; i < 10; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 4 + 2;
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                color: 0xff6600,
                                life: Math.random() * 20 + 10
                            });
                        }

                        // Kill the kamikaze enemy
                        enemy.health = 0;
                        return;
                    }

                    // Regular enemies - if building is in the way (within 1.5 tiles) and between enemy and target
                    if (!enemy.isKamikaze && distToBuilding < TILE_SIZE * 1.5) {
                        const angleToTarget = Math.atan2(dy, dx);
                        const angleToBuilding = Math.atan2(by - enemy.y, bx - enemy.x);
                        const angleDiff = Math.abs(angleToTarget - angleToBuilding);

                        if (angleDiff < Math.PI / 4 || angleDiff > 7 * Math.PI / 4) {
                            // Building is roughly in direction of target - attack it
                            b.health -= 0.5; // Damage buildings in the way
                        }
                    }
                });

                // Shooting enemies stop at range and shoot instead of ramming
                const shootingRange = enemy.canShoot ? enemy.range * TILE_SIZE * 0.9 : TILE_SIZE;
                const shouldMove = !enemy.canShoot || dist > shootingRange;

                if (shouldMove && dist > TILE_SIZE) {
                    // Apply slow effect if active
                    let speedMultiplier = 1.0;
                    if (enemy.slowedUntil && Date.now() < enemy.slowedUntil) {
                        speedMultiplier = enemy.slowFactor || 0.5;
                    } else {
                        enemy.slowedUntil = null;
                        enemy.slowFactor = null;
                    }
                    
                    enemy.x += (dx / dist) * enemy.speed * speedMultiplier;
                    enemy.y += (dy / dist) * enemy.speed * speedMultiplier;
                }

                // Enemy shooting
                if (enemy.canShoot && enemy.fireCooldownMax) {
                    enemy.lastFire = (enemy.lastFire || 0) + delta;

                    if (enemy.useLaser) {
                        // Laser enemies fire with cooldown
                        const playerDist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);

                        if (player.respawnTimer <= 0 && playerDist < enemy.range * TILE_SIZE) {
                            // Only activate laser when cooldown is ready
                            if (enemy.lastFire >= enemy.fireCooldownMax) {
                                enemy.laserActive = true;
                                enemy.laserTarget = { x: player.x, y: player.y, isPlayer: true };
                                enemy.laserStartTime = Date.now();
                                enemy.lastFire = 0;
                            }

                            // Laser stays active for 300ms then turns off
                            if (enemy.laserActive && enemy.laserStartTime && Date.now() - enemy.laserStartTime > 300) {
                                enemy.laserActive = false;
                                enemy.laserTarget = null;
                            }

                            // Deal damage when laser is active (increased laser damage)
                            if (enemy.laserActive) {
                                player.health -= enemy.damage * 0.35; // Per frame damage while active (greatly increased)
                                updatePlayerHealthUI();
                                spawnParticles(player.x, player.y, 0xff4444, 2);
                                if (player.health <= 0 && player.respawnTimer <= 0) {
                                    respawnPlayer();
                                }
                            }
                        } else if (targetBuilding && dist < enemy.range * TILE_SIZE) {
                            // Only activate laser when cooldown is ready
                            if (enemy.lastFire >= enemy.fireCooldownMax) {
                                enemy.laserActive = true;
                                enemy.laserTarget = { x: targetX, y: targetY, building: targetBuilding };
                                enemy.laserStartTime = Date.now();
                                enemy.lastFire = 0;
                            }

                            // Laser stays active for 300ms then turns off
                            if (enemy.laserActive && enemy.laserStartTime && Date.now() - enemy.laserStartTime > 300) {
                                enemy.laserActive = false;
                                enemy.laserTarget = null;
                            }

                            // Deal damage to building when laser is active
                            if (enemy.laserActive && targetBuilding) {
                                targetBuilding.health -= enemy.damage * 0.05;
                            }
                        } else {
                            enemy.laserActive = false;
                            enemy.laserTarget = null;
                        }
                    } else {
                        // Regular bullet enemies
                        if (enemy.lastFire >= enemy.fireCooldownMax) {
                            // Shoot at player if in range (only if player is alive)
                            const playerDist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);

                            if (player.respawnTimer <= 0 && playerDist < enemy.range * TILE_SIZE) {
                                enemyBullets.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    startX: enemy.x,
                                    startY: enemy.y,
                                    targetX: player.x,
                                    targetY: player.y,
                                    speed: enemy.bulletSpeed || 4,
                                    damage: enemy.damage * 8, // Greatly increased damage to player
                                    splash: enemy.splash,
                                    enemyType: enemy.type,
                                    targetIsPlayer: true
                                });
                                enemy.lastFire = 0;
                            } else if (targetBuilding && dist < enemy.range * TILE_SIZE) {
                                // Shoot at building from range
                                enemyBullets.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    startX: enemy.x,
                                    startY: enemy.y,
                                    targetX: targetX,
                                    targetY: targetY,
                                    speed: enemy.bulletSpeed || 4,
                                    damage: enemy.damage * 5, // Increased building damage
                                    targetBuilding: targetBuilding,
                                    splash: enemy.splash,
                                    enemyType: enemy.type
                                });
                                enemy.lastFire = 0;
                            }
                        }
                    }
                }

                // Only non-shooting enemies do melee damage
                if (!enemy.canShoot && dist < TILE_SIZE && targetBuilding) {
                    targetBuilding.health -= enemy.damage * 0.1;

                    if (targetBuilding.type === 'core') {
                        coreHealth = targetBuilding.health;
                        if (coreHealth <= 0) {
                            gameOver = true;
                            alert('Game Over! Wave ' + wave);
                        }
                    } else if (targetBuilding.health <= 0) {
                        destroyBuilding(targetBuilding);
                    }
                }

                // Fast enemies are kamikaze - explode on contact
                if (enemy.type === 'fast' && dist < TILE_SIZE * 1.5) {
                    const explosionRange = TILE_SIZE * 2.5;
                    const explosionDamage = 40 + wave * 8;

                    // Damage all buildings in range
                    const damagedBuildings = [];
                    buildings.forEach(b => {
                        const bx = b.x * TILE_SIZE + TILE_SIZE / 2;
                        const by = b.y * TILE_SIZE + TILE_SIZE / 2;
                        const bDist = Math.sqrt((bx - enemy.x)**2 + (by - enemy.y)**2);
                        if (bDist < explosionRange) {
                            const falloff = 1 - (bDist / explosionRange);
                            b.health -= explosionDamage * falloff;
                            if (b.type === 'core') {
                                coreHealth = b.health;
                                if (coreHealth <= 0) {
                                    gameOver = true;
                                    alert('Game Over! Wave ' + wave);
                                }
                            } else if (b.health <= 0) {
                                damagedBuildings.push(b);
                            }
                        }
                    });
                    damagedBuildings.forEach(b => destroyBuilding(b));

                    // Damage player if nearby
                    const playerDist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);
                    if (playerDist < explosionRange && player.respawnTimer <= 0 && player.invulnerable <= 0) {
                        const falloff = 1 - (playerDist / explosionRange);
                        player.health -= explosionDamage * falloff;
                        if (player.health <= 0) {
                            respawnPlayer();
                        }
                    }

                    // Explosion effect (reduced particles for performance)
                    for (let i = 0; i < 20; i++) {
                        const particleAngle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 6 + 3;
                        particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(particleAngle) * speed,
                            vy: Math.sin(particleAngle) * speed,
                            color: Math.random() > 0.5 ? 0xff6600 : 0xffaa00,
                            life: Math.random() * 40 + 30
                        });
                    }

                    // Kill the kamikaze enemy
                    enemy.health = 0;
                }

                // Draw enemy
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;

                if (screenX > -50 && screenX < window.innerWidth + 50 &&
                    screenY > -50 && screenY < window.innerHeight + 50) {

                    // Shadow
                    graphics.fillStyle(0x000000, 0.3);
                    graphics.fillEllipse(screenX, screenY + enemy.size * 0.8, enemy.size, enemy.size * 0.4);

                    // Body with type-specific designs
                    graphics.fillStyle(enemy.color);
                    
                    if (enemy.type === 'basic') {
                        // Basic enemy - hexagonal assault drone
                        graphics.fillCircle(screenX, screenY, enemy.size);
                        graphics.fillStyle(enemy.color * 0.7);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.6);
                        // Directional indicator
                        graphics.fillStyle(0xff8888);
                        const angle = Math.atan2(dy, dx);
                        graphics.fillCircle(screenX + Math.cos(angle) * 5, screenY + Math.sin(angle) * 5, 3);
                        // Side panels
                        graphics.fillStyle(0xaa3333);
                        graphics.fillRect(screenX - enemy.size, screenY - 2, enemy.size * 0.6, 4);
                        graphics.fillRect(screenX + enemy.size * 0.4, screenY - 2, enemy.size * 0.6, 4);
                    } else if (enemy.type === 'fast') {
                        // Fast enemy - sleek rocket with thrusters
                        const angle = Math.atan2(dy, dx);
                        graphics.fillCircle(screenX, screenY, enemy.size);
                        // Rocket body
                        graphics.fillStyle(0xff8800);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.7);
                        // Nose cone
                        graphics.fillStyle(0xffaa00);
                        graphics.fillCircle(screenX + Math.cos(angle) * 4, screenY + Math.sin(angle) * 4, enemy.size * 0.5);
                        // Thruster flames
                        const thrustX = screenX - Math.cos(angle) * enemy.size;
                        const thrustY = screenY - Math.sin(angle) * enemy.size;
                        graphics.fillStyle(0xff6600, 0.8);
                        graphics.fillCircle(thrustX, thrustY, 4);
                        graphics.fillStyle(0xffff00, 0.6);
                        graphics.fillCircle(thrustX, thrustY, 2);
                        // Warning stripes (kamikaze indicator)
                        graphics.fillStyle(0xffff00);
                        graphics.fillRect(screenX - 4, screenY - 1, 3, 2);
                        graphics.fillRect(screenX + 1, screenY - 1, 3, 2);
                    } else {
                        // Default circular body for other types
                        graphics.fillCircle(screenX, screenY, enemy.size);
                    }

                    // Details based on type
                    const angle = Math.atan2(dy, dx);

                    if (enemy.type === 'shooter') {
                        // Gun barrel
                        graphics.fillStyle(0x333333);
                        graphics.fillRect(
                            screenX + Math.cos(angle) * enemy.size * 0.5 - 2,
                            screenY + Math.sin(angle) * enemy.size * 0.5 - 2,
                            enemy.size * 0.7, 4
                        );
                    }

                    if (enemy.type === 'sniper') {
                        // Long sniper barrel
                        graphics.fillStyle(0x222244);
                        graphics.fillRect(
                            screenX + Math.cos(angle) * enemy.size * 0.3 - 1,
                            screenY + Math.sin(angle) * enemy.size * 0.3 - 1,
                            enemy.size * 1.2, 3
                        );
                        // Scope
                        graphics.fillStyle(0x6666ff);
                        graphics.fillCircle(screenX, screenY - 3, 3);
                    }

                    if (enemy.type === 'artillery') {
                        // Mortar tube
                        graphics.fillStyle(0x224422);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.5);
                        graphics.fillStyle(0x335533);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.35);
                        // Barrel pointing up
                        graphics.fillStyle(0x113311);
                        graphics.fillRect(screenX - 3, screenY - enemy.size * 0.7, 6, enemy.size * 0.5);
                    }

                    if (enemy.type === 'tank') {
                        // Tank treads
                        graphics.fillStyle(0x443333);
                        graphics.fillRect(screenX - enemy.size, screenY - enemy.size * 0.4, enemy.size * 2, enemy.size * 0.8);
                        // Tank body
                        graphics.fillStyle(0x664444);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.6);
                        // Turret
                        graphics.fillStyle(0x553333);
                        graphics.fillRect(
                            screenX + Math.cos(angle) * 2 - 2,
                            screenY + Math.sin(angle) * 2 - 2,
                            enemy.size * 0.8, 4
                        );
                    }

                    if (enemy.type === 'swarm') {
                        // Small fast wings
                        const wingFlap = Math.sin(time / 30) * 3;
                        graphics.fillStyle(0xcc66cc);
                        graphics.fillEllipse(screenX - 4, screenY + wingFlap, 3, 5);
                        graphics.fillEllipse(screenX + 4, screenY - wingFlap, 3, 5);
                    }

                    if (enemy.type === 'boss') {
                        // Boss armor
                        graphics.fillStyle(0x880000);
                        graphics.fillCircle(screenX, screenY, enemy.size * 0.7);
                        // Crown/horns
                        graphics.fillStyle(0xffcc00);
                        graphics.beginPath();
                        graphics.moveTo(screenX - 8, screenY - enemy.size);
                        graphics.lineTo(screenX - 4, screenY - enemy.size - 8);
                        graphics.lineTo(screenX, screenY - enemy.size);
                        graphics.lineTo(screenX + 4, screenY - enemy.size - 8);
                        graphics.lineTo(screenX + 8, screenY - enemy.size);
                        graphics.closePath();
                        graphics.fillPath();
                        // Glowing aura
                        graphics.lineStyle(2, 0xffff00, Math.sin(time / 100) * 0.3 + 0.7);
                        graphics.strokeCircle(screenX, screenY, enemy.size + 4);
                        // Gun turrets
                        graphics.fillStyle(0x333333);
                        graphics.fillRect(screenX - enemy.size * 0.8, screenY - 4, enemy.size * 0.6, 4);
                        graphics.fillRect(screenX + enemy.size * 0.3, screenY - 4, enemy.size * 0.6, 4);
                    }

                    // Health bar
                    if (enemy.health < enemy.maxHealth) {
                        const healthPct = enemy.health / enemy.maxHealth;
                        graphics.fillStyle(0x333333);
                        graphics.fillRect(screenX - enemy.size, screenY - enemy.size - 8, enemy.size * 2, 4);
                        graphics.fillStyle(healthPct > 0.5 ? 0x44ff44 : (healthPct > 0.25 ? 0xffff00 : 0xff4444));
                        graphics.fillRect(screenX - enemy.size, screenY - enemy.size - 8, enemy.size * 2 * healthPct, 4);
                    }

                    // Draw laser beam if active
                    if (enemy.laserActive && enemy.laserTarget) {
                        const targetScreenX = enemy.laserTarget.x - camera.x;
                        const targetScreenY = enemy.laserTarget.y - camera.y;
                        const laserPulse = Math.sin(Date.now() / 60) * 0.3 + 0.7;
                        const color = enemy.laserColor || 0xff0000;

                        // Outer glow - wider for bigger enemies
                        const glowWidth = enemy.size > 20 ? 18 : (enemy.size > 15 ? 14 : 10);
                        graphics.lineStyle(glowWidth, color, laserPulse * 0.25);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Middle glow
                        graphics.lineStyle(glowWidth * 0.5, color, laserPulse * 0.6);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Core beam - very bright
                        graphics.lineStyle(glowWidth * 0.25, 0xffffff, laserPulse * 0.95);
                        graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                        // Impact effect at target
                        graphics.fillStyle(color, laserPulse * 0.7);
                        graphics.fillCircle(targetScreenX, targetScreenY, 14);
                        graphics.fillStyle(0xffffff, laserPulse * 0.5);
                        graphics.fillCircle(targetScreenX, targetScreenY, 7);
                    }
                }
            });

            enemies = enemies.filter(e => e.health > 0);
            document.getElementById('enemy-count').textContent = enemies.length;

            // Enemy bullets
            enemyBullets.forEach(bullet => {
                const dx = bullet.targetX - bullet.x;
                const dy = bullet.targetY - bullet.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist > bullet.speed) {
                    bullet.x += (dx / dist) * bullet.speed;
                    bullet.y += (dy / dist) * bullet.speed;
                } else {
                    bullet.hit = true;

                    // Check if hit player (only if not respawning/invulnerable)
                    if (player.respawnTimer <= 0 && player.invulnerable <= 0) {
                        const playerDist = Math.sqrt((player.x - bullet.x)**2 + (player.y - bullet.y)**2);
                        if (playerDist < 20) {
                            player.health -= bullet.damage;
                            updatePlayerHealthUI();
                            spawnParticles(player.x, player.y, 0xff0000, 5);

                            if (player.health <= 0) {
                                respawnPlayer();
                            }
                        }
                    }

                    // Splash damage for artillery
                    if (bullet.splash) {
                        spawnParticles(bullet.x, bullet.y, 0x448844, 5); // Reduced from 15
                        spawnParticles(bullet.x, bullet.y, 0xffaa00, 3); // Reduced from 10

                        // Damage buildings in splash radius
                        const splashRadius = TILE_SIZE * 2;
                        const damagedBuildings = [];
                        buildings.forEach(b => {
                            const bx = b.x * TILE_SIZE + TILE_SIZE / 2;
                            const by = b.y * TILE_SIZE + TILE_SIZE / 2;
                            const bDist = Math.sqrt((bx - bullet.x)**2 + (by - bullet.y)**2);
                            if (bDist < splashRadius) {
                                const falloff = 1 - (bDist / splashRadius);
                                b.health -= bullet.damage * falloff;
                                if (b.type === 'core') {
                                    coreHealth = b.health;
                                    if (coreHealth <= 0) {
                                        gameOver = true;
                                        alert('Game Over! Wave ' + wave);
                                    }
                                } else if (b.health <= 0) {
                                    damagedBuildings.push(b);
                                }
                            }
                        });
                        // Remove destroyed buildings
                        damagedBuildings.forEach(b => {
                            destroyBuilding(b);
                        });
                    }

                    // Check if hit building (non-splash)
                    if (bullet.targetBuilding && !bullet.splash) {
                        bullet.targetBuilding.health -= bullet.damage;
                        if (bullet.targetBuilding.type === 'core') {
                            coreHealth = bullet.targetBuilding.health;
                            if (coreHealth <= 0) {
                                gameOver = true;
                                alert('Game Over! Wave ' + wave);
                            }
                        } else if (bullet.targetBuilding.health <= 0) {
                            destroyBuilding(bullet.targetBuilding);
                        }
                    }
                }

                if (!bullet.hit) {
                    const screenX = bullet.x - camera.x;
                    const screenY = bullet.y - camera.y;

                    // Different bullet visuals based on enemy type
                    if (bullet.enemyType === 'sniper') {
                        graphics.fillStyle(0x8844ff);
                        graphics.fillCircle(screenX, screenY, 3);
                        // Trail
                        graphics.lineStyle(2, 0x8844ff, 0.5);
                        const trailLen = 15;
                        const dx = bullet.targetX - bullet.x;
                        const dy = bullet.targetY - bullet.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 0) {
                            graphics.lineBetween(screenX, screenY,
                                screenX - (dx/dist) * trailLen,
                                screenY - (dy/dist) * trailLen);
                        }
                    } else if (bullet.enemyType === 'artillery') {
                        // Arc indicator
                        const progress = 1 - (Math.sqrt((bullet.targetX - bullet.x)**2 + (bullet.targetY - bullet.y)**2) /
                                             Math.sqrt((bullet.targetX - bullet.startX)**2 + (bullet.targetY - bullet.startY)**2 + 1));
                        const arcHeight = Math.sin(progress * Math.PI) * 20;
                        graphics.fillStyle(0x88ff88);
                        graphics.fillCircle(screenX, screenY - arcHeight, 5);
                        // Shadow
                        graphics.fillStyle(0x000000, 0.3);
                        graphics.fillCircle(screenX, screenY + 5, 3);
                    } else {
                        graphics.fillStyle(0xff8800);
                        graphics.fillCircle(screenX, screenY, 4);
                    }
                }
            });

            enemyBullets = enemyBullets.filter(b => !b.hit);
            
            // Hard limit on bullets for performance
            if (enemyBullets.length > 100) {
                enemyBullets.splice(0, enemyBullets.length - 100);
            }

            // Turret AI
            buildings.forEach(b => {
                if (b.type === 'turret' || b.type === 'scatter' || b.type === 'laser' || b.type === 'alloy-turret' || b.type === 'stormer') {
                    if (b.type === 'laser' && !b.powered) return;
                    if ((b.type === 'turret' || b.type === 'scatter' || b.type === 'alloy-turret' || b.type === 'stormer') && b.ammo <= 0) return;

                    const data = BUILDINGS[b.type];
                    b.cooldown = (b.cooldown || 0) - delta;

                    const tx = b.x * TILE_SIZE + TILE_SIZE/2;
                    const ty = b.y * TILE_SIZE + TILE_SIZE/2;
                    const range = data.range * TILE_SIZE;

                    // Find closest enemy for targeting using spatial grid (optimized)
                    let closest = null;
                    let closestDist = Infinity;

                    const nearbyEnemies = getNearbyEnemies(tx, ty, range);
                    for (const e of nearbyEnemies) {
                        const dist = Math.sqrt((e.x - tx)**2 + (e.y - ty)**2);
                        if (dist < closestDist) {
                            closest = e;
                            closestDist = dist;
                        }
                    }

                    // Update turret rotation to track target smoothly
                    if (closest) {
                        const targetAngle = Math.atan2(closest.y - ty, closest.x - tx);
                        if (b.turretAngle === undefined) b.turretAngle = targetAngle;

                        // Smooth rotation toward target
                        let angleDiff = targetAngle - b.turretAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        b.turretAngle += angleDiff * 0.15; // Rotation speed
                    }

                    if (b.cooldown <= 0 && enemies.length > 0 && closest) {
                        if (b.type === 'turret') {
                            bullets.push({
                                x: tx, y: ty,
                                targetX: closest.x, targetY: closest.y,
                                speed: 10, damage: data.damage,
                                type: 'bullet'
                            });
                            b.ammo--;
                        } else if (b.type === 'alloy-turret') {
                            // Salvo fires rapid bursts
                            bullets.push({
                                x: tx, y: ty,
                                targetX: closest.x, targetY: closest.y,
                                speed: 12, damage: data.damage,
                                type: 'alloy'
                            });
                            b.ammo--;
                        } else if (b.type === 'scatter') {
                            for (let i = 0; i < data.shots; i++) {
                                const spread = (i - 1) * 0.2;
                                const angle = Math.atan2(closest.y - ty, closest.x - tx) + spread;
                                bullets.push({
                                    x: tx, y: ty,
                                    vx: Math.cos(angle) * 8,
                                    vy: Math.sin(angle) * 8,
                                    speed: 8, damage: data.damage,
                                    life: 30,
                                    type: 'scatter'
                                });
                            }
                            b.ammo -= 2;
                        } else if (b.type === 'laser') {
                            closest.health -= data.damage;
                            spawnParticles(closest.x, closest.y, 0x6666ff, 8);

                            const screenTx = tx - camera.x;
                            const screenTy = ty - camera.y;
                            const screenEx = closest.x - camera.x;
                            const screenEy = closest.y - camera.y;

                            graphics.lineStyle(3, 0x6666ff, 0.8);
                            graphics.lineBetween(screenTx, screenTy, screenEx, screenEy);

                            // Chain lightning (optimized with spatial grid)
                            const chainEnemies = getNearbyEnemies(closest.x, closest.y, TILE_SIZE * 2);
                            for (const e2 of chainEnemies) {
                                if (e2 !== closest) {
                                    e2.health -= data.damage * 0.5;
                                    const screen2x = e2.x - camera.x;
                                    const screen2y = e2.y - camera.y;
                                    graphics.lineStyle(2, 0x4444cc, 0.6);
                                    graphics.lineBetween(screenEx, screenEy, screen2x, screen2y);
                                }
                            }
                        } else if (b.type === 'stormer') {
                            // Stormer fires continuous sand stream, hits multiple enemies in cone
                            const angle = b.turretAngle || Math.atan2(closest.y - ty, closest.x - tx);
                            const coneWidth = 0.4; // Cone spread in radians

                            // Optimized with spatial grid
                            const coneEnemies = getNearbyEnemies(tx, ty, range);
                            for (const e of coneEnemies) {
                                const dist = Math.sqrt((e.x - tx)**2 + (e.y - ty)**2);
                                const angleToEnemy = Math.atan2(e.y - ty, e.x - tx);
                                let angleDiff = angleToEnemy - angle;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                                if (dist < range && Math.abs(angleDiff) < coneWidth) {
                                    e.health -= data.damage;
                                    // Apply slow effect
                                    e.slowedUntil = Date.now() + 1000; // Slow for 1 second
                                    e.slowFactor = data.slowEffect; // 50% speed
                                    spawnParticles(e.x, e.y, 0xc9b592, 5);
                                }
                            }
                            
                            // Visual sand blast effect
                            const screenTx = tx - camera.x;
                            const screenTy = ty - camera.y;
                            for (let i = 0; i < 5; i++) {
                                const spreadAngle = angle + (Math.random() - 0.5) * coneWidth * 2;
                                const len = range * (0.7 + Math.random() * 0.3);
                                const ex = tx + Math.cos(spreadAngle) * len;
                                const ey = ty + Math.sin(spreadAngle) * len;
                                const screenEx = ex - camera.x;
                                const screenEy = ey - camera.y;
                                graphics.lineStyle(2 + Math.random() * 2, 0xc9b592, 0.3 + Math.random() * 0.3);
                                graphics.lineBetween(screenTx, screenTy, screenEx, screenEy);
                            }
                            
                            b.ammo--;
                        }
                        // Apply cooldown (slower when low power for laser)
                        const cooldownMult = (b.type === 'laser' && b.powerEfficiency) ? 
                            (1 / Math.max(0.2, b.powerEfficiency)) : 1.0;
                        b.cooldown = data.cooldown * cooldownMult;
                    }
                }
            });

            // Update bullets
            bullets.forEach(bullet => {
                if (bullet.type === 'scatter') {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    bullet.life--;

                    if (bullet.life <= 0) {
                        bullet.hit = true;
                    } else {
                        enemies.forEach(e => {
                            if (e.delay <= 0) {
                                const dist = Math.sqrt((e.x - bullet.x)**2 + (e.y - bullet.y)**2);
                                if (dist < e.size + 4) {
                                    e.health -= bullet.damage;
                                    bullet.hit = true;
                                    spawnParticles(bullet.x, bullet.y, 0xffaa00, 3);
                                }
                            }
                        });
                    }
                } else {
                    const dx = bullet.targetX - bullet.x;
                    const dy = bullet.targetY - bullet.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist > bullet.speed) {
                        bullet.x += (dx / dist) * bullet.speed;
                        bullet.y += (dy / dist) * bullet.speed;
                    } else {
                        bullet.hit = true;
                        enemies.forEach(e => {
                            const eDist = Math.sqrt((e.x - bullet.x)**2 + (e.y - bullet.y)**2);
                            if (eDist < 20) {
                                e.health -= bullet.damage;
                                spawnParticles(e.x, e.y, 0xffff00, 3);
                            }
                        });
                    }
                }

                if (!bullet.hit) {
                    const screenX = bullet.x - camera.x;
                    const screenY = bullet.y - camera.y;
                    const bulletColor = bullet.type === 'scatter' ? 0xffaa00 :
                                       bullet.type === 'alloy' ? 0xb8967a : 0xffff00;
                    graphics.fillStyle(bulletColor);
                    graphics.fillCircle(screenX, screenY, bullet.type === 'scatter' ? 3 : 4);
                }
            });

            bullets = bullets.filter(b => !b.hit);

            // Hard limit on bullets for performance
            if (bullets.length > 80) {
                bullets.splice(0, bullets.length - 80);
            }

            // Update player bullets
            playerBullets.forEach(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life--;

                if (bullet.life <= 0) {
                    bullet.hit = true;
                } else {
                    // Check collision with enemies
                    enemies.forEach(e => {
                        if (e.delay <= 0 && !bullet.hit) {
                            const dist = Math.sqrt((e.x - bullet.x)**2 + (e.y - bullet.y)**2);
                            if (dist < e.size + 6) {
                                e.health -= bullet.damage;
                                bullet.hit = true;
                                spawnParticles(bullet.x, bullet.y, 0x44ffff, 5);
                                spawnParticles(e.x, e.y, 0xff4444, 3);
                            }
                        }
                    });
                }

                // Draw bullet if not hit
                if (!bullet.hit) {
                    const screenX = bullet.x - camera.x;
                    const screenY = bullet.y - camera.y;

                    // Cyan/blue bullet with glow effect
                    graphics.fillStyle(0x44ffff, 0.5);
                    graphics.fillCircle(screenX, screenY, 6);
                    graphics.fillStyle(0x88ffff);
                    graphics.fillCircle(screenX, screenY, 4);
                    graphics.fillStyle(0xffffff);
                    graphics.fillCircle(screenX, screenY, 2);
                }
            });

            playerBullets = playerBullets.filter(b => !b.hit);

            // Hard limit on player bullets for performance
            if (playerBullets.length > 50) {
                playerBullets.splice(0, playerBullets.length - 50);
            }

            // Update particles
            // Update and draw particles (optimized with culling)
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }

                // Only draw particles on screen
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                if (screenX > -20 && screenX < window.innerWidth + 20 &&
                    screenY > -20 && screenY < window.innerHeight + 20) {
                    graphics.fillStyle(p.color, p.life / 30);
                    graphics.fillCircle(screenX, screenY, p.size * (p.life / 30));
                }
            }
            
            // Limit total particle count for performance
            if (particles.length > 1000) {
                particles.splice(0, particles.length - 1000);
            }

            // Draw player ship
            drawPlayer();

            // Building preview
            if (selectedBuilding && selectedBuilding !== 'delete') {
                const pointer = scene.input.activePointer;
                const world = screenToWorld(pointer.x, pointer.y);
                const tile = worldToTile(world.x, world.y);

                if (tile.x >= 0 && tile.x < MAP_WIDTH && tile.y >= 0 && tile.y < MAP_HEIGHT) {
                    const screenX = tile.x * TILE_SIZE - camera.x;
                    const screenY = tile.y * TILE_SIZE - camera.y;

                    const data = BUILDINGS[selectedBuilding];
                    const width = data.width || 1;
                    const height = data.height || 1;

                    const canPlace = map[tile.y][tile.x] === 0 &&
                                    terrainMap[tile.y][tile.x] !== TERRAIN.WATER &&
                                    canAfford(selectedBuilding);
                    const isDrill = selectedBuilding === 'drill' || selectedBuilding === 'pneumatic-drill' || selectedBuilding === 'alloy-drill';
                    
                    // For drills, check if ANY tile in the 2x2 area has ore
                    let hasOreOrSand = false;
                    if (isDrill) {
                        for (let dy = 0; dy < height; dy++) {
                            for (let dx = 0; dx < width; dx++) {
                                if (tile.y + dy >= MAP_HEIGHT || tile.x + dx >= MAP_WIDTH) continue;
                                if ((oreMap[tile.y + dy] && oreMap[tile.y + dy][tile.x + dx]) ||
                                    (terrainMap[tile.y + dy] && terrainMap[tile.y + dy][tile.x + dx] === TERRAIN.SAND)) {
                                    hasOreOrSand = true;
                                    break;
                                }
                            }
                            if (hasOreOrSand) break;
                        }
                    }
                    const needsOre = isDrill && !hasOreOrSand;

                    // Draw preview for full building size
                    graphics.fillStyle(needsOre ? 0xff0000 : (canPlace ? 0x00ff00 : 0xff0000), 0.3);
                    graphics.fillRect(screenX, screenY, TILE_SIZE * width, TILE_SIZE * height);

                    // Draw direction arrow in center for rotatable buildings
                    if (isDrill || selectedBuilding === 'conveyor' || selectedBuilding === 'alloy-conveyor' || selectedBuilding === 'graphite-press' || selectedBuilding === 'alloy-factory' || selectedBuilding === 'thermal-generator' || selectedBuilding === 'payload-conveyor') {
                        const centerX = screenX + (TILE_SIZE * width) / 2;
                        const centerY = screenY + (TILE_SIZE * height) / 2;
                        drawArrow(centerX, centerY, rotation, 0xffffff);
                    }

                    // Show range from center
                    if (data.range) {
                        const centerX = screenX + (TILE_SIZE * width) / 2;
                        const centerY = screenY + (TILE_SIZE * height) / 2;
                        graphics.lineStyle(1, 0x4444ff, 0.3);
                        graphics.strokeCircle(centerX, centerY, data.range * TILE_SIZE);
                    }
                    if (data.powerRange) {
                        const centerX = screenX + (TILE_SIZE * width) / 2;
                        const centerY = screenY + (TILE_SIZE * height) / 2;
                        graphics.lineStyle(1, 0xffcc00, 0.3);
                        graphics.strokeCircle(centerX, centerY, data.powerRange * TILE_SIZE);
                    }
                }
            }

            // Update tooltip continuously based on mouse position
            const pointer = scene.input.activePointer;
            const world = screenToWorld(pointer.x, pointer.y);
            const hoverTile = worldToTile(world.x, world.y);
            updateTooltip(pointer, hoverTile);

            // Draw minimap
            drawMinimap();
            drawFactoryIndicator();
        }

        function drawPlayer() {
            // Don't draw if respawning
            if (player.respawnTimer > 0) {
                // Draw ghost/respawn indicator
                const screenX = player.x - camera.x;
                const screenY = player.y - camera.y;
                const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.3;
                graphics.fillStyle(0x4488ff, pulse);
                graphics.fillCircle(screenX, screenY, 15);
                graphics.lineStyle(2, 0xffffff, pulse);
                graphics.strokeCircle(screenX, screenY, 20 + Math.sin(Date.now() / 200) * 5);
                return;
            }

            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;

            // Invulnerability shield
            if (player.invulnerable > 0) {
                const shieldPulse = Math.sin(Date.now() / 50) * 0.3 + 0.5;
                graphics.fillStyle(0x44ffff, shieldPulse * 0.3);
                graphics.fillCircle(screenX, screenY, 25);
                graphics.lineStyle(2, 0x44ffff, shieldPulse);
                graphics.strokeCircle(screenX, screenY, 25);
            }

            // Shadow
            graphics.fillStyle(0x000000, 0.3);
            graphics.fillEllipse(screenX + 2, screenY + 3, 16, 10);

            // Calculate rotation for ship direction
            const cos = Math.cos(player.angle);
            const sin = Math.sin(player.angle);

            // Helper function to rotate a point around the ship center
            function rotatePoint(px, py) {
                return {
                    x: screenX + px * cos - py * sin,
                    y: screenY + px * sin + py * cos
                };
            }

            // Main hull body (drawn as a polygon for rotation)
            graphics.fillStyle(0x555566);
            const hull1 = rotatePoint(-10, -8);
            const hull2 = rotatePoint(10, -8);
            const hull3 = rotatePoint(10, 8);
            const hull4 = rotatePoint(-10, 8);
            graphics.beginPath();
            graphics.moveTo(hull1.x, hull1.y);
            graphics.lineTo(hull2.x, hull2.y);
            graphics.lineTo(hull3.x, hull3.y);
            graphics.lineTo(hull4.x, hull4.y);
            graphics.closePath();
            graphics.fillPath();

            // Front angled section (nose)
            graphics.fillStyle(0x666677);
            const nose1 = rotatePoint(10, -8);
            const nose2 = rotatePoint(16, -4);
            const nose3 = rotatePoint(16, 4);
            const nose4 = rotatePoint(10, 8);
            graphics.beginPath();
            graphics.moveTo(nose1.x, nose1.y);
            graphics.lineTo(nose2.x, nose2.y);
            graphics.lineTo(nose3.x, nose3.y);
            graphics.lineTo(nose4.x, nose4.y);
            graphics.closePath();
            graphics.fillPath();

            // Cockpit window
            graphics.fillStyle(0x447788, 0.8);
            const cockpit = rotatePoint(9, 0);
            graphics.fillCircle(cockpit.x, cockpit.y, 4);

            // Gun barrels (on the sides of the nose)
            graphics.fillStyle(0x444455);
            const gun1Start = rotatePoint(12, -6);
            const gun1End = rotatePoint(20, -6);
            const gun2Start = rotatePoint(12, 6);
            const gun2End = rotatePoint(20, 6);
            graphics.lineStyle(3, 0x444455);
            graphics.beginPath();
            graphics.moveTo(gun1Start.x, gun1Start.y);
            graphics.lineTo(gun1End.x, gun1End.y);
            graphics.strokePath();
            graphics.beginPath();
            graphics.moveTo(gun2Start.x, gun2Start.y);
            graphics.lineTo(gun2End.x, gun2End.y);
            graphics.strokePath();

            // Gun barrel tips (muzzles)
            graphics.fillStyle(0x333344);
            graphics.fillCircle(gun1End.x, gun1End.y, 2);
            graphics.fillCircle(gun2End.x, gun2End.y, 2);

            // Engine glow
            const engineGlow = Math.sin(Date.now() / 40) * 0.3 + 0.7;
            const isMoving = keys.W?.isDown || keys.S?.isDown || keys.A?.isDown || keys.D?.isDown;
            const glowIntensity = isMoving ? 1 : 0.5;

            // Engine flames (at the back)
            const eng1 = rotatePoint(-14, -4);
            const eng2 = rotatePoint(-14, 4);
            graphics.fillStyle(0xff4400, engineGlow * glowIntensity * 0.7);
            graphics.fillCircle(eng1.x, eng1.y, 3 + (isMoving ? 2 : 0));
            graphics.fillCircle(eng2.x, eng2.y, 3 + (isMoving ? 2 : 0));

            graphics.fillStyle(0xffaa00, engineGlow * glowIntensity * 0.5);
            graphics.fillCircle(eng1.x, eng1.y, 2);
            graphics.fillCircle(eng2.x, eng2.y, 2);

            // Warning lights on front
            graphics.fillStyle(0xffcc00);
            const warn1 = rotatePoint(12, -5);
            const warn2 = rotatePoint(12, 5);
            graphics.fillCircle(warn1.x, warn1.y, 2);
            graphics.fillCircle(warn2.x, warn2.y, 2);

            // Mining laser - yellow beam to target ore (wider and brighter)
            if (miningMode && miningTarget) {
                const targetScreenX = miningTarget.x - camera.x;
                const targetScreenY = miningTarget.y - camera.y;

                // Laser glow/pulse effect
                const laserPulse = Math.sin(Date.now() / 80) * 0.3 + 0.7;

                // Outer glow - wider
                graphics.lineStyle(14, 0xffff00, laserPulse * 0.3);
                graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                // Middle glow - brighter
                graphics.lineStyle(7, 0xffff44, laserPulse * 0.7);
                graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                // Core beam - very bright
                graphics.lineStyle(3, 0xffffcc, laserPulse * 0.95);
                graphics.lineBetween(screenX, screenY, targetScreenX, targetScreenY);

                // Impact effect at target - larger and brighter
                graphics.fillStyle(0xffff00, laserPulse * 0.7);
                graphics.fillCircle(targetScreenX, targetScreenY, 12);
                graphics.fillStyle(0xffffff, laserPulse * 0.6);
                graphics.fillCircle(targetScreenX, targetScreenY, 6);
            } else if (miningMode) {
                // Show mining mode active indicator
                const miningPulse = Math.sin(Date.now() / 150) * 0.3 + 0.7;
                graphics.lineStyle(2, 0x44ff44, miningPulse * 0.6);
                graphics.strokeCircle(screenX, screenY, 30);
            }
        }

        function drawBuilding(b, screenX, screenY) {
            const px = screenX;
            const py = screenY;

            if (b.type === 'core') {
                // Large detailed 3x3 core
                const coreSize = TILE_SIZE * 3;
                const centerX = px + coreSize / 2;
                const centerY = py + coreSize / 2;

                // Base platform
                graphics.fillStyle(0x1a3a1a);
                graphics.fillRoundedRect(px + 2, py + 2, coreSize - 4, coreSize - 4, 10);

                // Outer ring
                graphics.fillStyle(0x2d5a2d);
                graphics.fillRoundedRect(px + 8, py + 8, coreSize - 16, coreSize - 16, 8);

                // Inner platform
                graphics.fillStyle(0x4CAF50);
                graphics.fillRoundedRect(px + 16, py + 16, coreSize - 32, coreSize - 32, 6);

                // Secondary inner ring
                graphics.fillStyle(0x3d8b3d);
                graphics.fillRoundedRect(px + 24, py + 24, coreSize - 48, coreSize - 48, 4);

                // Core crystal (larger)
                graphics.fillStyle(0x81C784);
                graphics.fillCircle(centerX, centerY, 18);

                // Glow effect
                const glow = Math.sin(Date.now() / 200) * 0.2 + 0.4;
                graphics.fillStyle(0xaaffaa, glow);
                graphics.fillCircle(centerX, centerY, 24);

                // Inner glow
                graphics.fillStyle(0xccffcc, glow * 0.7);
                graphics.fillCircle(centerX, centerY, 12);

                // Resource intake ports (on all 4 sides)
                graphics.fillStyle(0x333333);
                // Top ports
                graphics.fillRect(centerX - 12, py + 2, 8, 5);
                graphics.fillRect(centerX + 4, py + 2, 8, 5);
                // Bottom ports
                graphics.fillRect(centerX - 12, py + coreSize - 7, 8, 5);
                graphics.fillRect(centerX + 4, py + coreSize - 7, 8, 5);
                // Left ports
                graphics.fillRect(px + 2, centerY - 12, 5, 8);
                graphics.fillRect(px + 2, centerY + 4, 5, 8);
                // Right ports
                graphics.fillRect(px + coreSize - 7, centerY - 12, 5, 8);
                graphics.fillRect(px + coreSize - 7, centerY + 4, 5, 8);

                // Corner decorations
                graphics.fillStyle(0x4CAF50);
                graphics.fillCircle(px + 14, py + 14, 4);
                graphics.fillCircle(px + coreSize - 14, py + 14, 4);
                graphics.fillCircle(px + 14, py + coreSize - 14, 4);
                graphics.fillCircle(px + coreSize - 14, py + coreSize - 14, 4);

            } else if (b.type === 'drill') {
                // Industrial mining drill - 2x2 with better visuals
                const width = TILE_SIZE * 2;
                const height = TILE_SIZE * 2;
                
                // Base platform
                graphics.fillStyle(0x4a4a4a);
                graphics.fillRoundedRect(px + 2, py + 2, width - 4, height - 4, 6);

                // Metal housing
                graphics.fillStyle(0x777777);
                graphics.fillRoundedRect(px + 8, py + 8, width - 16, height - 16, 4);

                // Corner hydraulics
                graphics.fillStyle(0x555555);
                graphics.fillRect(px + 6, py + 6, 8, 8);
                graphics.fillRect(px + width - 14, py + 6, 8, 8);
                graphics.fillRect(px + 6, py + height - 14, 8, 8);
                graphics.fillRect(px + width - 14, py + height - 14, 8, 8);
                
                // Warning stripes on edges
                graphics.fillStyle(0xffcc00);
                graphics.fillRect(px + 12, py + 10, width - 24, 3);
                graphics.fillRect(px + 12, py + height - 13, width - 24, 3);

                // Rotating drill head assembly (larger for 2x2)
                const drillAngle = (Date.now() / 100) % (Math.PI * 2);
                
                // Large drill housing
                graphics.fillStyle(0x5a5a5a);
                graphics.fillCircle(px + width/2, py + height/2, 18);
                
                // Spinning drill bits (3 arms)
                graphics.fillStyle(0xcccccc);
                for (let i = 0; i < 3; i++) {
                    const a = drillAngle + i * Math.PI * 2 / 3;
                    const bitX = px + width/2 + Math.cos(a) * 13;
                    const bitY = py + height/2 + Math.sin(a) * 13;
                    graphics.fillCircle(bitX, bitY, 5);
                }
                
                // Center bolt
                graphics.fillStyle(0x333333);
                graphics.fillCircle(px + width/2, py + height/2, 8);
                graphics.fillStyle(0x666666);
                graphics.fillCircle(px + width/2, py + height/2, 4);

                // Ore count indicator (dots in corners)
                if (b.oreCount && b.oreCount > 1) {
                    graphics.fillStyle(0x4CAF50);
                    const dotSize = 3;
                    const positions = [
                        { x: px + 10, y: py + 10 },
                        { x: px + width - 10, y: py + 10 },
                        { x: px + 10, y: py + height - 10 },
                        { x: px + width - 10, y: py + height - 10 }
                    ];
                    for (let i = 0; i < Math.min(b.oreCount, 4); i++) {
                        graphics.fillCircle(positions[i].x, positions[i].y, dotSize);
                    }
                }

            } else if (b.type === 'pneumatic-drill') {
                // Pneumatic drill - 2x2 advanced drill with hydraulic details
                const width = TILE_SIZE * 2;
                const height = TILE_SIZE * 2;
                
                // Base platform with darker brown
                graphics.fillStyle(0x6a4a2a);
                graphics.fillRoundedRect(px + 2, py + 2, width - 4, height - 4, 6);

                // Copper/bronze housing
                graphics.fillStyle(0xB87333);
                graphics.fillRoundedRect(px + 8, py + 8, width - 16, height - 16, 4);

                // Pneumatic cylinders on corners
                graphics.fillStyle(0x8a6a4a);
                const cylinderSize = 10;
                graphics.fillRoundedRect(px + 6, py + 6, cylinderSize, cylinderSize, 2);
                graphics.fillRoundedRect(px + width - 16, py + 6, cylinderSize, cylinderSize, 2);
                graphics.fillRoundedRect(px + 6, py + height - 16, cylinderSize, cylinderSize, 2);
                graphics.fillRoundedRect(px + width - 16, py + height - 16, cylinderSize, cylinderSize, 2);

                // Piston rods extending from cylinders
                graphics.fillStyle(0xaaaaaa);
                graphics.fillRect(px + 11, py + 16, 2, 8);
                graphics.fillRect(px + width - 13, py + 16, 2, 8);
                graphics.fillRect(px + 11, py + height - 24, 2, 8);
                graphics.fillRect(px + width - 13, py + height - 24, 2, 8);

                // Fast rotating quad drill (larger for 2x2)
                const pDrillAngle = (Date.now() / 50) % (Math.PI * 2);
                
                // Drill housing ring
                graphics.fillStyle(0x6a5a4a);
                graphics.fillCircle(px + width/2, py + height/2, 16);
                
                // Rotating drill bits (4 sharp blades)
                graphics.fillStyle(0xdddddd);
                for (let i = 0; i < 4; i++) {
                    const a = pDrillAngle + i * Math.PI / 2;
                    const bitX = px + width/2 + Math.cos(a) * 12;
                    const bitY = py + height/2 + Math.sin(a) * 12;
                    // Draw blade shape
                    graphics.fillRect(bitX - 4, bitY - 2, 8, 4);
                    graphics.fillCircle(bitX + 2, bitY, 3);
                }
                
                // Center hub
                graphics.fillStyle(0x555555);
                graphics.fillCircle(px + width/2, py + height/2, 9);
                graphics.fillStyle(0x888888);
                graphics.fillCircle(px + width/2, py + height/2, 6);

                // Warning stripes
                graphics.fillStyle(0xffcc00);
                graphics.fillRect(px + 12, py + 8, width - 24, 3);
                graphics.fillRect(px + 8, py + 12, 3, height - 24);
                graphics.fillRect(px + width - 11, py + 12, 3, height - 24);
                graphics.fillRect(px + 12, py + height - 11, width - 24, 3);

                drawArrow(px + width/2, py + height/2, b.rotation, 0xffcc00);

                // Ore count indicator
                if (b.oreCount && b.oreCount > 1) {
                    graphics.fillStyle(0x4CAF50);
                    const dotSize = 3;
                    const positions = [
                        { x: px + 12, y: py + height - 12 },
                        { x: px + width - 12, y: py + height - 12 },
                        { x: px + 12, y: py + height - 18 },
                        { x: px + width - 12, y: py + height - 18 }
                    ];
                    for (let i = 0; i < Math.min(b.oreCount, 4); i++) {
                        graphics.fillCircle(positions[i].x, positions[i].y, dotSize);
                    }
                }

            } else if (b.type === 'alloy-drill') {
                // Alloy drill - 2x2 premium drill with advanced design
                const width = TILE_SIZE * 2;
                const height = TILE_SIZE * 2;
                
                // Premium alloy base
                graphics.fillStyle(0x7a5a4a);
                graphics.fillRoundedRect(px + 2, py + 2, width - 4, height - 4, 6);

                // Alloy housing with gradient effect
                graphics.fillStyle(0xb8967a);
                graphics.fillRoundedRect(px + 6, py + 6, width - 12, height - 12, 5);
                
                // Inner reinforced frame
                graphics.fillStyle(0xa88868);
                graphics.fillRoundedRect(px + 10, py + 10, width - 20, height - 20, 4);

                // Decorative corner reinforcements
                graphics.fillStyle(0xd4a574);
                const cornerSize = 8;
                graphics.fillRoundedRect(px + 8, py + 8, cornerSize, cornerSize, 2);
                graphics.fillRoundedRect(px + width - 16, py + 8, cornerSize, cornerSize, 2);
                graphics.fillRoundedRect(px + 8, py + height - 16, cornerSize, cornerSize, 2);
                graphics.fillRoundedRect(px + width - 16, py + height - 16, cornerSize, cornerSize, 2);

                // Ultra-fast rotating drill (4x speed, 6 blades)
                const aDrillAngle = (Date.now() / 25) % (Math.PI * 2);
                
                // Outer drill ring
                graphics.fillStyle(0x9a8a7a);
                graphics.fillCircle(px + width/2, py + height/2, 18);
                
                // Six rotating cutting blades
                graphics.fillStyle(0xeeeeee);
                for (let i = 0; i < 6; i++) {
                    const a = aDrillAngle + i * Math.PI / 3;
                    const bladeX = px + width/2 + Math.cos(a) * 14;
                    const bladeY = py + height/2 + Math.sin(a) * 14;
                    // Diamond-shaped blade
                    graphics.fillCircle(bladeX, bladeY, 5);
                    graphics.fillRect(bladeX - 2, bladeY - 4, 4, 8);
                }
                
                // Central hub with metallic look
                graphics.fillStyle(0x666666);
                graphics.fillCircle(px + width/2, py + height/2, 11);
                graphics.fillStyle(0xaaaaaa);
                graphics.fillCircle(px + width/2, py + height/2, 8);
                graphics.fillStyle(0xcccccc);
                graphics.fillCircle(px + width/2, py + height/2, 5);

                // Premium detail lines
                graphics.fillStyle(0xd4a574);
                // Horizontal and vertical accent lines
                graphics.fillRect(px + width/2 - 1, py + 12, 2, 10);
                graphics.fillRect(px + width/2 - 1, py + height - 22, 2, 10);
                graphics.fillRect(px + 12, py + height/2 - 1, 10, 2);
                graphics.fillRect(px + width - 22, py + height/2 - 1, 10, 2);

                drawArrow(px + width/2, py + height/2, b.rotation, 0xd4a574);

                // Ore count indicator (use brighter green to distinguish from premium dots)
                if (b.oreCount && b.oreCount > 1) {
                    graphics.fillStyle(0x44ff44);
                    const dotSize = 4;
                    // Position near center top
                    const startX = px + width/2 - (b.oreCount - 1) * 5;
                    for (let i = 0; i < Math.min(b.oreCount, 4); i++) {
                        graphics.fillCircle(startX + i * 10, py + 8, dotSize);
                    }
                }

            } else if (b.type === 'graphite-press') {
                // 2x2 Graphite Press - top-down view
                const pressW = TILE_SIZE * 2;
                const pressH = TILE_SIZE * 2;
                
                // Main press body - dark gray base
                graphics.fillStyle(0x1a1a1a);
                graphics.fillRoundedRect(px + 2, py + 2, pressW - 4, pressH - 4, 6);
                
                // Press platform
                graphics.fillStyle(0x2a2a2a);
                graphics.fillRoundedRect(px + 6, py + 6, pressW - 12, pressH - 12, 4);
                
                // Four compression pistons at corners
                const pistonSize = b.craftProgress ? 
                    8 + Math.sin((b.craftProgress / BUILDINGS['graphite-press'].craftTime) * Math.PI * 2) * 3 : 8;
                graphics.fillStyle(0x555555);
                graphics.fillCircle(px + 16, py + 16, pistonSize);
                graphics.fillCircle(px + pressW - 16, py + 16, pistonSize);
                graphics.fillCircle(px + 16, py + pressH - 16, pistonSize);
                graphics.fillCircle(px + pressW - 16, py + pressH - 16, pistonSize);
                
                // Central compression chamber
                graphics.fillStyle(0x3a3a3a);
                graphics.fillRoundedRect(px + pressW/2 - 12, py + pressH/2 - 12, 24, 24, 3);
                
                // Compression indicator in center
                if (b.craftProgress > 0) {
                    const progress = b.craftProgress / BUILDINGS['graphite-press'].craftTime;
                    graphics.fillStyle(0x222222, 0.3 + progress * 0.5);
                    graphics.fillCircle(px + pressW/2, py + pressH/2, 10);
                }
                
                // Storage indicators - coal on left, graphite output on right
                if (b.coalStored > 0) {
                    const coalPct = Math.min(1, b.coalStored / 2);
                    graphics.fillStyle(0x444444);
                    graphics.fillRect(px + 8, py + pressH/2 - 8, 12 * coalPct, 16);
                }
                
                // Output direction arrow
                drawArrow(px + pressW/2, py + pressH/2, b.rotation, 0x666666);

            } else if (b.type === 'alloy-factory') {
                // 2x2 Alloy Factory - highly visible industrial building
                const factoryW = TILE_SIZE * 2;
                const factoryH = TILE_SIZE * 2;
                
                // Main factory building - dark industrial brown
                graphics.fillStyle(0x443322);
                graphics.fillRoundedRect(px + 2, py + 2, factoryW - 4, factoryH - 4, 6);
                
                // Factory walls
                graphics.fillStyle(0x665544);
                graphics.fillRoundedRect(px + 6, py + 6, factoryW - 12, factoryH - 12, 4);
                
                // Lead and titanium input hoppers
                graphics.fillStyle(0x888899);  // Lead hopper
                graphics.fillRect(px + 8, py + 8, 12, 10);
                graphics.fillStyle(0x4a7c9b);  // Titanium hopper
                graphics.fillRect(px + factoryW - 20, py + 8, 12, 10);
                
                // Furnace glow in center
                const glowIntensity = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                graphics.fillStyle(0xff6600, glowIntensity * 0.6);
                graphics.fillCircle(px + factoryW/2, py + factoryH/2, 14);
                graphics.fillStyle(0xffaa00, glowIntensity * 0.8);
                graphics.fillCircle(px + factoryW/2, py + factoryH/2, 10);
                
                // Chimney with smoke
                graphics.fillStyle(0x333333);
                graphics.fillRect(px + factoryW - 16, py + 4, 8, 12);
                if (b.powered) {
                    const smokeOffset = (Date.now() / 100) % 20;
                    graphics.fillStyle(0x666666, 0.4);
                    graphics.fillCircle(px + factoryW - 12, py - smokeOffset, 4);
                    graphics.fillCircle(px + factoryW - 10, py - smokeOffset - 6, 3);
                }
                
                // Alloy output chute
                graphics.fillStyle(0xb8967a);
                graphics.fillRect(px + factoryW/2 - 6, py + factoryH - 8, 12, 6);
                
                // Windows
                graphics.fillStyle(0xffcc66, glowIntensity * 0.4);
                graphics.fillRect(px + 12, py + 24, 8, 10);
                graphics.fillRect(px + factoryW - 20, py + 24, 8, 10);
                
                // Storage indicators
                if (b.leadStored > 0) {
                    const leadBar = Math.min(1, b.leadStored / 10);
                    graphics.fillStyle(0x888899);
                    graphics.fillRect(px + 4, py + factoryH - 8, 10 * leadBar, 4);
                }
                if (b.titaniumStored > 0) {
                    const titaniumBar = Math.min(1, b.titaniumStored / 10);
                    graphics.fillStyle(0x4a7c9b);
                    graphics.fillRect(px + factoryW - 14, py + factoryH - 8, 10 * titaniumBar, 4);
                }
                
                // Craft progress indicator
                if (b.craftProgress > 0) {
                    const progress = b.craftProgress / BUILDINGS['alloy-factory'].craftTime;
                    graphics.fillStyle(0x44ff44);
                    graphics.fillRect(px + 4, py + 4, (factoryW - 8) * progress, 3);
                }
                
                // Power indicator
                if (!b.powered) {
                    graphics.fillStyle(0xff4444, 0.6);
                    graphics.fillRect(px + factoryW/2 - 8, py + factoryH/2 - 2, 16, 4);
                    graphics.fillStyle(0xff4444);
                    graphics.fillCircle(px + 8, py + 8, 3);
                }

            } else if (b.type === 'miner-constructor') {
                // 2x2 Miner Constructor
                const consW = TILE_SIZE * 2;
                const consH = TILE_SIZE * 2;

                // Base platform
                graphics.fillStyle(0x2a4a2a);
                graphics.fillRoundedRect(px + 2, py + 2, consW - 4, consH - 4, 6);

                // Construction bay
                graphics.fillStyle(0x44aa44);
                graphics.fillRoundedRect(px + 8, py + 8, consW - 16, consH - 16, 4);

                // Assembly arms
                graphics.fillStyle(0x666666);
                graphics.fillRect(px + 10, py + 10, 4, consH - 20);
                graphics.fillRect(px + consW - 14, py + 10, 4, consH - 20);

                // Lead and titanium input hoppers
                graphics.fillStyle(0x888899);  // Lead hopper
                graphics.fillRect(px + 8, py + 8, 12, 10);
                graphics.fillStyle(0x4a7c9b);  // Titanium hopper
                graphics.fillRect(px + consW - 20, py + 8, 12, 10);

                // Construction platform in center (animated if crafting)
                if (b.craftProgress > 0) {
                    const progress = b.craftProgress / BUILDINGS['miner-constructor'].craftTime;

                    // Draw semi-transparent miner sprite being fabricated
                    const minerAlpha = progress * 0.7; // Fade in as progress increases
                    const centerX = px + consW/2;
                    const centerY = py + consH/2;

                    // Miner body (ghost image)
                    graphics.fillStyle(0x4CAF50, minerAlpha);
                    graphics.fillCircle(centerX, centerY, 8);

                    // Miner propeller effect
                    graphics.fillStyle(0x66BB66, minerAlpha * 0.5);
                    graphics.fillCircle(centerX - 6, centerY - 6, 3);
                    graphics.fillCircle(centerX + 6, centerY - 6, 3);

                    // Scanning line animation with ease-in-out (slow at edges, fast in middle)
                    const scanTime = Date.now() % 1200; // 1200ms loop
                    let scanLinear = scanTime < 600 ? scanTime / 600 : (1200 - scanTime) / 600; // Back and forth 0-1
                    // Apply ease-in-out (cubic bezier approximation: slow-fast-slow)
                    const scanProgress = scanLinear < 0.5
                        ? 4 * scanLinear * scanLinear * scanLinear
                        : 1 - Math.pow(-2 * scanLinear + 2, 3) / 2;
                    const scanX = px + 12 + (consW - 24) * scanProgress;

                    // Vertical scanning line
                    graphics.lineStyle(2, 0x44ffff, 0.8);
                    graphics.lineBetween(scanX, py + 12, scanX, py + consH - 12);

                    // Glow effect on scanning line
                    graphics.lineStyle(6, 0x44ffff, 0.3);
                    graphics.lineBetween(scanX, py + 12, scanX, py + consH - 12);

                    // Assembly effect particles
                    const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                    graphics.fillStyle(0x44ff44, pulse * 0.4);
                    graphics.fillCircle(centerX, centerY, 16);
                }

                // Storage indicators
                if (b.leadStored > 0) {
                    const leadBar = Math.min(1, b.leadStored / 100);
                    graphics.fillStyle(0x888899);
                    graphics.fillRect(px + 4, py + consH - 8, 20 * leadBar, 4);
                }
                if (b.titaniumStored > 0) {
                    const titaniumBar = Math.min(1, b.titaniumStored / 100);
                    graphics.fillStyle(0x4a7c9b);
                    graphics.fillRect(px + consW - 24, py + consH - 8, 20 * titaniumBar, 4);
                }

                // Craft progress indicator
                if (b.craftProgress > 0) {
                    const progress = b.craftProgress / BUILDINGS['miner-constructor'].craftTime;
                    graphics.fillStyle(0x44ff44);
                    graphics.fillRect(px + 4, py + 4, (consW - 8) * progress, 3);
                }

            } else if (b.type === 'conveyor' || b.type === 'alloy-conveyor') {
                // Conveyor belt with proper turns - proportional to straight conveyors
                const isAlloy = b.type === 'alloy-conveyor';
                const dir = getDirection(b.rotation);
                const beltSpeed = isAlloy ? 75 : 150;
                const beltPhase = (Date.now() / beltSpeed) % 1;

                // Detect neighboring conveyors to determine if this is a turn
                const inputDir = { x: -dir.x, y: -dir.y }; // Opposite of output
                const leftDir = { x: dir.y, y: -dir.x };
                const rightDir = { x: -dir.y, y: dir.x };

                // Check for input conveyor (one that outputs to this tile)
                const getConveyorAt = (tx, ty) => {
                    return buildings.find(ob =>
                        (ob.type === 'conveyor' || ob.type === 'alloy-conveyor') &&
                        ob.x === tx && ob.y === ty
                    );
                };

                const backConveyor = getConveyorAt(b.x + inputDir.x, b.y + inputDir.y);
                const leftConveyor = getConveyorAt(b.x + leftDir.x, b.y + leftDir.y);
                const rightConveyor = getConveyorAt(b.x + rightDir.x, b.y + rightDir.y);

                // Check if neighbor outputs to us
                const outputsToUs = (neighbor, fromDir) => {
                    if (!neighbor) return false;
                    const nDir = getDirection(neighbor.rotation);
                    return nDir.x === -fromDir.x && nDir.y === -fromDir.y;
                };

                const hasBackInput = backConveyor && outputsToUs(backConveyor, inputDir);
                const hasLeftInput = leftConveyor && outputsToUs(leftConveyor, leftDir);
                const hasRightInput = rightConveyor && outputsToUs(rightConveyor, rightDir);

                // Determine conveyor type: straight, turn-left, turn-right
                let isTurnLeft = !hasBackInput && hasLeftInput && !hasRightInput;
                let isTurnRight = !hasBackInput && hasRightInput && !hasLeftInput;

                // Colors with textured look
                const baseColor = isAlloy ? 0x3a2a1a : 0x252525;
                const beltColor = isAlloy ? 0x5a4a3a : 0x3a3a3a;
                const beltColorLight = isAlloy ? 0x6a5a4a : 0x484848;
                const arrowColor = isAlloy ? 0x8a7a6a : 0x5a5a5a;
                const railColor = isAlloy ? 0x8a7a6a : 0x666666;
                const railHighlight = isAlloy ? 0xaa9a8a : 0x888888;
                const railShadow = isAlloy ? 0x5a4a3a : 0x444444;

                // Base with subtle texture pattern
                graphics.fillStyle(baseColor);
                graphics.fillRect(px, py, TILE_SIZE, TILE_SIZE);

                // Belt width matches straight conveyor (TILE_SIZE - 6 for rails on each side)
                const railWidth = 3;
                const beltInset = railWidth;
                const beltWidth = TILE_SIZE - (railWidth * 2);

                if (isTurnLeft || isTurnRight) {
                    // Draw curved conveyor turn - PROPORTIONAL to straight conveyor
                    // Inner and outer radius should create belt width equal to straight conveyor
                    const innerRadius = beltInset; // Start from rail edge
                    const outerRadius = TILE_SIZE - beltInset; // End at other rail edge

                    // Determine corner position based on rotation and turn direction
                    let cornerX, cornerY, startAngle, endAngle;

                    if (b.rotation === 0) { // Facing right
                        if (isTurnLeft) { cornerX = px + TILE_SIZE; cornerY = py; startAngle = Math.PI / 2; endAngle = Math.PI; }
                        else { cornerX = px + TILE_SIZE; cornerY = py + TILE_SIZE; startAngle = Math.PI; endAngle = Math.PI * 1.5; }
                    } else if (b.rotation === 1) { // Facing down
                        if (isTurnLeft) { cornerX = px + TILE_SIZE; cornerY = py + TILE_SIZE; startAngle = Math.PI; endAngle = Math.PI * 1.5; }
                        else { cornerX = px; cornerY = py + TILE_SIZE; startAngle = Math.PI * 1.5; endAngle = Math.PI * 2; }
                    } else if (b.rotation === 2) { // Facing left
                        if (isTurnLeft) { cornerX = px; cornerY = py + TILE_SIZE; startAngle = Math.PI * 1.5; endAngle = Math.PI * 2; }
                        else { cornerX = px; cornerY = py; startAngle = 0; endAngle = Math.PI / 2; }
                    } else { // Facing up
                        if (isTurnLeft) { cornerX = px; cornerY = py; startAngle = 0; endAngle = Math.PI / 2; }
                        else { cornerX = px + TILE_SIZE; cornerY = py; startAngle = Math.PI / 2; endAngle = Math.PI; }
                    }

                    // Draw curved belt surface with gradient effect
                    graphics.fillStyle(beltColor);
                    graphics.beginPath();
                    graphics.arc(cornerX, cornerY, outerRadius, startAngle, endAngle, false);
                    graphics.arc(cornerX, cornerY, innerRadius, endAngle, startAngle, true);
                    graphics.closePath();
                    graphics.fillPath();

                    // Belt texture - subtle ridges along the curve
                    graphics.fillStyle(beltColorLight, 0.4);
                    const ridgeCount = 5;
                    for (let r = 0; r < ridgeCount; r++) {
                        const ridgeRadius = innerRadius + (outerRadius - innerRadius) * (r / ridgeCount);
                        graphics.lineStyle(1, beltColorLight, 0.3);
                        graphics.beginPath();
                        graphics.arc(cornerX, cornerY, ridgeRadius, startAngle, endAngle, false);
                        graphics.strokePath();
                    }

                    // Inner rail (curved) with 3D effect
                    graphics.lineStyle(railWidth, railShadow, 1);
                    graphics.beginPath();
                    graphics.arc(cornerX, cornerY, innerRadius, startAngle, endAngle, false);
                    graphics.strokePath();
                    graphics.lineStyle(1, railHighlight, 0.8);
                    graphics.beginPath();
                    graphics.arc(cornerX, cornerY, innerRadius + 1, startAngle, endAngle, false);
                    graphics.strokePath();

                    // Outer rail (curved) with 3D effect
                    graphics.lineStyle(railWidth, railColor, 1);
                    graphics.beginPath();
                    graphics.arc(cornerX, cornerY, outerRadius, startAngle, endAngle, false);
                    graphics.strokePath();
                    graphics.lineStyle(1, railHighlight, 0.6);
                    graphics.beginPath();
                    graphics.arc(cornerX, cornerY, outerRadius - 1, startAngle, endAngle, false);
                    graphics.strokePath();

                    // Curved arrows - chevron style matching straight conveyor
                    const midRadius = (innerRadius + outerRadius) / 2;
                    for (let i = 0; i < 3; i++) {
                        const progress = ((i / 3 + beltPhase) % 1);
                        const angle = startAngle + (endAngle - startAngle) * progress;
                        const arrowX = cornerX + Math.cos(angle) * midRadius;
                        const arrowY = cornerY + Math.sin(angle) * midRadius;

                        // Arrow pointing along curve tangent
                        const tangentAngle = angle + Math.PI / 2;
                        graphics.fillStyle(arrowColor);
                        graphics.beginPath();
                        graphics.moveTo(arrowX + Math.cos(tangentAngle - 2.5) * 5, arrowY + Math.sin(tangentAngle - 2.5) * 5);
                        graphics.lineTo(arrowX + Math.cos(tangentAngle) * 6, arrowY + Math.sin(tangentAngle) * 6);
                        graphics.lineTo(arrowX + Math.cos(tangentAngle + 2.5) * 5, arrowY + Math.sin(tangentAngle + 2.5) * 5);
                        graphics.closePath();
                        graphics.fillPath();
                    }

                    // Corner bolts for industrial look
                    graphics.fillStyle(0x555555);
                    graphics.fillCircle(cornerX + (cornerX < px + TILE_SIZE/2 ? 4 : -4),
                                       cornerY + (cornerY < py + TILE_SIZE/2 ? 4 : -4), 2);

                } else {
                    // Straight conveyor with textured belt
                    // Main belt surface
                    graphics.fillStyle(beltColor);
                    graphics.fillRect(px + railWidth, py + railWidth, TILE_SIZE - railWidth*2, TILE_SIZE - railWidth*2);

                    // Belt texture - horizontal/vertical ridges based on direction
                    graphics.fillStyle(beltColorLight, 0.3);
                    const ridgeSpacing = 4;
                    if (dir.x !== 0) {
                        for (let ry = py + railWidth + 2; ry < py + TILE_SIZE - railWidth; ry += ridgeSpacing) {
                            graphics.fillRect(px + railWidth, ry, TILE_SIZE - railWidth*2, 1);
                        }
                    } else {
                        for (let rx = px + railWidth + 2; rx < px + TILE_SIZE - railWidth; rx += ridgeSpacing) {
                            graphics.fillRect(rx, py + railWidth, 1, TILE_SIZE - railWidth*2);
                        }
                    }

                    // Moving chevron/arrow indicators
                    for (let i = 0; i < 4; i++) {
                        const progress = ((i / 4 + beltPhase) % 1);
                        let arrowX, arrowY;

                        if (dir.x !== 0) {
                            arrowX = px + railWidth + 2 + progress * (TILE_SIZE - railWidth*2 - 4);
                            arrowY = py + TILE_SIZE / 2;
                            graphics.fillStyle(arrowColor);
                            graphics.beginPath();
                            if (dir.x > 0) {
                                graphics.moveTo(arrowX - 3, arrowY - 5);
                                graphics.lineTo(arrowX + 3, arrowY);
                                graphics.lineTo(arrowX - 3, arrowY + 5);
                            } else {
                                graphics.moveTo(arrowX + 3, arrowY - 5);
                                graphics.lineTo(arrowX - 3, arrowY);
                                graphics.lineTo(arrowX + 3, arrowY + 5);
                            }
                            graphics.closePath();
                            graphics.fillPath();
                        } else {
                            arrowX = px + TILE_SIZE / 2;
                            arrowY = py + railWidth + 2 + progress * (TILE_SIZE - railWidth*2 - 4);
                            graphics.fillStyle(arrowColor);
                            graphics.beginPath();
                            if (dir.y > 0) {
                                graphics.moveTo(arrowX - 5, arrowY - 3);
                                graphics.lineTo(arrowX, arrowY + 3);
                                graphics.lineTo(arrowX + 5, arrowY - 3);
                            } else {
                                graphics.moveTo(arrowX - 5, arrowY + 3);
                                graphics.lineTo(arrowX, arrowY - 3);
                                graphics.lineTo(arrowX + 5, arrowY + 3);
                            }
                            graphics.closePath();
                            graphics.fillPath();
                        }
                    }

                    // Metallic side rails with 3D effect
                    if (dir.x !== 0) {
                        // Top rail
                        graphics.fillStyle(railShadow);
                        graphics.fillRect(px, py, TILE_SIZE, railWidth);
                        graphics.fillStyle(railHighlight, 0.7);
                        graphics.fillRect(px, py, TILE_SIZE, 1);
                        // Bottom rail
                        graphics.fillStyle(railColor);
                        graphics.fillRect(px, py + TILE_SIZE - railWidth, TILE_SIZE, railWidth);
                        graphics.fillStyle(railHighlight, 0.5);
                        graphics.fillRect(px, py + TILE_SIZE - railWidth, TILE_SIZE, 1);
                    } else {
                        // Left rail
                        graphics.fillStyle(railShadow);
                        graphics.fillRect(px, py, railWidth, TILE_SIZE);
                        graphics.fillStyle(railHighlight, 0.7);
                        graphics.fillRect(px, py, 1, TILE_SIZE);
                        // Right rail
                        graphics.fillStyle(railColor);
                        graphics.fillRect(px + TILE_SIZE - railWidth, py, railWidth, TILE_SIZE);
                        graphics.fillStyle(railHighlight, 0.5);
                        graphics.fillRect(px + TILE_SIZE - railWidth, py, 1, TILE_SIZE);
                    }

                    // Roller wheels with metallic shine
                    const wheelColor = isAlloy ? 0x7a6a5a : 0x505050;
                    const wheelHighlight = isAlloy ? 0x9a8a7a : 0x707070;
                    if (dir.x !== 0) {
                        graphics.fillStyle(wheelColor);
                        graphics.fillCircle(px + 5, py + TILE_SIZE / 2, 3);
                        graphics.fillCircle(px + TILE_SIZE - 5, py + TILE_SIZE / 2, 3);
                        graphics.fillStyle(wheelHighlight, 0.6);
                        graphics.fillCircle(px + 4, py + TILE_SIZE / 2 - 1, 1);
                        graphics.fillCircle(px + TILE_SIZE - 6, py + TILE_SIZE / 2 - 1, 1);
                    } else {
                        graphics.fillStyle(wheelColor);
                        graphics.fillCircle(px + TILE_SIZE / 2, py + 5, 3);
                        graphics.fillCircle(px + TILE_SIZE / 2, py + TILE_SIZE - 5, 3);
                        graphics.fillStyle(wheelHighlight, 0.6);
                        graphics.fillCircle(px + TILE_SIZE / 2 - 1, py + 4, 1);
                        graphics.fillCircle(px + TILE_SIZE / 2 - 1, py + TILE_SIZE - 6, 1);
                    }
                }

            } else if (b.type === 'payload-conveyor') {
                // Payload conveyor - 2x2 heavy-duty conveyor for drones
                const convW = TILE_SIZE * 2;
                const convH = TILE_SIZE * 2;

                // Base platform
                graphics.fillStyle(0x1a4c6b);
                graphics.fillRoundedRect(px, py, convW, convH, 4);

                const dir = getDirection(b.rotation);
                const beltPhase = (Date.now() / 150) % 1; // Slower movement

                // Heavy-duty belt surface
                graphics.fillStyle(0x2a5c7b);
                graphics.fillRect(px + 3, py + 3, convW - 6, convH - 6);

                // Inner belt area
                graphics.fillStyle(0x4a7c9b);
                graphics.fillRect(px + 6, py + 6, convW - 12, convH - 12);

                // Reinforced corner brackets
                graphics.fillStyle(0x5a8cab);
                // Top-left bracket
                graphics.fillRect(px + 2, py + 2, 12, 4);
                graphics.fillRect(px + 2, py + 2, 4, 12);
                // Top-right bracket
                graphics.fillRect(px + convW - 14, py + 2, 12, 4);
                graphics.fillRect(px + convW - 6, py + 2, 4, 12);
                // Bottom-left bracket
                graphics.fillRect(px + 2, py + convH - 6, 12, 4);
                graphics.fillRect(px + 2, py + convH - 14, 4, 12);
                // Bottom-right bracket
                graphics.fillRect(px + convW - 14, py + convH - 6, 12, 4);
                graphics.fillRect(px + convW - 6, py + convH - 14, 4, 12);

                // Directional rails based on rotation
                graphics.fillStyle(0x6a9cbb);
                if (dir.x !== 0) {
                    // Horizontal movement - draw horizontal rails
                    graphics.fillRect(px + 8, py + 8, convW - 16, 6);
                    graphics.fillRect(px + 8, py + convH - 14, convW - 16, 6);
                } else {
                    // Vertical movement - draw vertical rails
                    graphics.fillRect(px + 8, py + 8, 6, convH - 16);
                    graphics.fillRect(px + convW - 14, py + 8, 6, convH - 16);
                }

                // Moving chevron pattern to show direction
                for (let i = 0; i < 4; i++) {
                    const progress = ((i / 4 + beltPhase) % 1);
                    graphics.fillStyle(0x7aaccc, 0.5);

                    if (dir.x !== 0) {
                        // Horizontal chevrons
                        const lineX = px + 10 + progress * (convW - 20);
                        const chevronDir = dir.x > 0 ? 1 : -1;
                        graphics.lineStyle(2, 0x7aaccc, 0.6);
                        graphics.lineBetween(lineX, py + convH/2 - 10, lineX + chevronDir * 6, py + convH/2);
                        graphics.lineBetween(lineX, py + convH/2 + 10, lineX + chevronDir * 6, py + convH/2);
                    } else {
                        // Vertical chevrons
                        const lineY = py + 10 + progress * (convH - 20);
                        const chevronDir = dir.y > 0 ? 1 : -1;
                        graphics.lineStyle(2, 0x7aaccc, 0.6);
                        graphics.lineBetween(px + convW/2 - 10, lineY, px + convW/2, lineY + chevronDir * 6);
                        graphics.lineBetween(px + convW/2 + 10, lineY, px + convW/2, lineY + chevronDir * 6);
                    }
                }

                // Central platform for drone
                graphics.fillStyle(0x3a6c8b);
                graphics.fillCircle(px + convW/2, py + convH/2, 14);
                graphics.fillStyle(0x4a7c9b);
                graphics.fillCircle(px + convW/2, py + convH/2, 10);

                // Direction arrow in center
                drawArrow(px + convW/2, py + convH/2, b.rotation, 0x8acccf);

                // Show if it has a miner loaded
                if (b.payloadMiner) {
                    graphics.fillStyle(0x4CAF50, 0.9);
                    graphics.fillCircle(px + convW/2, py + convH/2, 12);
                    graphics.fillStyle(0x66ff66, 0.7);
                    graphics.fillCircle(px + convW/2, py + convH/2, 6);
                }

            } else if (b.type === 'router') {
                graphics.fillStyle(0x555577);
                graphics.fillRoundedRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8, 4);
                graphics.fillStyle(0x666699);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 8);

                // Distribution arrows
                graphics.fillStyle(0x8888aa);
                for (let i = 0; i < 4; i++) {
                    const a = i * Math.PI / 2;
                    graphics.fillRect(
                        px + TILE_SIZE/2 + Math.cos(a) * 10 - 2,
                        py + TILE_SIZE/2 + Math.sin(a) * 10 - 2,
                        4, 4
                    );
                }

            } else if (b.type === 'junction') {
                graphics.fillStyle(0x775555);
                graphics.fillRoundedRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8, 4);
                graphics.lineStyle(2, 0x996666);
                graphics.lineBetween(px + 4, py + TILE_SIZE/2, px + TILE_SIZE - 4, py + TILE_SIZE/2);
                graphics.lineBetween(px + TILE_SIZE/2, py + 4, px + TILE_SIZE/2, py + TILE_SIZE - 4);

            } else if (b.type === 'generator') {
                // Coal generator with furnace
                graphics.fillStyle(0x442200);
                graphics.fillRoundedRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4, 4);

                // Furnace housing
                graphics.fillStyle(0x663300);
                graphics.fillRoundedRect(px + 5, py + 5, TILE_SIZE - 10, TILE_SIZE - 10, 3);

                // Fire window
                if (b.active) {
                    const flicker = Math.sin(Date.now() / 80) * 0.3 + 0.7;
                    graphics.fillStyle(0xff3300, flicker);
                    graphics.fillRect(px + 10, py + 10, TILE_SIZE - 20, TILE_SIZE - 20);
                    graphics.fillStyle(0xff6600, flicker * 0.8);
                    graphics.fillRect(px + 12, py + 12, TILE_SIZE - 24, TILE_SIZE - 24);
                    graphics.fillStyle(0xffaa00, flicker * 0.6);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 4);
                } else {
                    graphics.fillStyle(0x333333);
                    graphics.fillRect(px + 10, py + 10, TILE_SIZE - 20, TILE_SIZE - 20);
                }

                // Chimney
                graphics.fillStyle(0x555555);
                graphics.fillRect(px + TILE_SIZE - 10, py + 2, 6, 8);

                // Coal level indicator
                if (b.coalStored > 0) {
                    const coalPct = Math.min(1, b.coalStored / 10);
                    graphics.fillStyle(0x222222);
                    graphics.fillRect(px + 2, py + TILE_SIZE - 6, (TILE_SIZE - 4) * coalPct, 4);
                }

            } else if (b.type === 'thermal-generator') {
                // Thermal generator - 2x2 advanced power plant
                const width = TILE_SIZE * 2;
                const height = TILE_SIZE * 2;

                // Base structure
                graphics.fillStyle(0x553300);
                graphics.fillRoundedRect(px + 2, py + 2, width - 4, height - 4, 6);

                // Reactor core housing
                graphics.fillStyle(0x774400);
                graphics.fillRoundedRect(px + 8, py + 8, width - 16, height - 16, 4);

                // Central reactor chamber
                if (b.active) {
                    const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
                    graphics.fillStyle(0xff4400, pulse);
                    graphics.fillCircle(px + width/2, py + height/2, 20);
                    graphics.fillStyle(0xff6600, pulse * 0.8);
                    graphics.fillCircle(px + width/2, py + height/2, 15);
                    graphics.fillStyle(0xffaa00, pulse * 0.6);
                    graphics.fillCircle(px + width/2, py + height/2, 10);
                } else {
                    graphics.fillStyle(0x444444);
                    graphics.fillCircle(px + width/2, py + height/2, 20);
                }

                // Heat vents
                graphics.fillStyle(0x666666);
                for (let i = 0; i < 4; i++) {
                    const angle = i * Math.PI / 2;
                    const vx = px + width/2 + Math.cos(angle) * 22;
                    const vy = py + height/2 + Math.sin(angle) * 22;
                    graphics.fillRect(vx - 2, vy - 6, 4, 12);
                }

                // Chimneys/exhaust
                graphics.fillStyle(0x555555);
                graphics.fillRect(px + 10, py + 2, 8, 10);
                graphics.fillRect(px + width - 18, py + 2, 8, 10);

                // Resource indicators
                if (b.coalStored > 0) {
                    const coalPct = Math.min(1, b.coalStored / 10);
                    graphics.fillStyle(0x222222);
                    graphics.fillRect(px + 4, py + height - 10, (width - 8) * coalPct * 0.5, 4);
                }
                if (b.leadStored > 0) {
                    const leadPct = Math.min(1, b.leadStored / 10);
                    graphics.fillStyle(0x666666);
                    graphics.fillRect(px + 4 + (width - 8) * 0.5, py + height - 10, (width - 8) * leadPct * 0.5, 4);
                }

            } else if (b.type === 'power-node') {
                // Power distribution node
                graphics.fillStyle(0x554400);
                graphics.fillRoundedRect(px + 8, py + 8, TILE_SIZE - 16, TILE_SIZE - 16, 4);

                // Electric coil
                graphics.fillStyle(0x886600);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 8);

                // Glowing core
                const glow = Math.sin(Date.now() / 100) * 0.3 + 0.5;
                graphics.fillStyle(0xffcc00, glow);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 5);
                graphics.fillStyle(0xffff88, glow * 0.8);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 3);

                // Connection points
                graphics.fillStyle(0xccaa00);
                graphics.fillCircle(px + TILE_SIZE/2, py + 4, 3);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE - 4, 3);
                graphics.fillCircle(px + 4, py + TILE_SIZE/2, 3);
                graphics.fillCircle(px + TILE_SIZE - 4, py + TILE_SIZE/2, 3);

                // Draw power connections
                const range = BUILDINGS['power-node'].powerRange * TILE_SIZE;
                const nx = b.x * TILE_SIZE + TILE_SIZE/2;
                const ny = b.y * TILE_SIZE + TILE_SIZE/2;

                buildings.forEach(other => {
                    if (other === b) return;
                    // Connect to power sources, other power nodes, and all power consumers
                    const isPowerSource = other.type === 'generator' || other.type === 'thermal-generator';
                    const isPowerNode = other.type === 'power-node' || other.type === 'large-power-node';
                    const isPowerConsumer = other.type === 'laser' || other.type === 'alloy-factory' || other.type === 'repair' || other.type === 'miner-constructor';

                    if (!isPowerSource && !isPowerNode && !isPowerConsumer) return;

                    const ow = other.width || 1;
                    const oh = other.height || 1;
                    const ox = (other.x + ow / 2) * TILE_SIZE;
                    const oy = (other.y + oh / 2) * TILE_SIZE;
                    const dist = Math.sqrt((ox - nx)**2 + (oy - ny)**2);

                    if (dist <= range) {
                        const screenOx = ox - camera.x;
                        const screenOy = oy - camera.y;
                        graphics.lineStyle(1, 0xffcc00, 0.4);
                        graphics.lineBetween(px + TILE_SIZE/2, py + TILE_SIZE/2, screenOx, screenOy);
                    }
                });

            } else if (b.type === 'large-power-node') {
                // Large Power Node - 2x2 with extended range
                const nodeW = TILE_SIZE * 2;
                const nodeH = TILE_SIZE * 2;
                const centerX = px + nodeW / 2;
                const centerY = py + nodeH / 2;

                // Base platform
                graphics.fillStyle(0x443300);
                graphics.fillRoundedRect(px + 2, py + 2, nodeW - 4, nodeH - 4, 6);

                // Inner housing
                graphics.fillStyle(0x665500);
                graphics.fillRoundedRect(px + 6, py + 6, nodeW - 12, nodeH - 12, 4);

                // Electric coils at corners
                graphics.fillStyle(0x887700);
                graphics.fillCircle(px + 14, py + 14, 6);
                graphics.fillCircle(px + nodeW - 14, py + 14, 6);
                graphics.fillCircle(px + 14, py + nodeH - 14, 6);
                graphics.fillCircle(px + nodeW - 14, py + nodeH - 14, 6);

                // Central large coil
                graphics.fillStyle(0x998800);
                graphics.fillCircle(centerX, centerY, 16);
                graphics.fillStyle(0x776600);
                graphics.fillCircle(centerX, centerY, 12);

                // Glowing core with pulse effect
                const lgGlow = Math.sin(Date.now() / 80) * 0.3 + 0.6;
                graphics.fillStyle(0xffdd00, lgGlow);
                graphics.fillCircle(centerX, centerY, 10);
                graphics.fillStyle(0xffff66, lgGlow * 0.9);
                graphics.fillCircle(centerX, centerY, 6);
                graphics.fillStyle(0xffffaa, lgGlow * 0.7);
                graphics.fillCircle(centerX, centerY, 3);

                // Connection points on all sides
                graphics.fillStyle(0xddbb00);
                graphics.fillCircle(centerX, py + 4, 4);
                graphics.fillCircle(centerX, py + nodeH - 4, 4);
                graphics.fillCircle(px + 4, centerY, 4);
                graphics.fillCircle(px + nodeW - 4, centerY, 4);

                // Energy arcs between corner coils
                const arcPulse = Math.sin(Date.now() / 60) * 0.4 + 0.6;
                graphics.lineStyle(2, 0xffee00, arcPulse * 0.5);
                graphics.lineBetween(px + 14, py + 14, px + nodeW - 14, py + 14);
                graphics.lineBetween(px + nodeW - 14, py + 14, px + nodeW - 14, py + nodeH - 14);
                graphics.lineBetween(px + nodeW - 14, py + nodeH - 14, px + 14, py + nodeH - 14);
                graphics.lineBetween(px + 14, py + nodeH - 14, px + 14, py + 14);

                // Draw power connections with extended range
                const lgRange = BUILDINGS['large-power-node'].powerRange * TILE_SIZE;
                const lgNx = (b.x + 1) * TILE_SIZE;
                const lgNy = (b.y + 1) * TILE_SIZE;

                buildings.forEach(other => {
                    if (other === b) return;
                    const isPowerSource = other.type === 'generator' || other.type === 'thermal-generator';
                    const isPowerNode = other.type === 'power-node' || other.type === 'large-power-node';
                    const isPowerConsumer = other.type === 'laser' || other.type === 'alloy-factory' || other.type === 'repair' || other.type === 'miner-constructor';

                    if (!isPowerSource && !isPowerNode && !isPowerConsumer) return;

                    const ow = other.width || 1;
                    const oh = other.height || 1;
                    const ox = (other.x + ow / 2) * TILE_SIZE;
                    const oy = (other.y + oh / 2) * TILE_SIZE;
                    const dist = Math.sqrt((ox - lgNx)**2 + (oy - lgNy)**2);

                    if (dist <= lgRange) {
                        const screenOx = ox - camera.x;
                        const screenOy = oy - camera.y;
                        graphics.lineStyle(2, 0xffdd00, 0.5);
                        graphics.lineBetween(centerX, centerY, screenOx, screenOy);
                    }
                });

            } else if (b.type === 'turret') {
                // Duo turret - realistic top-down with rotation and textures
                // Base platform with metallic texture
                graphics.fillStyle(0x2a2a2a);
                graphics.fillRoundedRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4, 5);

                // Platform texture lines
                graphics.fillStyle(0x3a3a3a, 0.5);
                graphics.fillRect(px + 4, py + 8, TILE_SIZE - 8, 1);
                graphics.fillRect(px + 4, py + 16, TILE_SIZE - 8, 1);
                graphics.fillRect(px + 4, py + 24, TILE_SIZE - 8, 1);

                // Turret base ring
                graphics.fillStyle(0x4a4a4a);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 13);
                graphics.fillStyle(0x3a3a3a);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 11);

                // Gun housing - red with metallic sheen
                graphics.fillStyle(0xaa3333);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);
                graphics.fillStyle(0xcc5555, 0.4);
                graphics.fillCircle(px + TILE_SIZE/2 - 2, py + TILE_SIZE/2 - 2, 4);

                // Dual barrels - rotated toward target
                const angle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                const cx = px + TILE_SIZE/2;
                const cy = py + TILE_SIZE/2;
                const barrelLength = 13;
                const barrelSpacing = 4;

                // Left barrel with shadow
                const lx1 = cx + Math.cos(angle) * barrelLength + Math.cos(angle + Math.PI/2) * barrelSpacing;
                const ly1 = cy + Math.sin(angle) * barrelLength + Math.sin(angle + Math.PI/2) * barrelSpacing;
                const lx2 = cx + Math.cos(angle + Math.PI/2) * barrelSpacing;
                const ly2 = cy + Math.sin(angle + Math.PI/2) * barrelSpacing;
                graphics.lineStyle(4, 0x444444);
                graphics.lineBetween(lx2, ly2, lx1, ly1);
                graphics.lineStyle(3, 0x666666);
                graphics.lineBetween(lx2, ly2, lx1, ly1);

                // Right barrel with shadow
                const rx1 = cx + Math.cos(angle) * barrelLength + Math.cos(angle - Math.PI/2) * barrelSpacing;
                const ry1 = cy + Math.sin(angle) * barrelLength + Math.sin(angle - Math.PI/2) * barrelSpacing;
                const rx2 = cx + Math.cos(angle - Math.PI/2) * barrelSpacing;
                const ry2 = cy + Math.sin(angle - Math.PI/2) * barrelSpacing;
                graphics.lineStyle(4, 0x444444);
                graphics.lineBetween(rx2, ry2, rx1, ry1);
                graphics.lineStyle(3, 0x666666);
                graphics.lineBetween(rx2, ry2, rx1, ry1);

                // Barrel tips with muzzle flash hint
                graphics.fillStyle(0x888888);
                graphics.fillCircle(lx1, ly1, 2);
                graphics.fillCircle(rx1, ry1, 2);
                graphics.fillStyle(0x222222);
                graphics.fillCircle(lx1, ly1, 1);
                graphics.fillCircle(rx1, ry1, 1);

                // Corner bolts for industrial look
                graphics.fillStyle(0x555555);
                graphics.fillCircle(px + 5, py + 5, 2);
                graphics.fillCircle(px + TILE_SIZE - 5, py + 5, 2);
                graphics.fillCircle(px + 5, py + TILE_SIZE - 5, 2);
                graphics.fillCircle(px + TILE_SIZE - 5, py + TILE_SIZE - 5, 2);

                // Ammo indicator bar
                if (b.ammo !== undefined) {
                    const ammoPct = Math.min(1, b.ammo / 20);
                    graphics.fillStyle(0x222222);
                    graphics.fillRect(px + 3, py + TILE_SIZE - 6, TILE_SIZE - 6, 3);
                    graphics.fillStyle(ammoPct > 0.3 ? 0x44ff44 : 0xff4444);
                    graphics.fillRect(px + 3, py + TILE_SIZE - 6, (TILE_SIZE - 6) * ammoPct, 3);
                }

            } else if (b.type === 'scatter') {
                // Scatter turret - triple barrel with rotation
                graphics.fillStyle(0x333333);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                graphics.fillStyle(0x444444);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 12);

                graphics.fillStyle(0xcc6633);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                // Triple barrels - rotated toward target
                const scatterAngle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                const scx = px + TILE_SIZE/2;
                const scy = py + TILE_SIZE/2;
                const scBarrelLength = 11;

                graphics.lineStyle(4, 0x666666);
                for (let i = -1; i <= 1; i++) {
                    const spreadAngle = scatterAngle + i * 0.15;
                    const bx1 = scx;
                    const by1 = scy;
                    const bx2 = scx + Math.cos(spreadAngle) * scBarrelLength;
                    const by2 = scy + Math.sin(spreadAngle) * scBarrelLength;
                    graphics.lineBetween(bx1, by1, bx2, by2);
                }

                // Ammo indicator
                if (b.ammo !== undefined) {
                    const ammoPct = Math.min(1, b.ammo / 20);
                    graphics.fillStyle(ammoPct > 0.3 ? 0x44ff44 : 0xff4444);
                    graphics.fillRect(px + 3, py + TILE_SIZE - 5, (TILE_SIZE - 6) * ammoPct, 2);
                }

            } else if (b.type === 'laser') {
                // Arc turret - electric with rotation
                graphics.fillStyle(0x222244);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                graphics.fillStyle(0x333366);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 12);

                if (b.powered) {
                    graphics.fillStyle(0x4466cc);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                    // Electric arcs
                    const spark = Math.sin(Date.now() / 50) * 0.5 + 0.5;
                    graphics.fillStyle(0x88aaff, spark);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 5);

                    // Tesla coil pointing toward target
                    const laserAngle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                    const coilX = px + TILE_SIZE/2 + Math.cos(laserAngle) * 8;
                    const coilY = py + TILE_SIZE/2 + Math.sin(laserAngle) * 8;
                    graphics.fillStyle(0xaaccff, spark);
                    graphics.fillCircle(coilX + Math.sin(Date.now() / 30) * 2, coilY + Math.cos(Date.now() / 30) * 2, 3);
                } else {
                    graphics.fillStyle(0x445566);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                    // No power X
                    graphics.lineStyle(2, 0xff4444, 0.8);
                    graphics.lineBetween(px + 8, py + 8, px + TILE_SIZE - 8, py + TILE_SIZE - 8);
                    graphics.lineBetween(px + TILE_SIZE - 8, py + 8, px + 8, py + TILE_SIZE - 8);
                }

            } else if (b.type === 'stormer') {
                // Stormer turret - sand blaster
                graphics.fillStyle(0x8a7a6a);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                // Turret base
                graphics.fillStyle(0xa89572);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 12);

                // Sand tank
                graphics.fillStyle(0xc9b592);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                // Nozzle pointing toward target
                const stormerAngle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                const nozzleLength = 13;
                const nozzleX = px + TILE_SIZE/2 + Math.cos(stormerAngle) * nozzleLength;
                const nozzleY = py + TILE_SIZE/2 + Math.sin(stormerAngle) * nozzleLength;
                
                graphics.lineStyle(4, 0x8a7a6a);
                graphics.lineBetween(px + TILE_SIZE/2, py + TILE_SIZE/2, nozzleX, nozzleY);
                
                // Nozzle tip
                graphics.fillStyle(0x6a5a4a);
                graphics.fillCircle(nozzleX, nozzleY, 3);

                // Ammo indicator
                if (b.ammo !== undefined) {
                    const ammoPct = Math.min(1, b.ammo / 20);
                    graphics.fillStyle(ammoPct > 0.3 ? 0xc9b592 : 0xff4444);
                    graphics.fillRect(px + 3, py + TILE_SIZE - 5, (TILE_SIZE - 6) * ammoPct, 2);
                }

            } else if (b.type === 'wall') {
                // Stone wall with textured brick pattern
                graphics.fillStyle(0x4a4a4a);
                graphics.fillRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);

                // Mortar lines
                graphics.fillStyle(0x3a3a3a);
                graphics.fillRect(px + 1, py + TILE_SIZE/2 - 1, TILE_SIZE - 2, 2);
                graphics.fillRect(px + TILE_SIZE/2 - 1, py + 1, 2, TILE_SIZE/2 - 2);
                graphics.fillRect(px + 1, py + TILE_SIZE/2 + 1, TILE_SIZE/2 - 2, 2);

                // Brick surfaces with slight variation
                graphics.fillStyle(0x5a5a5a);
                graphics.fillRect(px + 3, py + 3, TILE_SIZE/2 - 5, TILE_SIZE/2 - 5);
                graphics.fillRect(px + TILE_SIZE/2 + 1, py + 3, TILE_SIZE/2 - 5, TILE_SIZE/2 - 5);
                graphics.fillStyle(0x555555);
                graphics.fillRect(px + 3, py + TILE_SIZE/2 + 2, TILE_SIZE - 6, TILE_SIZE/2 - 5);

                // Stone texture spots
                graphics.fillStyle(0x666666, 0.4);
                graphics.fillCircle(px + 8, py + 8, 2);
                graphics.fillCircle(px + 22, py + 12, 2);
                graphics.fillCircle(px + 14, py + 22, 2);

                // Highlight edge
                graphics.fillStyle(0x6a6a6a, 0.5);
                graphics.fillRect(px + 2, py + 2, TILE_SIZE - 4, 1);
                graphics.fillRect(px + 2, py + 2, 1, TILE_SIZE - 4);

            } else if (b.type === 'titanium-wall') {
                // Reinforced titanium wall with metallic texture
                graphics.fillStyle(0x2a4a6a);
                graphics.fillRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);

                // Inner panel
                graphics.fillStyle(0x3a6a8a);
                graphics.fillRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6);

                // Brushed metal texture lines
                graphics.fillStyle(0x4a7a9a, 0.4);
                for (let ty = py + 5; ty < py + TILE_SIZE - 5; ty += 3) {
                    graphics.fillRect(px + 5, ty, TILE_SIZE - 10, 1);
                }

                // Metal shine gradient
                graphics.fillStyle(0x6a9aba, 0.5);
                graphics.fillRect(px + 4, py + 4, TILE_SIZE - 8, 6);

                // Reinforcement cross
                graphics.fillStyle(0x5a8aaa, 0.3);
                graphics.fillRect(px + TILE_SIZE/2 - 1, py + 6, 2, TILE_SIZE - 12);
                graphics.fillRect(px + 6, py + TILE_SIZE/2 - 1, TILE_SIZE - 12, 2);

                // Corner rivets with highlights
                graphics.fillStyle(0x2a4a6a);
                graphics.fillCircle(px + 6, py + 6, 3);
                graphics.fillCircle(px + TILE_SIZE - 6, py + 6, 3);
                graphics.fillCircle(px + 6, py + TILE_SIZE - 6, 3);
                graphics.fillCircle(px + TILE_SIZE - 6, py + TILE_SIZE - 6, 3);
                graphics.fillStyle(0x5a8aaa, 0.6);
                graphics.fillCircle(px + 5, py + 5, 1);
                graphics.fillCircle(px + TILE_SIZE - 7, py + 5, 1);
                graphics.fillCircle(px + 5, py + TILE_SIZE - 7, 1);
                graphics.fillCircle(px + TILE_SIZE - 7, py + TILE_SIZE - 7, 1);

            } else if (b.type === 'alloy-wall') {
                // Reinforced alloy wall with premium texture
                graphics.fillStyle(0x6a5040);
                graphics.fillRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);

                // Inner panel with gradient effect
                graphics.fillStyle(0x9a7560);
                graphics.fillRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6);

                // Premium brushed metal texture
                graphics.fillStyle(0xaa8570, 0.3);
                for (let ty = py + 5; ty < py + TILE_SIZE - 5; ty += 2) {
                    graphics.fillRect(px + 5, ty, TILE_SIZE - 10, 1);
                }

                // Golden shine effect
                graphics.fillStyle(0xc0a080, 0.6);
                graphics.fillRect(px + 4, py + 4, TILE_SIZE - 8, 5);
                graphics.fillStyle(0xd0b090, 0.3);
                graphics.fillRect(px + 6, py + 6, TILE_SIZE - 12, 2);

                // Reinforcement pattern
                graphics.fillStyle(0x8a6550, 0.4);
                graphics.fillRect(px + 8, py + 8, TILE_SIZE - 16, TILE_SIZE - 16);

                // Heavy rivets with metallic look
                graphics.fillStyle(0x5a4030);
                graphics.fillCircle(px + 6, py + 6, 3);
                graphics.fillCircle(px + TILE_SIZE - 6, py + 6, 3);
                graphics.fillCircle(px + 6, py + TILE_SIZE - 6, 3);
                graphics.fillCircle(px + TILE_SIZE - 6, py + TILE_SIZE - 6, 3);

            } else if (b.type === 'alloy-turret') {
                // Salvo turret - alloy rapid fire with rotation
                graphics.fillStyle(0x444444);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                // Turret base
                graphics.fillStyle(0x555555);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 12);

                // Gun housing - alloy colored
                graphics.fillStyle(0xb8967a);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 9);

                // Quad barrels - rotated toward target
                const salvoAngle = b.turretAngle !== undefined ? b.turretAngle : -Math.PI/2;
                const salvoX = px + TILE_SIZE/2;
                const salvoY = py + TILE_SIZE/2;
                const salvoBarrelLength = 13;

                graphics.lineStyle(2, 0x666666);
                for (let i = -1.5; i <= 1.5; i++) {
                    const spreadAngle = salvoAngle + i * 0.12;
                    const bx2 = salvoX + Math.cos(spreadAngle) * salvoBarrelLength;
                    const by2 = salvoY + Math.sin(spreadAngle) * salvoBarrelLength;
                    graphics.lineBetween(salvoX, salvoY, bx2, by2);
                }

                // Ammo indicator
                if (b.ammo !== undefined) {
                    const ammoPct = Math.min(1, b.ammo / 20);
                    graphics.fillStyle(ammoPct > 0.3 ? 0x44ff44 : 0xff4444);
                    graphics.fillRect(px + 3, py + TILE_SIZE - 5, (TILE_SIZE - 6) * ammoPct, 2);
                }

            } else if (b.type === 'explosive') {
                // Explosive bomb
                const pulseAlpha = Math.sin(Date.now() / 300) * 0.2 + 0.8;

                graphics.fillStyle(0x332211);
                graphics.fillRoundedRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8, 4);

                // Bomb body
                graphics.fillStyle(0x883311);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 10);

                // Warning stripes
                graphics.fillStyle(0xffcc00);
                graphics.fillRect(px + TILE_SIZE/2 - 6, py + TILE_SIZE/2 - 2, 12, 2);
                graphics.fillRect(px + TILE_SIZE/2 - 6, py + TILE_SIZE/2 + 2, 12, 2);

                // Fuse
                graphics.lineStyle(2, 0x666666);
                graphics.lineBetween(px + TILE_SIZE/2, py + 4, px + TILE_SIZE/2, py + 8);

                // Sparking fuse tip
                const spark = Math.random() > 0.5;
                if (spark) {
                    graphics.fillStyle(0xff6600, pulseAlpha);
                    graphics.fillCircle(px + TILE_SIZE/2, py + 4, 2);
                }

            } else if (b.type === 'repair') {
                // Repair station
                graphics.fillStyle(0x225522);
                graphics.fillRoundedRect(px + 3, py + 3, TILE_SIZE - 6, TILE_SIZE - 6, 4);

                graphics.fillStyle(0x338833);
                graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 10);

                // Green cross
                graphics.fillStyle(0x44aa44);
                graphics.fillRect(px + TILE_SIZE/2 - 2, py + TILE_SIZE/2 - 8, 4, 16);
                graphics.fillRect(px + TILE_SIZE/2 - 8, py + TILE_SIZE/2 - 2, 16, 4);

                // Healing glow when enemies nearby
                if (enemies.length > 0) {
                    const healGlow = Math.sin(Date.now() / 200) * 0.2 + 0.3;
                    graphics.fillStyle(0x88ff88, healGlow);
                    graphics.fillCircle(px + TILE_SIZE/2, py + TILE_SIZE/2, 14);
                }
            }

            // Health bar for damaged buildings
            if (b.type !== 'core' && b.health < b.maxHealth) {
                const healthPct = b.health / b.maxHealth;
                graphics.fillStyle(0x333333);
                graphics.fillRect(px, py - 5, TILE_SIZE, 3);
                graphics.fillStyle(healthPct > 0.5 ? 0x44ff44 : (healthPct > 0.25 ? 0xffff00 : 0xff4444));
                graphics.fillRect(px, py - 5, TILE_SIZE * healthPct, 3);
            }
        }

        function drawArrow(x, y, rot, color) {
            const dir = getDirection(rot);
            const len = 8;
            graphics.lineStyle(2, color);
            graphics.lineBetween(x - dir.x * len, y - dir.y * len, x + dir.x * len, y + dir.y * len);

            const headLen = 5;
            const perpX = -dir.y;
            const perpY = dir.x;
            graphics.lineBetween(
                x + dir.x * len, y + dir.y * len,
                x + dir.x * (len - headLen) + perpX * headLen/2,
                y + dir.y * (len - headLen) + perpY * headLen/2
            );
            graphics.lineBetween(
                x + dir.x * len, y + dir.y * len,
                x + dir.x * (len - headLen) - perpX * headLen/2,
                y + dir.y * (len - headLen) - perpY * headLen/2
            );
        }

        function drawMinimap() {
            const minimap = document.getElementById('minimap');
            const ctx = minimap.getContext('2d');

            minimap.width = 180;
            minimap.height = 135;

            const scaleX = minimap.width / (MAP_WIDTH * TILE_SIZE);
            const scaleY = minimap.height / (MAP_HEIGHT * TILE_SIZE);

            // Draw terrain
            ctx.fillStyle = '#2a3a2a';
            ctx.fillRect(0, 0, minimap.width, minimap.height);

            // Draw buildings
            buildings.forEach(b => {
                if (b.type === 'core') {
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(b.x * TILE_SIZE * scaleX, b.y * TILE_SIZE * scaleY, TILE_SIZE * 3 * scaleX, TILE_SIZE * 3 * scaleY);
                } else {
                    ctx.fillStyle = b.type.includes('turret') || b.type === 'scatter' || b.type === 'laser' ? '#cc4444' :
                                   b.type.includes('wall') ? '#666666' :
                                   b.type === 'drill' || b.type === 'pneumatic-drill' ? '#8B4513' :
                                   '#555555';
                    ctx.fillRect(b.x * TILE_SIZE * scaleX, b.y * TILE_SIZE * scaleY, TILE_SIZE * scaleX, TILE_SIZE * scaleY);
                }
            });

            // Draw enemies
            ctx.fillStyle = '#ff4444';
            enemies.forEach(e => {
                if (e.delay <= 0) {
                    ctx.fillRect(e.x * scaleX - 1, e.y * scaleY - 1, 3, 3);
                }
            });

            // Draw player
            ctx.fillStyle = '#4488ff';
            ctx.fillRect(player.x * scaleX - 2, player.y * scaleY - 2, 5, 5);

            // Draw viewport rectangle
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(
                camera.x * scaleX,
                camera.y * scaleY,
                window.innerWidth * scaleX,
                window.innerHeight * scaleY
            );

            // Draw spawn point
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(spawnPoint.x * TILE_SIZE * scaleX + TILE_SIZE * scaleX / 2,
                   spawnPoint.y * TILE_SIZE * scaleY + TILE_SIZE * scaleY / 2, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw factory indicator arrow pointing to miner-constructor when off-screen
        function drawFactoryIndicator() {
            const factory = buildings.find(b => b.type === 'miner-constructor');
            if (!factory) {
                document.getElementById('factory-indicator').style.display = 'none';
                return;
            }

            // Calculate factory center in world coordinates
            const factoryX = (factory.x + 1) * TILE_SIZE; // 2x2 center
            const factoryY = (factory.y + 1) * TILE_SIZE;

            // Calculate factory position on screen
            const screenX = factoryX - camera.x;
            const screenY = factoryY - camera.y;

            // Check if factory is visible on screen (with some margin)
            const margin = 50;
            const isOnScreen = screenX >= -margin && screenX <= window.innerWidth / zoom + margin &&
                              screenY >= -margin && screenY <= window.innerHeight / zoom + margin;

            const indicator = document.getElementById('factory-indicator');

            if (isOnScreen) {
                indicator.style.display = 'none';
                return;
            }

            // Show indicator
            indicator.style.display = 'block';

            // Calculate angle from player to factory
            const dx = factoryX - player.x;
            const dy = factoryY - player.y;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Position indicator at screen edge
            const edgeMargin = 60;
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;

            // Calculate where the arrow should be placed (at screen edge)
            let indicatorX = centerX + Math.cos(angle) * (centerX - edgeMargin);
            let indicatorY = centerY + Math.sin(angle) * (centerY - edgeMargin);

            // Clamp to screen bounds
            indicatorX = Math.max(edgeMargin, Math.min(window.innerWidth - edgeMargin, indicatorX));
            indicatorY = Math.max(edgeMargin, Math.min(window.innerHeight - edgeMargin, indicatorY));

            indicator.style.left = (indicatorX - 50) + 'px';
            indicator.style.top = (indicatorY - 50) + 'px';

            // Draw arrow on canvas
            const ctx = indicator.getContext('2d');
            ctx.clearRect(0, 0, 100, 100);

            ctx.save();
            ctx.translate(50, 50);
            ctx.rotate(angle);

            // Arrow body
            ctx.fillStyle = '#44aa44';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.moveTo(25, 0);  // Tip
            ctx.lineTo(-15, -12);
            ctx.lineTo(-10, 0);
            ctx.lineTo(-15, 12);
            ctx.closePath();
            ctx.fill();

            // Arrow outline
            ctx.strokeStyle = '#88ff88';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Distance text
            ctx.restore();
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.globalAlpha = 1;
            const distText = Math.round(distance / TILE_SIZE) + 'm';
            ctx.fillText(distText, 50, 85);

            // Factory icon
            ctx.fillStyle = '#44ff44';
            ctx.font = '12px monospace';
            ctx.fillText('FAC', 50, 20);
        }

        // Initialize
        updateResourceUI();
        updatePlayerHealthUI();
    </script>
</body>
</html>
